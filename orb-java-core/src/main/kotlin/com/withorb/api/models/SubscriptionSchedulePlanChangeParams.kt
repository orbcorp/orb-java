// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.toUnmodifiable
import com.withorb.api.errors.OrbInvalidDataException
import com.withorb.api.models.*
import java.time.OffsetDateTime
import java.util.Objects
import java.util.Optional

class SubscriptionSchedulePlanChangeParams
constructor(
    private val subscriptionId: String,
    private val changeOption: ChangeOption,
    private val addAdjustments: List<AddAdjustment>?,
    private val addPrices: List<AddPrice>?,
    private val alignBillingWithPlanChangeDate: Boolean?,
    private val autoCollection: Boolean?,
    private val billingCycleAlignment: BillingCycleAlignment?,
    private val changeDate: OffsetDateTime?,
    private val couponRedemptionCode: String?,
    private val creditsOverageRate: Double?,
    private val defaultInvoiceMemo: String?,
    private val externalPlanId: String?,
    private val initialPhaseOrder: Long?,
    private val invoicingThreshold: String?,
    private val netTerms: Long?,
    private val perCreditOverageAmount: Double?,
    private val planId: String?,
    private val priceOverrides: List<PriceOverride>?,
    private val removeAdjustments: List<RemoveAdjustment>?,
    private val removePrices: List<RemovePrice>?,
    private val replaceAdjustments: List<ReplaceAdjustment>?,
    private val replacePrices: List<ReplacePrice>?,
    private val additionalQueryParams: Map<String, List<String>>,
    private val additionalHeaders: Map<String, List<String>>,
    private val additionalBodyProperties: Map<String, JsonValue>,
) {

    fun subscriptionId(): String = subscriptionId

    fun changeOption(): ChangeOption = changeOption

    fun addAdjustments(): Optional<List<AddAdjustment>> = Optional.ofNullable(addAdjustments)

    fun addPrices(): Optional<List<AddPrice>> = Optional.ofNullable(addPrices)

    fun alignBillingWithPlanChangeDate(): Optional<Boolean> =
        Optional.ofNullable(alignBillingWithPlanChangeDate)

    fun autoCollection(): Optional<Boolean> = Optional.ofNullable(autoCollection)

    fun billingCycleAlignment(): Optional<BillingCycleAlignment> =
        Optional.ofNullable(billingCycleAlignment)

    fun changeDate(): Optional<OffsetDateTime> = Optional.ofNullable(changeDate)

    fun couponRedemptionCode(): Optional<String> = Optional.ofNullable(couponRedemptionCode)

    fun creditsOverageRate(): Optional<Double> = Optional.ofNullable(creditsOverageRate)

    fun defaultInvoiceMemo(): Optional<String> = Optional.ofNullable(defaultInvoiceMemo)

    fun externalPlanId(): Optional<String> = Optional.ofNullable(externalPlanId)

    fun initialPhaseOrder(): Optional<Long> = Optional.ofNullable(initialPhaseOrder)

    fun invoicingThreshold(): Optional<String> = Optional.ofNullable(invoicingThreshold)

    fun netTerms(): Optional<Long> = Optional.ofNullable(netTerms)

    fun perCreditOverageAmount(): Optional<Double> = Optional.ofNullable(perCreditOverageAmount)

    fun planId(): Optional<String> = Optional.ofNullable(planId)

    fun priceOverrides(): Optional<List<PriceOverride>> = Optional.ofNullable(priceOverrides)

    fun removeAdjustments(): Optional<List<RemoveAdjustment>> =
        Optional.ofNullable(removeAdjustments)

    fun removePrices(): Optional<List<RemovePrice>> = Optional.ofNullable(removePrices)

    fun replaceAdjustments(): Optional<List<ReplaceAdjustment>> =
        Optional.ofNullable(replaceAdjustments)

    fun replacePrices(): Optional<List<ReplacePrice>> = Optional.ofNullable(replacePrices)

    @JvmSynthetic
    internal fun getBody(): SubscriptionSchedulePlanChangeBody {
        return SubscriptionSchedulePlanChangeBody(
            changeOption,
            addAdjustments,
            addPrices,
            alignBillingWithPlanChangeDate,
            autoCollection,
            billingCycleAlignment,
            changeDate,
            couponRedemptionCode,
            creditsOverageRate,
            defaultInvoiceMemo,
            externalPlanId,
            initialPhaseOrder,
            invoicingThreshold,
            netTerms,
            perCreditOverageAmount,
            planId,
            priceOverrides,
            removeAdjustments,
            removePrices,
            replaceAdjustments,
            replacePrices,
            additionalBodyProperties,
        )
    }

    @JvmSynthetic internal fun getQueryParams(): Map<String, List<String>> = additionalQueryParams

    @JvmSynthetic internal fun getHeaders(): Map<String, List<String>> = additionalHeaders

    fun getPathParam(index: Int): String {
        return when (index) {
            0 -> subscriptionId
            else -> ""
        }
    }

    @JsonDeserialize(builder = SubscriptionSchedulePlanChangeBody.Builder::class)
    @NoAutoDetect
    class SubscriptionSchedulePlanChangeBody
    internal constructor(
        private val changeOption: ChangeOption?,
        private val addAdjustments: List<AddAdjustment>?,
        private val addPrices: List<AddPrice>?,
        private val alignBillingWithPlanChangeDate: Boolean?,
        private val autoCollection: Boolean?,
        private val billingCycleAlignment: BillingCycleAlignment?,
        private val changeDate: OffsetDateTime?,
        private val couponRedemptionCode: String?,
        private val creditsOverageRate: Double?,
        private val defaultInvoiceMemo: String?,
        private val externalPlanId: String?,
        private val initialPhaseOrder: Long?,
        private val invoicingThreshold: String?,
        private val netTerms: Long?,
        private val perCreditOverageAmount: Double?,
        private val planId: String?,
        private val priceOverrides: List<PriceOverride>?,
        private val removeAdjustments: List<RemoveAdjustment>?,
        private val removePrices: List<RemovePrice>?,
        private val replaceAdjustments: List<ReplaceAdjustment>?,
        private val replacePrices: List<ReplacePrice>?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        @JsonProperty("change_option") fun changeOption(): ChangeOption? = changeOption

        /** Additional adjustments to be added to the subscription */
        @JsonProperty("add_adjustments") fun addAdjustments(): List<AddAdjustment>? = addAdjustments

        /** Additional prices to be added to the subscription */
        @JsonProperty("add_prices") fun addPrices(): List<AddPrice>? = addPrices

        /**
         * [DEPRECATED] Use billing_cycle_alignment instead. Reset billing periods to be aligned
         * with the plan change's effective date.
         */
        @JsonProperty("align_billing_with_plan_change_date")
        fun alignBillingWithPlanChangeDate(): Boolean? = alignBillingWithPlanChangeDate

        /**
         * Determines whether issued invoices for this subscription will automatically be charged
         * with the saved payment method on the due date. If not specified, this defaults to the
         * behavior configured for this customer.
         */
        @JsonProperty("auto_collection") fun autoCollection(): Boolean? = autoCollection

        /**
         * Reset billing periods to be aligned with the plan change's effective date or start of the
         * month. Defaults to `unchanged` which keeps subscription's existing billing cycle
         * alignment.
         */
        @JsonProperty("billing_cycle_alignment")
        fun billingCycleAlignment(): BillingCycleAlignment? = billingCycleAlignment

        /**
         * The date that the plan change should take effect. This parameter can only be passed if
         * the `change_option` is `requested_date`.
         */
        @JsonProperty("change_date") fun changeDate(): OffsetDateTime? = changeDate

        /**
         * Redemption code to be used for this subscription. If the coupon cannot be found by its
         * redemption code, or cannot be redeemed, an error response will be returned and the
         * subscription creation or plan change will not be scheduled.
         */
        @JsonProperty("coupon_redemption_code")
        fun couponRedemptionCode(): String? = couponRedemptionCode

        @JsonProperty("credits_overage_rate") fun creditsOverageRate(): Double? = creditsOverageRate

        /**
         * Determines the default memo on this subscription's invoices. Note that if this is not
         * provided, it is determined by the plan configuration.
         */
        @JsonProperty("default_invoice_memo") fun defaultInvoiceMemo(): String? = defaultInvoiceMemo

        /**
         * The external_plan_id of the plan that the given subscription should be switched to. Note
         * that either this property or `plan_id` must be specified.
         */
        @JsonProperty("external_plan_id") fun externalPlanId(): String? = externalPlanId

        /** The phase of the plan to start with */
        @JsonProperty("initial_phase_order") fun initialPhaseOrder(): Long? = initialPhaseOrder

        /**
         * When this subscription's accrued usage reaches this threshold, an invoice will be issued
         * for the subscription. If not specified, invoices will only be issued at the end of the
         * billing period.
         */
        @JsonProperty("invoicing_threshold") fun invoicingThreshold(): String? = invoicingThreshold

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0. If not
         * provided, this defaults to the value specified in the plan.
         */
        @JsonProperty("net_terms") fun netTerms(): Long? = netTerms

        @JsonProperty("per_credit_overage_amount")
        fun perCreditOverageAmount(): Double? = perCreditOverageAmount

        /**
         * The plan that the given subscription should be switched to. Note that either this
         * property or `external_plan_id` must be specified.
         */
        @JsonProperty("plan_id") fun planId(): String? = planId

        /** Optionally provide a list of overrides for prices on the plan */
        @JsonProperty("price_overrides") fun priceOverrides(): List<PriceOverride>? = priceOverrides

        /** Plan adjustments to be removed from the subscription */
        @JsonProperty("remove_adjustments")
        fun removeAdjustments(): List<RemoveAdjustment>? = removeAdjustments

        /** Plan prices to be removed from the subscription */
        @JsonProperty("remove_prices") fun removePrices(): List<RemovePrice>? = removePrices

        /** Plan adjustments to be replaced with additional adjustments on the subscription */
        @JsonProperty("replace_adjustments")
        fun replaceAdjustments(): List<ReplaceAdjustment>? = replaceAdjustments

        /** Plan prices to be replaced with additional prices on the subscription */
        @JsonProperty("replace_prices") fun replacePrices(): List<ReplacePrice>? = replacePrices

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is SubscriptionSchedulePlanChangeBody &&
                this.changeOption == other.changeOption &&
                this.addAdjustments == other.addAdjustments &&
                this.addPrices == other.addPrices &&
                this.alignBillingWithPlanChangeDate == other.alignBillingWithPlanChangeDate &&
                this.autoCollection == other.autoCollection &&
                this.billingCycleAlignment == other.billingCycleAlignment &&
                this.changeDate == other.changeDate &&
                this.couponRedemptionCode == other.couponRedemptionCode &&
                this.creditsOverageRate == other.creditsOverageRate &&
                this.defaultInvoiceMemo == other.defaultInvoiceMemo &&
                this.externalPlanId == other.externalPlanId &&
                this.initialPhaseOrder == other.initialPhaseOrder &&
                this.invoicingThreshold == other.invoicingThreshold &&
                this.netTerms == other.netTerms &&
                this.perCreditOverageAmount == other.perCreditOverageAmount &&
                this.planId == other.planId &&
                this.priceOverrides == other.priceOverrides &&
                this.removeAdjustments == other.removeAdjustments &&
                this.removePrices == other.removePrices &&
                this.replaceAdjustments == other.replaceAdjustments &&
                this.replacePrices == other.replacePrices &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        changeOption,
                        addAdjustments,
                        addPrices,
                        alignBillingWithPlanChangeDate,
                        autoCollection,
                        billingCycleAlignment,
                        changeDate,
                        couponRedemptionCode,
                        creditsOverageRate,
                        defaultInvoiceMemo,
                        externalPlanId,
                        initialPhaseOrder,
                        invoicingThreshold,
                        netTerms,
                        perCreditOverageAmount,
                        planId,
                        priceOverrides,
                        removeAdjustments,
                        removePrices,
                        replaceAdjustments,
                        replacePrices,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "SubscriptionSchedulePlanChangeBody{changeOption=$changeOption, addAdjustments=$addAdjustments, addPrices=$addPrices, alignBillingWithPlanChangeDate=$alignBillingWithPlanChangeDate, autoCollection=$autoCollection, billingCycleAlignment=$billingCycleAlignment, changeDate=$changeDate, couponRedemptionCode=$couponRedemptionCode, creditsOverageRate=$creditsOverageRate, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, initialPhaseOrder=$initialPhaseOrder, invoicingThreshold=$invoicingThreshold, netTerms=$netTerms, perCreditOverageAmount=$perCreditOverageAmount, planId=$planId, priceOverrides=$priceOverrides, removeAdjustments=$removeAdjustments, removePrices=$removePrices, replaceAdjustments=$replaceAdjustments, replacePrices=$replacePrices, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var changeOption: ChangeOption? = null
            private var addAdjustments: List<AddAdjustment>? = null
            private var addPrices: List<AddPrice>? = null
            private var alignBillingWithPlanChangeDate: Boolean? = null
            private var autoCollection: Boolean? = null
            private var billingCycleAlignment: BillingCycleAlignment? = null
            private var changeDate: OffsetDateTime? = null
            private var couponRedemptionCode: String? = null
            private var creditsOverageRate: Double? = null
            private var defaultInvoiceMemo: String? = null
            private var externalPlanId: String? = null
            private var initialPhaseOrder: Long? = null
            private var invoicingThreshold: String? = null
            private var netTerms: Long? = null
            private var perCreditOverageAmount: Double? = null
            private var planId: String? = null
            private var priceOverrides: List<PriceOverride>? = null
            private var removeAdjustments: List<RemoveAdjustment>? = null
            private var removePrices: List<RemovePrice>? = null
            private var replaceAdjustments: List<ReplaceAdjustment>? = null
            private var replacePrices: List<ReplacePrice>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                subscriptionSchedulePlanChangeBody: SubscriptionSchedulePlanChangeBody
            ) = apply {
                this.changeOption = subscriptionSchedulePlanChangeBody.changeOption
                this.addAdjustments = subscriptionSchedulePlanChangeBody.addAdjustments
                this.addPrices = subscriptionSchedulePlanChangeBody.addPrices
                this.alignBillingWithPlanChangeDate =
                    subscriptionSchedulePlanChangeBody.alignBillingWithPlanChangeDate
                this.autoCollection = subscriptionSchedulePlanChangeBody.autoCollection
                this.billingCycleAlignment =
                    subscriptionSchedulePlanChangeBody.billingCycleAlignment
                this.changeDate = subscriptionSchedulePlanChangeBody.changeDate
                this.couponRedemptionCode = subscriptionSchedulePlanChangeBody.couponRedemptionCode
                this.creditsOverageRate = subscriptionSchedulePlanChangeBody.creditsOverageRate
                this.defaultInvoiceMemo = subscriptionSchedulePlanChangeBody.defaultInvoiceMemo
                this.externalPlanId = subscriptionSchedulePlanChangeBody.externalPlanId
                this.initialPhaseOrder = subscriptionSchedulePlanChangeBody.initialPhaseOrder
                this.invoicingThreshold = subscriptionSchedulePlanChangeBody.invoicingThreshold
                this.netTerms = subscriptionSchedulePlanChangeBody.netTerms
                this.perCreditOverageAmount =
                    subscriptionSchedulePlanChangeBody.perCreditOverageAmount
                this.planId = subscriptionSchedulePlanChangeBody.planId
                this.priceOverrides = subscriptionSchedulePlanChangeBody.priceOverrides
                this.removeAdjustments = subscriptionSchedulePlanChangeBody.removeAdjustments
                this.removePrices = subscriptionSchedulePlanChangeBody.removePrices
                this.replaceAdjustments = subscriptionSchedulePlanChangeBody.replaceAdjustments
                this.replacePrices = subscriptionSchedulePlanChangeBody.replacePrices
                additionalProperties(subscriptionSchedulePlanChangeBody.additionalProperties)
            }

            @JsonProperty("change_option")
            fun changeOption(changeOption: ChangeOption) = apply {
                this.changeOption = changeOption
            }

            /** Additional adjustments to be added to the subscription */
            @JsonProperty("add_adjustments")
            fun addAdjustments(addAdjustments: List<AddAdjustment>) = apply {
                this.addAdjustments = addAdjustments
            }

            /** Additional prices to be added to the subscription */
            @JsonProperty("add_prices")
            fun addPrices(addPrices: List<AddPrice>) = apply { this.addPrices = addPrices }

            /**
             * [DEPRECATED] Use billing_cycle_alignment instead. Reset billing periods to be aligned
             * with the plan change's effective date.
             */
            @JsonProperty("align_billing_with_plan_change_date")
            fun alignBillingWithPlanChangeDate(alignBillingWithPlanChangeDate: Boolean) = apply {
                this.alignBillingWithPlanChangeDate = alignBillingWithPlanChangeDate
            }

            /**
             * Determines whether issued invoices for this subscription will automatically be
             * charged with the saved payment method on the due date. If not specified, this
             * defaults to the behavior configured for this customer.
             */
            @JsonProperty("auto_collection")
            fun autoCollection(autoCollection: Boolean) = apply {
                this.autoCollection = autoCollection
            }

            /**
             * Reset billing periods to be aligned with the plan change's effective date or start of
             * the month. Defaults to `unchanged` which keeps subscription's existing billing cycle
             * alignment.
             */
            @JsonProperty("billing_cycle_alignment")
            fun billingCycleAlignment(billingCycleAlignment: BillingCycleAlignment) = apply {
                this.billingCycleAlignment = billingCycleAlignment
            }

            /**
             * The date that the plan change should take effect. This parameter can only be passed
             * if the `change_option` is `requested_date`.
             */
            @JsonProperty("change_date")
            fun changeDate(changeDate: OffsetDateTime) = apply { this.changeDate = changeDate }

            /**
             * Redemption code to be used for this subscription. If the coupon cannot be found by
             * its redemption code, or cannot be redeemed, an error response will be returned and
             * the subscription creation or plan change will not be scheduled.
             */
            @JsonProperty("coupon_redemption_code")
            fun couponRedemptionCode(couponRedemptionCode: String) = apply {
                this.couponRedemptionCode = couponRedemptionCode
            }

            @JsonProperty("credits_overage_rate")
            fun creditsOverageRate(creditsOverageRate: Double) = apply {
                this.creditsOverageRate = creditsOverageRate
            }

            /**
             * Determines the default memo on this subscription's invoices. Note that if this is not
             * provided, it is determined by the plan configuration.
             */
            @JsonProperty("default_invoice_memo")
            fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
                this.defaultInvoiceMemo = defaultInvoiceMemo
            }

            /**
             * The external_plan_id of the plan that the given subscription should be switched to.
             * Note that either this property or `plan_id` must be specified.
             */
            @JsonProperty("external_plan_id")
            fun externalPlanId(externalPlanId: String) = apply {
                this.externalPlanId = externalPlanId
            }

            /** The phase of the plan to start with */
            @JsonProperty("initial_phase_order")
            fun initialPhaseOrder(initialPhaseOrder: Long) = apply {
                this.initialPhaseOrder = initialPhaseOrder
            }

            /**
             * When this subscription's accrued usage reaches this threshold, an invoice will be
             * issued for the subscription. If not specified, invoices will only be issued at the
             * end of the billing period.
             */
            @JsonProperty("invoicing_threshold")
            fun invoicingThreshold(invoicingThreshold: String) = apply {
                this.invoicingThreshold = invoicingThreshold
            }

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0. If not
             * provided, this defaults to the value specified in the plan.
             */
            @JsonProperty("net_terms")
            fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

            @JsonProperty("per_credit_overage_amount")
            fun perCreditOverageAmount(perCreditOverageAmount: Double) = apply {
                this.perCreditOverageAmount = perCreditOverageAmount
            }

            /**
             * The plan that the given subscription should be switched to. Note that either this
             * property or `external_plan_id` must be specified.
             */
            @JsonProperty("plan_id") fun planId(planId: String) = apply { this.planId = planId }

            /** Optionally provide a list of overrides for prices on the plan */
            @JsonProperty("price_overrides")
            fun priceOverrides(priceOverrides: List<PriceOverride>) = apply {
                this.priceOverrides = priceOverrides
            }

            /** Plan adjustments to be removed from the subscription */
            @JsonProperty("remove_adjustments")
            fun removeAdjustments(removeAdjustments: List<RemoveAdjustment>) = apply {
                this.removeAdjustments = removeAdjustments
            }

            /** Plan prices to be removed from the subscription */
            @JsonProperty("remove_prices")
            fun removePrices(removePrices: List<RemovePrice>) = apply {
                this.removePrices = removePrices
            }

            /** Plan adjustments to be replaced with additional adjustments on the subscription */
            @JsonProperty("replace_adjustments")
            fun replaceAdjustments(replaceAdjustments: List<ReplaceAdjustment>) = apply {
                this.replaceAdjustments = replaceAdjustments
            }

            /** Plan prices to be replaced with additional prices on the subscription */
            @JsonProperty("replace_prices")
            fun replacePrices(replacePrices: List<ReplacePrice>) = apply {
                this.replacePrices = replacePrices
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): SubscriptionSchedulePlanChangeBody =
                SubscriptionSchedulePlanChangeBody(
                    checkNotNull(changeOption) { "`changeOption` is required but was not set" },
                    addAdjustments?.toUnmodifiable(),
                    addPrices?.toUnmodifiable(),
                    alignBillingWithPlanChangeDate,
                    autoCollection,
                    billingCycleAlignment,
                    changeDate,
                    couponRedemptionCode,
                    creditsOverageRate,
                    defaultInvoiceMemo,
                    externalPlanId,
                    initialPhaseOrder,
                    invoicingThreshold,
                    netTerms,
                    perCreditOverageAmount,
                    planId,
                    priceOverrides?.toUnmodifiable(),
                    removeAdjustments?.toUnmodifiable(),
                    removePrices?.toUnmodifiable(),
                    replaceAdjustments?.toUnmodifiable(),
                    replacePrices?.toUnmodifiable(),
                    additionalProperties.toUnmodifiable(),
                )
        }
    }

    fun _additionalQueryParams(): Map<String, List<String>> = additionalQueryParams

    fun _additionalHeaders(): Map<String, List<String>> = additionalHeaders

    fun _additionalBodyProperties(): Map<String, JsonValue> = additionalBodyProperties

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is SubscriptionSchedulePlanChangeParams &&
            this.subscriptionId == other.subscriptionId &&
            this.changeOption == other.changeOption &&
            this.addAdjustments == other.addAdjustments &&
            this.addPrices == other.addPrices &&
            this.alignBillingWithPlanChangeDate == other.alignBillingWithPlanChangeDate &&
            this.autoCollection == other.autoCollection &&
            this.billingCycleAlignment == other.billingCycleAlignment &&
            this.changeDate == other.changeDate &&
            this.couponRedemptionCode == other.couponRedemptionCode &&
            this.creditsOverageRate == other.creditsOverageRate &&
            this.defaultInvoiceMemo == other.defaultInvoiceMemo &&
            this.externalPlanId == other.externalPlanId &&
            this.initialPhaseOrder == other.initialPhaseOrder &&
            this.invoicingThreshold == other.invoicingThreshold &&
            this.netTerms == other.netTerms &&
            this.perCreditOverageAmount == other.perCreditOverageAmount &&
            this.planId == other.planId &&
            this.priceOverrides == other.priceOverrides &&
            this.removeAdjustments == other.removeAdjustments &&
            this.removePrices == other.removePrices &&
            this.replaceAdjustments == other.replaceAdjustments &&
            this.replacePrices == other.replacePrices &&
            this.additionalQueryParams == other.additionalQueryParams &&
            this.additionalHeaders == other.additionalHeaders &&
            this.additionalBodyProperties == other.additionalBodyProperties
    }

    override fun hashCode(): Int {
        return Objects.hash(
            subscriptionId,
            changeOption,
            addAdjustments,
            addPrices,
            alignBillingWithPlanChangeDate,
            autoCollection,
            billingCycleAlignment,
            changeDate,
            couponRedemptionCode,
            creditsOverageRate,
            defaultInvoiceMemo,
            externalPlanId,
            initialPhaseOrder,
            invoicingThreshold,
            netTerms,
            perCreditOverageAmount,
            planId,
            priceOverrides,
            removeAdjustments,
            removePrices,
            replaceAdjustments,
            replacePrices,
            additionalQueryParams,
            additionalHeaders,
            additionalBodyProperties,
        )
    }

    override fun toString() =
        "SubscriptionSchedulePlanChangeParams{subscriptionId=$subscriptionId, changeOption=$changeOption, addAdjustments=$addAdjustments, addPrices=$addPrices, alignBillingWithPlanChangeDate=$alignBillingWithPlanChangeDate, autoCollection=$autoCollection, billingCycleAlignment=$billingCycleAlignment, changeDate=$changeDate, couponRedemptionCode=$couponRedemptionCode, creditsOverageRate=$creditsOverageRate, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, initialPhaseOrder=$initialPhaseOrder, invoicingThreshold=$invoicingThreshold, netTerms=$netTerms, perCreditOverageAmount=$perCreditOverageAmount, planId=$planId, priceOverrides=$priceOverrides, removeAdjustments=$removeAdjustments, removePrices=$removePrices, replaceAdjustments=$replaceAdjustments, replacePrices=$replacePrices, additionalQueryParams=$additionalQueryParams, additionalHeaders=$additionalHeaders, additionalBodyProperties=$additionalBodyProperties}"

    fun toBuilder() = Builder().from(this)

    companion object {

        @JvmStatic fun builder() = Builder()
    }

    @NoAutoDetect
    class Builder {

        private var subscriptionId: String? = null
        private var changeOption: ChangeOption? = null
        private var addAdjustments: MutableList<AddAdjustment> = mutableListOf()
        private var addPrices: MutableList<AddPrice> = mutableListOf()
        private var alignBillingWithPlanChangeDate: Boolean? = null
        private var autoCollection: Boolean? = null
        private var billingCycleAlignment: BillingCycleAlignment? = null
        private var changeDate: OffsetDateTime? = null
        private var couponRedemptionCode: String? = null
        private var creditsOverageRate: Double? = null
        private var defaultInvoiceMemo: String? = null
        private var externalPlanId: String? = null
        private var initialPhaseOrder: Long? = null
        private var invoicingThreshold: String? = null
        private var netTerms: Long? = null
        private var perCreditOverageAmount: Double? = null
        private var planId: String? = null
        private var priceOverrides: MutableList<PriceOverride> = mutableListOf()
        private var removeAdjustments: MutableList<RemoveAdjustment> = mutableListOf()
        private var removePrices: MutableList<RemovePrice> = mutableListOf()
        private var replaceAdjustments: MutableList<ReplaceAdjustment> = mutableListOf()
        private var replacePrices: MutableList<ReplacePrice> = mutableListOf()
        private var additionalQueryParams: MutableMap<String, MutableList<String>> = mutableMapOf()
        private var additionalHeaders: MutableMap<String, MutableList<String>> = mutableMapOf()
        private var additionalBodyProperties: MutableMap<String, JsonValue> = mutableMapOf()

        @JvmSynthetic
        internal fun from(
            subscriptionSchedulePlanChangeParams: SubscriptionSchedulePlanChangeParams
        ) = apply {
            this.subscriptionId = subscriptionSchedulePlanChangeParams.subscriptionId
            this.changeOption = subscriptionSchedulePlanChangeParams.changeOption
            this.addAdjustments(subscriptionSchedulePlanChangeParams.addAdjustments ?: listOf())
            this.addPrices(subscriptionSchedulePlanChangeParams.addPrices ?: listOf())
            this.alignBillingWithPlanChangeDate =
                subscriptionSchedulePlanChangeParams.alignBillingWithPlanChangeDate
            this.autoCollection = subscriptionSchedulePlanChangeParams.autoCollection
            this.billingCycleAlignment = subscriptionSchedulePlanChangeParams.billingCycleAlignment
            this.changeDate = subscriptionSchedulePlanChangeParams.changeDate
            this.couponRedemptionCode = subscriptionSchedulePlanChangeParams.couponRedemptionCode
            this.creditsOverageRate = subscriptionSchedulePlanChangeParams.creditsOverageRate
            this.defaultInvoiceMemo = subscriptionSchedulePlanChangeParams.defaultInvoiceMemo
            this.externalPlanId = subscriptionSchedulePlanChangeParams.externalPlanId
            this.initialPhaseOrder = subscriptionSchedulePlanChangeParams.initialPhaseOrder
            this.invoicingThreshold = subscriptionSchedulePlanChangeParams.invoicingThreshold
            this.netTerms = subscriptionSchedulePlanChangeParams.netTerms
            this.perCreditOverageAmount =
                subscriptionSchedulePlanChangeParams.perCreditOverageAmount
            this.planId = subscriptionSchedulePlanChangeParams.planId
            this.priceOverrides(subscriptionSchedulePlanChangeParams.priceOverrides ?: listOf())
            this.removeAdjustments(
                subscriptionSchedulePlanChangeParams.removeAdjustments ?: listOf()
            )
            this.removePrices(subscriptionSchedulePlanChangeParams.removePrices ?: listOf())
            this.replaceAdjustments(
                subscriptionSchedulePlanChangeParams.replaceAdjustments ?: listOf()
            )
            this.replacePrices(subscriptionSchedulePlanChangeParams.replacePrices ?: listOf())
            additionalQueryParams(subscriptionSchedulePlanChangeParams.additionalQueryParams)
            additionalHeaders(subscriptionSchedulePlanChangeParams.additionalHeaders)
            additionalBodyProperties(subscriptionSchedulePlanChangeParams.additionalBodyProperties)
        }

        fun subscriptionId(subscriptionId: String) = apply { this.subscriptionId = subscriptionId }

        fun changeOption(changeOption: ChangeOption) = apply { this.changeOption = changeOption }

        /** Additional adjustments to be added to the subscription */
        fun addAdjustments(addAdjustments: List<AddAdjustment>) = apply {
            this.addAdjustments.clear()
            this.addAdjustments.addAll(addAdjustments)
        }

        /** Additional adjustments to be added to the subscription */
        fun addAddAdjustment(addAdjustment: AddAdjustment) = apply {
            this.addAdjustments.add(addAdjustment)
        }

        /** Additional prices to be added to the subscription */
        fun addPrices(addPrices: List<AddPrice>) = apply {
            this.addPrices.clear()
            this.addPrices.addAll(addPrices)
        }

        /** Additional prices to be added to the subscription */
        fun addAddPrice(addPrice: AddPrice) = apply { this.addPrices.add(addPrice) }

        /**
         * [DEPRECATED] Use billing_cycle_alignment instead. Reset billing periods to be aligned
         * with the plan change's effective date.
         */
        fun alignBillingWithPlanChangeDate(alignBillingWithPlanChangeDate: Boolean) = apply {
            this.alignBillingWithPlanChangeDate = alignBillingWithPlanChangeDate
        }

        /**
         * Determines whether issued invoices for this subscription will automatically be charged
         * with the saved payment method on the due date. If not specified, this defaults to the
         * behavior configured for this customer.
         */
        fun autoCollection(autoCollection: Boolean) = apply { this.autoCollection = autoCollection }

        /**
         * Reset billing periods to be aligned with the plan change's effective date or start of the
         * month. Defaults to `unchanged` which keeps subscription's existing billing cycle
         * alignment.
         */
        fun billingCycleAlignment(billingCycleAlignment: BillingCycleAlignment) = apply {
            this.billingCycleAlignment = billingCycleAlignment
        }

        /**
         * The date that the plan change should take effect. This parameter can only be passed if
         * the `change_option` is `requested_date`.
         */
        fun changeDate(changeDate: OffsetDateTime) = apply { this.changeDate = changeDate }

        /**
         * Redemption code to be used for this subscription. If the coupon cannot be found by its
         * redemption code, or cannot be redeemed, an error response will be returned and the
         * subscription creation or plan change will not be scheduled.
         */
        fun couponRedemptionCode(couponRedemptionCode: String) = apply {
            this.couponRedemptionCode = couponRedemptionCode
        }

        fun creditsOverageRate(creditsOverageRate: Double) = apply {
            this.creditsOverageRate = creditsOverageRate
        }

        /**
         * Determines the default memo on this subscription's invoices. Note that if this is not
         * provided, it is determined by the plan configuration.
         */
        fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
            this.defaultInvoiceMemo = defaultInvoiceMemo
        }

        /**
         * The external_plan_id of the plan that the given subscription should be switched to. Note
         * that either this property or `plan_id` must be specified.
         */
        fun externalPlanId(externalPlanId: String) = apply { this.externalPlanId = externalPlanId }

        /** The phase of the plan to start with */
        fun initialPhaseOrder(initialPhaseOrder: Long) = apply {
            this.initialPhaseOrder = initialPhaseOrder
        }

        /**
         * When this subscription's accrued usage reaches this threshold, an invoice will be issued
         * for the subscription. If not specified, invoices will only be issued at the end of the
         * billing period.
         */
        fun invoicingThreshold(invoicingThreshold: String) = apply {
            this.invoicingThreshold = invoicingThreshold
        }

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0. If not
         * provided, this defaults to the value specified in the plan.
         */
        fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

        fun perCreditOverageAmount(perCreditOverageAmount: Double) = apply {
            this.perCreditOverageAmount = perCreditOverageAmount
        }

        /**
         * The plan that the given subscription should be switched to. Note that either this
         * property or `external_plan_id` must be specified.
         */
        fun planId(planId: String) = apply { this.planId = planId }

        /** Optionally provide a list of overrides for prices on the plan */
        fun priceOverrides(priceOverrides: List<PriceOverride>) = apply {
            this.priceOverrides.clear()
            this.priceOverrides.addAll(priceOverrides)
        }

        /** Optionally provide a list of overrides for prices on the plan */
        fun addPriceOverride(priceOverride: PriceOverride) = apply {
            this.priceOverrides.add(priceOverride)
        }

        /** Plan adjustments to be removed from the subscription */
        fun removeAdjustments(removeAdjustments: List<RemoveAdjustment>) = apply {
            this.removeAdjustments.clear()
            this.removeAdjustments.addAll(removeAdjustments)
        }

        /** Plan adjustments to be removed from the subscription */
        fun addRemoveAdjustment(removeAdjustment: RemoveAdjustment) = apply {
            this.removeAdjustments.add(removeAdjustment)
        }

        /** Plan prices to be removed from the subscription */
        fun removePrices(removePrices: List<RemovePrice>) = apply {
            this.removePrices.clear()
            this.removePrices.addAll(removePrices)
        }

        /** Plan prices to be removed from the subscription */
        fun addRemovePrice(removePrice: RemovePrice) = apply { this.removePrices.add(removePrice) }

        /** Plan adjustments to be replaced with additional adjustments on the subscription */
        fun replaceAdjustments(replaceAdjustments: List<ReplaceAdjustment>) = apply {
            this.replaceAdjustments.clear()
            this.replaceAdjustments.addAll(replaceAdjustments)
        }

        /** Plan adjustments to be replaced with additional adjustments on the subscription */
        fun addReplaceAdjustment(replaceAdjustment: ReplaceAdjustment) = apply {
            this.replaceAdjustments.add(replaceAdjustment)
        }

        /** Plan prices to be replaced with additional prices on the subscription */
        fun replacePrices(replacePrices: List<ReplacePrice>) = apply {
            this.replacePrices.clear()
            this.replacePrices.addAll(replacePrices)
        }

        /** Plan prices to be replaced with additional prices on the subscription */
        fun addReplacePrice(replacePrice: ReplacePrice) = apply {
            this.replacePrices.add(replacePrice)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, List<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllQueryParams(additionalQueryParams)
        }

        fun putQueryParam(name: String, value: String) = apply {
            this.additionalQueryParams.getOrPut(name) { mutableListOf() }.add(value)
        }

        fun putQueryParams(name: String, values: Iterable<String>) = apply {
            this.additionalQueryParams.getOrPut(name) { mutableListOf() }.addAll(values)
        }

        fun putAllQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            additionalQueryParams.forEach(this::putQueryParams)
        }

        fun removeQueryParam(name: String) = apply {
            this.additionalQueryParams.put(name, mutableListOf())
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllHeaders(additionalHeaders)
        }

        fun putHeader(name: String, value: String) = apply {
            this.additionalHeaders.getOrPut(name) { mutableListOf() }.add(value)
        }

        fun putHeaders(name: String, values: Iterable<String>) = apply {
            this.additionalHeaders.getOrPut(name) { mutableListOf() }.addAll(values)
        }

        fun putAllHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(this::putHeaders)
        }

        fun removeHeader(name: String) = apply { this.additionalHeaders.put(name, mutableListOf()) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            this.additionalBodyProperties.clear()
            this.additionalBodyProperties.putAll(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            this.additionalBodyProperties.put(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                this.additionalBodyProperties.putAll(additionalBodyProperties)
            }

        fun build(): SubscriptionSchedulePlanChangeParams =
            SubscriptionSchedulePlanChangeParams(
                checkNotNull(subscriptionId) { "`subscriptionId` is required but was not set" },
                checkNotNull(changeOption) { "`changeOption` is required but was not set" },
                if (addAdjustments.size == 0) null else addAdjustments.toUnmodifiable(),
                if (addPrices.size == 0) null else addPrices.toUnmodifiable(),
                alignBillingWithPlanChangeDate,
                autoCollection,
                billingCycleAlignment,
                changeDate,
                couponRedemptionCode,
                creditsOverageRate,
                defaultInvoiceMemo,
                externalPlanId,
                initialPhaseOrder,
                invoicingThreshold,
                netTerms,
                perCreditOverageAmount,
                planId,
                if (priceOverrides.size == 0) null else priceOverrides.toUnmodifiable(),
                if (removeAdjustments.size == 0) null else removeAdjustments.toUnmodifiable(),
                if (removePrices.size == 0) null else removePrices.toUnmodifiable(),
                if (replaceAdjustments.size == 0) null else replaceAdjustments.toUnmodifiable(),
                if (replacePrices.size == 0) null else replacePrices.toUnmodifiable(),
                additionalQueryParams.mapValues { it.value.toUnmodifiable() }.toUnmodifiable(),
                additionalHeaders.mapValues { it.value.toUnmodifiable() }.toUnmodifiable(),
                additionalBodyProperties.toUnmodifiable(),
            )
    }

    class ChangeOption
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ChangeOption && this.value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            @JvmField val REQUESTED_DATE = ChangeOption(JsonField.of("requested_date"))

            @JvmField
            val END_OF_SUBSCRIPTION_TERM = ChangeOption(JsonField.of("end_of_subscription_term"))

            @JvmField val IMMEDIATE = ChangeOption(JsonField.of("immediate"))

            @JvmStatic fun of(value: String) = ChangeOption(JsonField.of(value))
        }

        enum class Known {
            REQUESTED_DATE,
            END_OF_SUBSCRIPTION_TERM,
            IMMEDIATE,
        }

        enum class Value {
            REQUESTED_DATE,
            END_OF_SUBSCRIPTION_TERM,
            IMMEDIATE,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                REQUESTED_DATE -> Value.REQUESTED_DATE
                END_OF_SUBSCRIPTION_TERM -> Value.END_OF_SUBSCRIPTION_TERM
                IMMEDIATE -> Value.IMMEDIATE
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                REQUESTED_DATE -> Known.REQUESTED_DATE
                END_OF_SUBSCRIPTION_TERM -> Known.END_OF_SUBSCRIPTION_TERM
                IMMEDIATE -> Known.IMMEDIATE
                else -> throw OrbInvalidDataException("Unknown ChangeOption: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }

    @JsonDeserialize(builder = AddAdjustment.Builder::class)
    @NoAutoDetect
    class AddAdjustment
    private constructor(
        private val adjustment: Adjustment?,
        private val startDate: OffsetDateTime?,
        private val endDate: OffsetDateTime?,
        private val planPhaseOrder: Long?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The definition of a new adjustment to create and add to the subscription. */
        @JsonProperty("adjustment") fun adjustment(): Adjustment? = adjustment

        /**
         * The start date of the adjustment interval. This is the date that the adjustment will
         * start affecting prices on the subscription. If null, the adjustment will start when the
         * phase or subscription starts.
         */
        @JsonProperty("start_date") fun startDate(): OffsetDateTime? = startDate

        /**
         * The end date of the adjustment interval. This is the date that the adjustment will stop
         * affecting prices on the subscription. If null, the adjustment will start when the phase
         * or subscription starts.
         */
        @JsonProperty("end_date") fun endDate(): OffsetDateTime? = endDate

        /** The phase to add this adjustment to. */
        @JsonProperty("plan_phase_order") fun planPhaseOrder(): Long? = planPhaseOrder

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is AddAdjustment &&
                this.adjustment == other.adjustment &&
                this.startDate == other.startDate &&
                this.endDate == other.endDate &&
                this.planPhaseOrder == other.planPhaseOrder &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        adjustment,
                        startDate,
                        endDate,
                        planPhaseOrder,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "AddAdjustment{adjustment=$adjustment, startDate=$startDate, endDate=$endDate, planPhaseOrder=$planPhaseOrder, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var adjustment: Adjustment? = null
            private var startDate: OffsetDateTime? = null
            private var endDate: OffsetDateTime? = null
            private var planPhaseOrder: Long? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(addAdjustment: AddAdjustment) = apply {
                this.adjustment = addAdjustment.adjustment
                this.startDate = addAdjustment.startDate
                this.endDate = addAdjustment.endDate
                this.planPhaseOrder = addAdjustment.planPhaseOrder
                additionalProperties(addAdjustment.additionalProperties)
            }

            /** The definition of a new adjustment to create and add to the subscription. */
            @JsonProperty("adjustment")
            fun adjustment(adjustment: Adjustment) = apply { this.adjustment = adjustment }

            /**
             * The start date of the adjustment interval. This is the date that the adjustment will
             * start affecting prices on the subscription. If null, the adjustment will start when
             * the phase or subscription starts.
             */
            @JsonProperty("start_date")
            fun startDate(startDate: OffsetDateTime) = apply { this.startDate = startDate }

            /**
             * The end date of the adjustment interval. This is the date that the adjustment will
             * stop affecting prices on the subscription. If null, the adjustment will start when
             * the phase or subscription starts.
             */
            @JsonProperty("end_date")
            fun endDate(endDate: OffsetDateTime) = apply { this.endDate = endDate }

            /** The phase to add this adjustment to. */
            @JsonProperty("plan_phase_order")
            fun planPhaseOrder(planPhaseOrder: Long) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): AddAdjustment =
                AddAdjustment(
                    checkNotNull(adjustment) { "`adjustment` is required but was not set" },
                    startDate,
                    endDate,
                    planPhaseOrder,
                    additionalProperties.toUnmodifiable(),
                )
        }

        @JsonDeserialize(using = Adjustment.Deserializer::class)
        @JsonSerialize(using = Adjustment.Serializer::class)
        class Adjustment
        private constructor(
            private val newPercentageDiscount: NewPercentageDiscount? = null,
            private val newAmountDiscount: NewAmountDiscount? = null,
            private val newMinimum: NewMinimum? = null,
            private val newMaximum: NewMaximum? = null,
            private val _json: JsonValue? = null,
        ) {

            private var validated: Boolean = false

            fun newPercentageDiscount(): Optional<NewPercentageDiscount> =
                Optional.ofNullable(newPercentageDiscount)

            fun newAmountDiscount(): Optional<NewAmountDiscount> =
                Optional.ofNullable(newAmountDiscount)

            fun newMinimum(): Optional<NewMinimum> = Optional.ofNullable(newMinimum)

            fun newMaximum(): Optional<NewMaximum> = Optional.ofNullable(newMaximum)

            fun isNewPercentageDiscount(): Boolean = newPercentageDiscount != null

            fun isNewAmountDiscount(): Boolean = newAmountDiscount != null

            fun isNewMinimum(): Boolean = newMinimum != null

            fun isNewMaximum(): Boolean = newMaximum != null

            fun asNewPercentageDiscount(): NewPercentageDiscount =
                newPercentageDiscount.getOrThrow("newPercentageDiscount")

            fun asNewAmountDiscount(): NewAmountDiscount =
                newAmountDiscount.getOrThrow("newAmountDiscount")

            fun asNewMinimum(): NewMinimum = newMinimum.getOrThrow("newMinimum")

            fun asNewMaximum(): NewMaximum = newMaximum.getOrThrow("newMaximum")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T {
                return when {
                    newPercentageDiscount != null ->
                        visitor.visitNewPercentageDiscount(newPercentageDiscount)
                    newAmountDiscount != null -> visitor.visitNewAmountDiscount(newAmountDiscount)
                    newMinimum != null -> visitor.visitNewMinimum(newMinimum)
                    newMaximum != null -> visitor.visitNewMaximum(newMaximum)
                    else -> visitor.unknown(_json)
                }
            }

            fun validate(): Adjustment = apply {
                if (!validated) {
                    if (
                        newPercentageDiscount == null &&
                            newAmountDiscount == null &&
                            newMinimum == null &&
                            newMaximum == null
                    ) {
                        throw OrbInvalidDataException("Unknown Adjustment: $_json")
                    }
                    newPercentageDiscount?.validate()
                    newAmountDiscount?.validate()
                    newMinimum?.validate()
                    newMaximum?.validate()
                    validated = true
                }
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Adjustment &&
                    this.newPercentageDiscount == other.newPercentageDiscount &&
                    this.newAmountDiscount == other.newAmountDiscount &&
                    this.newMinimum == other.newMinimum &&
                    this.newMaximum == other.newMaximum
            }

            override fun hashCode(): Int {
                return Objects.hash(
                    newPercentageDiscount,
                    newAmountDiscount,
                    newMinimum,
                    newMaximum,
                )
            }

            override fun toString(): String {
                return when {
                    newPercentageDiscount != null ->
                        "Adjustment{newPercentageDiscount=$newPercentageDiscount}"
                    newAmountDiscount != null -> "Adjustment{newAmountDiscount=$newAmountDiscount}"
                    newMinimum != null -> "Adjustment{newMinimum=$newMinimum}"
                    newMaximum != null -> "Adjustment{newMaximum=$newMaximum}"
                    _json != null -> "Adjustment{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid Adjustment")
                }
            }

            companion object {

                @JvmStatic
                fun ofNewPercentageDiscount(newPercentageDiscount: NewPercentageDiscount) =
                    Adjustment(newPercentageDiscount = newPercentageDiscount)

                @JvmStatic
                fun ofNewAmountDiscount(newAmountDiscount: NewAmountDiscount) =
                    Adjustment(newAmountDiscount = newAmountDiscount)

                @JvmStatic
                fun ofNewMinimum(newMinimum: NewMinimum) = Adjustment(newMinimum = newMinimum)

                @JvmStatic
                fun ofNewMaximum(newMaximum: NewMaximum) = Adjustment(newMaximum = newMaximum)
            }

            interface Visitor<out T> {

                fun visitNewPercentageDiscount(newPercentageDiscount: NewPercentageDiscount): T

                fun visitNewAmountDiscount(newAmountDiscount: NewAmountDiscount): T

                fun visitNewMinimum(newMinimum: NewMinimum): T

                fun visitNewMaximum(newMaximum: NewMaximum): T

                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown Adjustment: $json")
                }
            }

            class Deserializer : BaseDeserializer<Adjustment>(Adjustment::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): Adjustment {
                    val json = JsonValue.fromJsonNode(node)
                    tryDeserialize(node, jacksonTypeRef<NewPercentageDiscount>()) { it.validate() }
                        ?.let {
                            return Adjustment(newPercentageDiscount = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewAmountDiscount>()) { it.validate() }
                        ?.let {
                            return Adjustment(newAmountDiscount = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewMinimum>()) { it.validate() }
                        ?.let {
                            return Adjustment(newMinimum = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewMaximum>()) { it.validate() }
                        ?.let {
                            return Adjustment(newMaximum = it, _json = json)
                        }

                    return Adjustment(_json = json)
                }
            }

            class Serializer : BaseSerializer<Adjustment>(Adjustment::class) {

                override fun serialize(
                    value: Adjustment,
                    generator: JsonGenerator,
                    provider: SerializerProvider
                ) {
                    when {
                        value.newPercentageDiscount != null ->
                            generator.writeObject(value.newPercentageDiscount)
                        value.newAmountDiscount != null ->
                            generator.writeObject(value.newAmountDiscount)
                        value.newMinimum != null -> generator.writeObject(value.newMinimum)
                        value.newMaximum != null -> generator.writeObject(value.newMaximum)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid Adjustment")
                    }
                }
            }

            @JsonDeserialize(builder = NewPercentageDiscount.Builder::class)
            @NoAutoDetect
            class NewPercentageDiscount
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val percentageDiscount: JsonField<Double>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun percentageDiscount(): Double =
                    percentageDiscount.getRequired("percentage_discount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewPercentageDiscount = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        percentageDiscount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewPercentageDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                percentageDiscount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewPercentageDiscount{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, percentageDiscount=$percentageDiscount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newPercentageDiscount: NewPercentageDiscount) = apply {
                        this.appliesToPriceIds = newPercentageDiscount.appliesToPriceIds
                        this.adjustmentType = newPercentageDiscount.adjustmentType
                        this.percentageDiscount = newPercentageDiscount.percentageDiscount
                        additionalProperties(newPercentageDiscount.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewPercentageDiscount =
                        NewPercentageDiscount(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            percentageDiscount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val PERCENTAGE_DISCOUNT =
                            AdjustmentType(JsonField.of("percentage_discount"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE_DISCOUNT,
                    }

                    enum class Value {
                        PERCENTAGE_DISCOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE_DISCOUNT -> Value.PERCENTAGE_DISCOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE_DISCOUNT -> Known.PERCENTAGE_DISCOUNT
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewAmountDiscount.Builder::class)
            @NoAutoDetect
            class NewAmountDiscount
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val amountDiscount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun amountDiscount(): String = amountDiscount.getRequired("amount_discount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewAmountDiscount = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        amountDiscount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewAmountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.amountDiscount == other.amountDiscount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                amountDiscount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewAmountDiscount{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, amountDiscount=$amountDiscount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newAmountDiscount: NewAmountDiscount) = apply {
                        this.appliesToPriceIds = newAmountDiscount.appliesToPriceIds
                        this.adjustmentType = newAmountDiscount.adjustmentType
                        this.amountDiscount = newAmountDiscount.amountDiscount
                        additionalProperties(newAmountDiscount.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewAmountDiscount =
                        NewAmountDiscount(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            amountDiscount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val AMOUNT_DISCOUNT = AdjustmentType(JsonField.of("amount_discount"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        AMOUNT_DISCOUNT,
                    }

                    enum class Value {
                        AMOUNT_DISCOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            AMOUNT_DISCOUNT -> Value.AMOUNT_DISCOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            AMOUNT_DISCOUNT -> Known.AMOUNT_DISCOUNT
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewMinimum.Builder::class)
            @NoAutoDetect
            class NewMinimum
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val minimumAmount: JsonField<String>,
                private val itemId: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /** The item ID that revenue from this minimum will be attributed to. */
                fun itemId(): String = itemId.getRequired("item_id")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

                /** The item ID that revenue from this minimum will be attributed to. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewMinimum = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        minimumAmount()
                        itemId()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewMinimum &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.minimumAmount == other.minimumAmount &&
                        this.itemId == other.itemId &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                minimumAmount,
                                itemId,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewMinimum{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, minimumAmount=$minimumAmount, itemId=$itemId, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var minimumAmount: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newMinimum: NewMinimum) = apply {
                        this.appliesToPriceIds = newMinimum.appliesToPriceIds
                        this.adjustmentType = newMinimum.adjustmentType
                        this.minimumAmount = newMinimum.minimumAmount
                        this.itemId = newMinimum.itemId
                        additionalProperties(newMinimum.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** The item ID that revenue from this minimum will be attributed to. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The item ID that revenue from this minimum will be attributed to. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewMinimum =
                        NewMinimum(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            minimumAmount,
                            itemId,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MINIMUM = AdjustmentType(JsonField.of("minimum"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        MINIMUM,
                    }

                    enum class Value {
                        MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MINIMUM -> Value.MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MINIMUM -> Known.MINIMUM
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewMaximum.Builder::class)
            @NoAutoDetect
            class NewMaximum
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val maximumAmount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewMaximum = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        maximumAmount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewMaximum &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.maximumAmount == other.maximumAmount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                maximumAmount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewMaximum{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newMaximum: NewMaximum) = apply {
                        this.appliesToPriceIds = newMaximum.appliesToPriceIds
                        this.adjustmentType = newMaximum.adjustmentType
                        this.maximumAmount = newMaximum.maximumAmount
                        additionalProperties(newMaximum.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun maximumAmount(maximumAmount: String) =
                        maximumAmount(JsonField.of(maximumAmount))

                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewMaximum =
                        NewMaximum(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            maximumAmount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MAXIMUM = AdjustmentType(JsonField.of("maximum"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        MAXIMUM,
                    }

                    enum class Value {
                        MAXIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MAXIMUM -> Value.MAXIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MAXIMUM -> Known.MAXIMUM
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }
    }

    @JsonDeserialize(builder = AddPrice.Builder::class)
    @NoAutoDetect
    class AddPrice
    private constructor(
        private val priceId: String?,
        private val externalPriceId: String?,
        private val price: Price?,
        private val startDate: OffsetDateTime?,
        private val endDate: OffsetDateTime?,
        private val planPhaseOrder: Long?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The id of the price to add to the subscription. */
        @JsonProperty("price_id") fun priceId(): String? = priceId

        /** The external price id of the price to add to the subscription. */
        @JsonProperty("external_price_id") fun externalPriceId(): String? = externalPriceId

        /** The definition of a new price to create and add to the subscription. */
        @JsonProperty("price") fun price(): Price? = price

        /**
         * The start date of the price interval. This is the date that the price will start billing
         * on the subscription. If null, billing will start when the phase or subscription starts.
         */
        @JsonProperty("start_date") fun startDate(): OffsetDateTime? = startDate

        /**
         * The end date of the price interval. This is the date that the price will stop billing on
         * the subscription. If null, billing will end when the phase or subscription ends.
         */
        @JsonProperty("end_date") fun endDate(): OffsetDateTime? = endDate

        /** The phase to add this price to. */
        @JsonProperty("plan_phase_order") fun planPhaseOrder(): Long? = planPhaseOrder

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is AddPrice &&
                this.priceId == other.priceId &&
                this.externalPriceId == other.externalPriceId &&
                this.price == other.price &&
                this.startDate == other.startDate &&
                this.endDate == other.endDate &&
                this.planPhaseOrder == other.planPhaseOrder &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        priceId,
                        externalPriceId,
                        price,
                        startDate,
                        endDate,
                        planPhaseOrder,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "AddPrice{priceId=$priceId, externalPriceId=$externalPriceId, price=$price, startDate=$startDate, endDate=$endDate, planPhaseOrder=$planPhaseOrder, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var priceId: String? = null
            private var externalPriceId: String? = null
            private var price: Price? = null
            private var startDate: OffsetDateTime? = null
            private var endDate: OffsetDateTime? = null
            private var planPhaseOrder: Long? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(addPrice: AddPrice) = apply {
                this.priceId = addPrice.priceId
                this.externalPriceId = addPrice.externalPriceId
                this.price = addPrice.price
                this.startDate = addPrice.startDate
                this.endDate = addPrice.endDate
                this.planPhaseOrder = addPrice.planPhaseOrder
                additionalProperties(addPrice.additionalProperties)
            }

            /** The id of the price to add to the subscription. */
            @JsonProperty("price_id")
            fun priceId(priceId: String) = apply { this.priceId = priceId }

            /** The external price id of the price to add to the subscription. */
            @JsonProperty("external_price_id")
            fun externalPriceId(externalPriceId: String) = apply {
                this.externalPriceId = externalPriceId
            }

            /** The definition of a new price to create and add to the subscription. */
            @JsonProperty("price") fun price(price: Price) = apply { this.price = price }

            /**
             * The start date of the price interval. This is the date that the price will start
             * billing on the subscription. If null, billing will start when the phase or
             * subscription starts.
             */
            @JsonProperty("start_date")
            fun startDate(startDate: OffsetDateTime) = apply { this.startDate = startDate }

            /**
             * The end date of the price interval. This is the date that the price will stop billing
             * on the subscription. If null, billing will end when the phase or subscription ends.
             */
            @JsonProperty("end_date")
            fun endDate(endDate: OffsetDateTime) = apply { this.endDate = endDate }

            /** The phase to add this price to. */
            @JsonProperty("plan_phase_order")
            fun planPhaseOrder(planPhaseOrder: Long) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): AddPrice =
                AddPrice(
                    priceId,
                    externalPriceId,
                    price,
                    startDate,
                    endDate,
                    planPhaseOrder,
                    additionalProperties.toUnmodifiable(),
                )
        }

        @JsonDeserialize(using = Price.Deserializer::class)
        @JsonSerialize(using = Price.Serializer::class)
        class Price
        private constructor(
            private val newSubscriptionUnitPrice: NewSubscriptionUnitPrice? = null,
            private val newSubscriptionPackagePrice: NewSubscriptionPackagePrice? = null,
            private val newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice? = null,
            private val newSubscriptionTieredPrice: NewSubscriptionTieredPrice? = null,
            private val newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice? = null,
            private val newSubscriptionBpsPrice: NewSubscriptionBpsPrice? = null,
            private val newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice? = null,
            private val newSubscriptionBulkPrice: NewSubscriptionBulkPrice? = null,
            private val newSubscriptionThresholdTotalAmountPrice:
                NewSubscriptionThresholdTotalAmountPrice? =
                null,
            private val newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice? =
                null,
            private val newSubscriptionTieredWithMinimumPrice:
                NewSubscriptionTieredWithMinimumPrice? =
                null,
            private val newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice? =
                null,
            private val newSubscriptionPackageWithAllocationPrice:
                NewSubscriptionPackageWithAllocationPrice? =
                null,
            private val newSubscriptionTierWithProrationPrice:
                NewSubscriptionTierWithProrationPrice? =
                null,
            private val newSubscriptionUnitWithProrationPrice:
                NewSubscriptionUnitWithProrationPrice? =
                null,
            private val newSubscriptionGroupedAllocationPrice:
                NewSubscriptionGroupedAllocationPrice? =
                null,
            private val newSubscriptionGroupedWithProratedMinimumPrice:
                NewSubscriptionGroupedWithProratedMinimumPrice? =
                null,
            private val newSubscriptionBulkWithProrationPrice:
                NewSubscriptionBulkWithProrationPrice? =
                null,
            private val _json: JsonValue? = null,
        ) {

            private var validated: Boolean = false

            fun newSubscriptionUnitPrice(): Optional<NewSubscriptionUnitPrice> =
                Optional.ofNullable(newSubscriptionUnitPrice)

            fun newSubscriptionPackagePrice(): Optional<NewSubscriptionPackagePrice> =
                Optional.ofNullable(newSubscriptionPackagePrice)

            fun newSubscriptionMatrixPrice(): Optional<NewSubscriptionMatrixPrice> =
                Optional.ofNullable(newSubscriptionMatrixPrice)

            fun newSubscriptionTieredPrice(): Optional<NewSubscriptionTieredPrice> =
                Optional.ofNullable(newSubscriptionTieredPrice)

            fun newSubscriptionTieredBpsPrice(): Optional<NewSubscriptionTieredBpsPrice> =
                Optional.ofNullable(newSubscriptionTieredBpsPrice)

            fun newSubscriptionBpsPrice(): Optional<NewSubscriptionBpsPrice> =
                Optional.ofNullable(newSubscriptionBpsPrice)

            fun newSubscriptionBulkBpsPrice(): Optional<NewSubscriptionBulkBpsPrice> =
                Optional.ofNullable(newSubscriptionBulkBpsPrice)

            fun newSubscriptionBulkPrice(): Optional<NewSubscriptionBulkPrice> =
                Optional.ofNullable(newSubscriptionBulkPrice)

            fun newSubscriptionThresholdTotalAmountPrice():
                Optional<NewSubscriptionThresholdTotalAmountPrice> =
                Optional.ofNullable(newSubscriptionThresholdTotalAmountPrice)

            fun newSubscriptionTieredPackagePrice(): Optional<NewSubscriptionTieredPackagePrice> =
                Optional.ofNullable(newSubscriptionTieredPackagePrice)

            fun newSubscriptionTieredWithMinimumPrice():
                Optional<NewSubscriptionTieredWithMinimumPrice> =
                Optional.ofNullable(newSubscriptionTieredWithMinimumPrice)

            fun newSubscriptionUnitWithPercentPrice():
                Optional<NewSubscriptionUnitWithPercentPrice> =
                Optional.ofNullable(newSubscriptionUnitWithPercentPrice)

            fun newSubscriptionPackageWithAllocationPrice():
                Optional<NewSubscriptionPackageWithAllocationPrice> =
                Optional.ofNullable(newSubscriptionPackageWithAllocationPrice)

            fun newSubscriptionTierWithProrationPrice():
                Optional<NewSubscriptionTierWithProrationPrice> =
                Optional.ofNullable(newSubscriptionTierWithProrationPrice)

            fun newSubscriptionUnitWithProrationPrice():
                Optional<NewSubscriptionUnitWithProrationPrice> =
                Optional.ofNullable(newSubscriptionUnitWithProrationPrice)

            fun newSubscriptionGroupedAllocationPrice():
                Optional<NewSubscriptionGroupedAllocationPrice> =
                Optional.ofNullable(newSubscriptionGroupedAllocationPrice)

            fun newSubscriptionGroupedWithProratedMinimumPrice():
                Optional<NewSubscriptionGroupedWithProratedMinimumPrice> =
                Optional.ofNullable(newSubscriptionGroupedWithProratedMinimumPrice)

            fun newSubscriptionBulkWithProrationPrice():
                Optional<NewSubscriptionBulkWithProrationPrice> =
                Optional.ofNullable(newSubscriptionBulkWithProrationPrice)

            fun isNewSubscriptionUnitPrice(): Boolean = newSubscriptionUnitPrice != null

            fun isNewSubscriptionPackagePrice(): Boolean = newSubscriptionPackagePrice != null

            fun isNewSubscriptionMatrixPrice(): Boolean = newSubscriptionMatrixPrice != null

            fun isNewSubscriptionTieredPrice(): Boolean = newSubscriptionTieredPrice != null

            fun isNewSubscriptionTieredBpsPrice(): Boolean = newSubscriptionTieredBpsPrice != null

            fun isNewSubscriptionBpsPrice(): Boolean = newSubscriptionBpsPrice != null

            fun isNewSubscriptionBulkBpsPrice(): Boolean = newSubscriptionBulkBpsPrice != null

            fun isNewSubscriptionBulkPrice(): Boolean = newSubscriptionBulkPrice != null

            fun isNewSubscriptionThresholdTotalAmountPrice(): Boolean =
                newSubscriptionThresholdTotalAmountPrice != null

            fun isNewSubscriptionTieredPackagePrice(): Boolean =
                newSubscriptionTieredPackagePrice != null

            fun isNewSubscriptionTieredWithMinimumPrice(): Boolean =
                newSubscriptionTieredWithMinimumPrice != null

            fun isNewSubscriptionUnitWithPercentPrice(): Boolean =
                newSubscriptionUnitWithPercentPrice != null

            fun isNewSubscriptionPackageWithAllocationPrice(): Boolean =
                newSubscriptionPackageWithAllocationPrice != null

            fun isNewSubscriptionTierWithProrationPrice(): Boolean =
                newSubscriptionTierWithProrationPrice != null

            fun isNewSubscriptionUnitWithProrationPrice(): Boolean =
                newSubscriptionUnitWithProrationPrice != null

            fun isNewSubscriptionGroupedAllocationPrice(): Boolean =
                newSubscriptionGroupedAllocationPrice != null

            fun isNewSubscriptionGroupedWithProratedMinimumPrice(): Boolean =
                newSubscriptionGroupedWithProratedMinimumPrice != null

            fun isNewSubscriptionBulkWithProrationPrice(): Boolean =
                newSubscriptionBulkWithProrationPrice != null

            fun asNewSubscriptionUnitPrice(): NewSubscriptionUnitPrice =
                newSubscriptionUnitPrice.getOrThrow("newSubscriptionUnitPrice")

            fun asNewSubscriptionPackagePrice(): NewSubscriptionPackagePrice =
                newSubscriptionPackagePrice.getOrThrow("newSubscriptionPackagePrice")

            fun asNewSubscriptionMatrixPrice(): NewSubscriptionMatrixPrice =
                newSubscriptionMatrixPrice.getOrThrow("newSubscriptionMatrixPrice")

            fun asNewSubscriptionTieredPrice(): NewSubscriptionTieredPrice =
                newSubscriptionTieredPrice.getOrThrow("newSubscriptionTieredPrice")

            fun asNewSubscriptionTieredBpsPrice(): NewSubscriptionTieredBpsPrice =
                newSubscriptionTieredBpsPrice.getOrThrow("newSubscriptionTieredBpsPrice")

            fun asNewSubscriptionBpsPrice(): NewSubscriptionBpsPrice =
                newSubscriptionBpsPrice.getOrThrow("newSubscriptionBpsPrice")

            fun asNewSubscriptionBulkBpsPrice(): NewSubscriptionBulkBpsPrice =
                newSubscriptionBulkBpsPrice.getOrThrow("newSubscriptionBulkBpsPrice")

            fun asNewSubscriptionBulkPrice(): NewSubscriptionBulkPrice =
                newSubscriptionBulkPrice.getOrThrow("newSubscriptionBulkPrice")

            fun asNewSubscriptionThresholdTotalAmountPrice():
                NewSubscriptionThresholdTotalAmountPrice =
                newSubscriptionThresholdTotalAmountPrice.getOrThrow(
                    "newSubscriptionThresholdTotalAmountPrice"
                )

            fun asNewSubscriptionTieredPackagePrice(): NewSubscriptionTieredPackagePrice =
                newSubscriptionTieredPackagePrice.getOrThrow("newSubscriptionTieredPackagePrice")

            fun asNewSubscriptionTieredWithMinimumPrice(): NewSubscriptionTieredWithMinimumPrice =
                newSubscriptionTieredWithMinimumPrice.getOrThrow(
                    "newSubscriptionTieredWithMinimumPrice"
                )

            fun asNewSubscriptionUnitWithPercentPrice(): NewSubscriptionUnitWithPercentPrice =
                newSubscriptionUnitWithPercentPrice.getOrThrow(
                    "newSubscriptionUnitWithPercentPrice"
                )

            fun asNewSubscriptionPackageWithAllocationPrice():
                NewSubscriptionPackageWithAllocationPrice =
                newSubscriptionPackageWithAllocationPrice.getOrThrow(
                    "newSubscriptionPackageWithAllocationPrice"
                )

            fun asNewSubscriptionTierWithProrationPrice(): NewSubscriptionTierWithProrationPrice =
                newSubscriptionTierWithProrationPrice.getOrThrow(
                    "newSubscriptionTierWithProrationPrice"
                )

            fun asNewSubscriptionUnitWithProrationPrice(): NewSubscriptionUnitWithProrationPrice =
                newSubscriptionUnitWithProrationPrice.getOrThrow(
                    "newSubscriptionUnitWithProrationPrice"
                )

            fun asNewSubscriptionGroupedAllocationPrice(): NewSubscriptionGroupedAllocationPrice =
                newSubscriptionGroupedAllocationPrice.getOrThrow(
                    "newSubscriptionGroupedAllocationPrice"
                )

            fun asNewSubscriptionGroupedWithProratedMinimumPrice():
                NewSubscriptionGroupedWithProratedMinimumPrice =
                newSubscriptionGroupedWithProratedMinimumPrice.getOrThrow(
                    "newSubscriptionGroupedWithProratedMinimumPrice"
                )

            fun asNewSubscriptionBulkWithProrationPrice(): NewSubscriptionBulkWithProrationPrice =
                newSubscriptionBulkWithProrationPrice.getOrThrow(
                    "newSubscriptionBulkWithProrationPrice"
                )

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T {
                return when {
                    newSubscriptionUnitPrice != null ->
                        visitor.visitNewSubscriptionUnitPrice(newSubscriptionUnitPrice)
                    newSubscriptionPackagePrice != null ->
                        visitor.visitNewSubscriptionPackagePrice(newSubscriptionPackagePrice)
                    newSubscriptionMatrixPrice != null ->
                        visitor.visitNewSubscriptionMatrixPrice(newSubscriptionMatrixPrice)
                    newSubscriptionTieredPrice != null ->
                        visitor.visitNewSubscriptionTieredPrice(newSubscriptionTieredPrice)
                    newSubscriptionTieredBpsPrice != null ->
                        visitor.visitNewSubscriptionTieredBpsPrice(newSubscriptionTieredBpsPrice)
                    newSubscriptionBpsPrice != null ->
                        visitor.visitNewSubscriptionBpsPrice(newSubscriptionBpsPrice)
                    newSubscriptionBulkBpsPrice != null ->
                        visitor.visitNewSubscriptionBulkBpsPrice(newSubscriptionBulkBpsPrice)
                    newSubscriptionBulkPrice != null ->
                        visitor.visitNewSubscriptionBulkPrice(newSubscriptionBulkPrice)
                    newSubscriptionThresholdTotalAmountPrice != null ->
                        visitor.visitNewSubscriptionThresholdTotalAmountPrice(
                            newSubscriptionThresholdTotalAmountPrice
                        )
                    newSubscriptionTieredPackagePrice != null ->
                        visitor.visitNewSubscriptionTieredPackagePrice(
                            newSubscriptionTieredPackagePrice
                        )
                    newSubscriptionTieredWithMinimumPrice != null ->
                        visitor.visitNewSubscriptionTieredWithMinimumPrice(
                            newSubscriptionTieredWithMinimumPrice
                        )
                    newSubscriptionUnitWithPercentPrice != null ->
                        visitor.visitNewSubscriptionUnitWithPercentPrice(
                            newSubscriptionUnitWithPercentPrice
                        )
                    newSubscriptionPackageWithAllocationPrice != null ->
                        visitor.visitNewSubscriptionPackageWithAllocationPrice(
                            newSubscriptionPackageWithAllocationPrice
                        )
                    newSubscriptionTierWithProrationPrice != null ->
                        visitor.visitNewSubscriptionTierWithProrationPrice(
                            newSubscriptionTierWithProrationPrice
                        )
                    newSubscriptionUnitWithProrationPrice != null ->
                        visitor.visitNewSubscriptionUnitWithProrationPrice(
                            newSubscriptionUnitWithProrationPrice
                        )
                    newSubscriptionGroupedAllocationPrice != null ->
                        visitor.visitNewSubscriptionGroupedAllocationPrice(
                            newSubscriptionGroupedAllocationPrice
                        )
                    newSubscriptionGroupedWithProratedMinimumPrice != null ->
                        visitor.visitNewSubscriptionGroupedWithProratedMinimumPrice(
                            newSubscriptionGroupedWithProratedMinimumPrice
                        )
                    newSubscriptionBulkWithProrationPrice != null ->
                        visitor.visitNewSubscriptionBulkWithProrationPrice(
                            newSubscriptionBulkWithProrationPrice
                        )
                    else -> visitor.unknown(_json)
                }
            }

            fun validate(): Price = apply {
                if (!validated) {
                    if (
                        newSubscriptionUnitPrice == null &&
                            newSubscriptionPackagePrice == null &&
                            newSubscriptionMatrixPrice == null &&
                            newSubscriptionTieredPrice == null &&
                            newSubscriptionTieredBpsPrice == null &&
                            newSubscriptionBpsPrice == null &&
                            newSubscriptionBulkBpsPrice == null &&
                            newSubscriptionBulkPrice == null &&
                            newSubscriptionThresholdTotalAmountPrice == null &&
                            newSubscriptionTieredPackagePrice == null &&
                            newSubscriptionTieredWithMinimumPrice == null &&
                            newSubscriptionUnitWithPercentPrice == null &&
                            newSubscriptionPackageWithAllocationPrice == null &&
                            newSubscriptionTierWithProrationPrice == null &&
                            newSubscriptionUnitWithProrationPrice == null &&
                            newSubscriptionGroupedAllocationPrice == null &&
                            newSubscriptionGroupedWithProratedMinimumPrice == null &&
                            newSubscriptionBulkWithProrationPrice == null
                    ) {
                        throw OrbInvalidDataException("Unknown Price: $_json")
                    }
                    newSubscriptionUnitPrice?.validate()
                    newSubscriptionPackagePrice?.validate()
                    newSubscriptionMatrixPrice?.validate()
                    newSubscriptionTieredPrice?.validate()
                    newSubscriptionTieredBpsPrice?.validate()
                    newSubscriptionBpsPrice?.validate()
                    newSubscriptionBulkBpsPrice?.validate()
                    newSubscriptionBulkPrice?.validate()
                    newSubscriptionThresholdTotalAmountPrice?.validate()
                    newSubscriptionTieredPackagePrice?.validate()
                    newSubscriptionTieredWithMinimumPrice?.validate()
                    newSubscriptionUnitWithPercentPrice?.validate()
                    newSubscriptionPackageWithAllocationPrice?.validate()
                    newSubscriptionTierWithProrationPrice?.validate()
                    newSubscriptionUnitWithProrationPrice?.validate()
                    newSubscriptionGroupedAllocationPrice?.validate()
                    newSubscriptionGroupedWithProratedMinimumPrice?.validate()
                    newSubscriptionBulkWithProrationPrice?.validate()
                    validated = true
                }
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Price &&
                    this.newSubscriptionUnitPrice == other.newSubscriptionUnitPrice &&
                    this.newSubscriptionPackagePrice == other.newSubscriptionPackagePrice &&
                    this.newSubscriptionMatrixPrice == other.newSubscriptionMatrixPrice &&
                    this.newSubscriptionTieredPrice == other.newSubscriptionTieredPrice &&
                    this.newSubscriptionTieredBpsPrice == other.newSubscriptionTieredBpsPrice &&
                    this.newSubscriptionBpsPrice == other.newSubscriptionBpsPrice &&
                    this.newSubscriptionBulkBpsPrice == other.newSubscriptionBulkBpsPrice &&
                    this.newSubscriptionBulkPrice == other.newSubscriptionBulkPrice &&
                    this.newSubscriptionThresholdTotalAmountPrice ==
                        other.newSubscriptionThresholdTotalAmountPrice &&
                    this.newSubscriptionTieredPackagePrice ==
                        other.newSubscriptionTieredPackagePrice &&
                    this.newSubscriptionTieredWithMinimumPrice ==
                        other.newSubscriptionTieredWithMinimumPrice &&
                    this.newSubscriptionUnitWithPercentPrice ==
                        other.newSubscriptionUnitWithPercentPrice &&
                    this.newSubscriptionPackageWithAllocationPrice ==
                        other.newSubscriptionPackageWithAllocationPrice &&
                    this.newSubscriptionTierWithProrationPrice ==
                        other.newSubscriptionTierWithProrationPrice &&
                    this.newSubscriptionUnitWithProrationPrice ==
                        other.newSubscriptionUnitWithProrationPrice &&
                    this.newSubscriptionGroupedAllocationPrice ==
                        other.newSubscriptionGroupedAllocationPrice &&
                    this.newSubscriptionGroupedWithProratedMinimumPrice ==
                        other.newSubscriptionGroupedWithProratedMinimumPrice &&
                    this.newSubscriptionBulkWithProrationPrice ==
                        other.newSubscriptionBulkWithProrationPrice
            }

            override fun hashCode(): Int {
                return Objects.hash(
                    newSubscriptionUnitPrice,
                    newSubscriptionPackagePrice,
                    newSubscriptionMatrixPrice,
                    newSubscriptionTieredPrice,
                    newSubscriptionTieredBpsPrice,
                    newSubscriptionBpsPrice,
                    newSubscriptionBulkBpsPrice,
                    newSubscriptionBulkPrice,
                    newSubscriptionThresholdTotalAmountPrice,
                    newSubscriptionTieredPackagePrice,
                    newSubscriptionTieredWithMinimumPrice,
                    newSubscriptionUnitWithPercentPrice,
                    newSubscriptionPackageWithAllocationPrice,
                    newSubscriptionTierWithProrationPrice,
                    newSubscriptionUnitWithProrationPrice,
                    newSubscriptionGroupedAllocationPrice,
                    newSubscriptionGroupedWithProratedMinimumPrice,
                    newSubscriptionBulkWithProrationPrice,
                )
            }

            override fun toString(): String {
                return when {
                    newSubscriptionUnitPrice != null ->
                        "Price{newSubscriptionUnitPrice=$newSubscriptionUnitPrice}"
                    newSubscriptionPackagePrice != null ->
                        "Price{newSubscriptionPackagePrice=$newSubscriptionPackagePrice}"
                    newSubscriptionMatrixPrice != null ->
                        "Price{newSubscriptionMatrixPrice=$newSubscriptionMatrixPrice}"
                    newSubscriptionTieredPrice != null ->
                        "Price{newSubscriptionTieredPrice=$newSubscriptionTieredPrice}"
                    newSubscriptionTieredBpsPrice != null ->
                        "Price{newSubscriptionTieredBpsPrice=$newSubscriptionTieredBpsPrice}"
                    newSubscriptionBpsPrice != null ->
                        "Price{newSubscriptionBpsPrice=$newSubscriptionBpsPrice}"
                    newSubscriptionBulkBpsPrice != null ->
                        "Price{newSubscriptionBulkBpsPrice=$newSubscriptionBulkBpsPrice}"
                    newSubscriptionBulkPrice != null ->
                        "Price{newSubscriptionBulkPrice=$newSubscriptionBulkPrice}"
                    newSubscriptionThresholdTotalAmountPrice != null ->
                        "Price{newSubscriptionThresholdTotalAmountPrice=$newSubscriptionThresholdTotalAmountPrice}"
                    newSubscriptionTieredPackagePrice != null ->
                        "Price{newSubscriptionTieredPackagePrice=$newSubscriptionTieredPackagePrice}"
                    newSubscriptionTieredWithMinimumPrice != null ->
                        "Price{newSubscriptionTieredWithMinimumPrice=$newSubscriptionTieredWithMinimumPrice}"
                    newSubscriptionUnitWithPercentPrice != null ->
                        "Price{newSubscriptionUnitWithPercentPrice=$newSubscriptionUnitWithPercentPrice}"
                    newSubscriptionPackageWithAllocationPrice != null ->
                        "Price{newSubscriptionPackageWithAllocationPrice=$newSubscriptionPackageWithAllocationPrice}"
                    newSubscriptionTierWithProrationPrice != null ->
                        "Price{newSubscriptionTierWithProrationPrice=$newSubscriptionTierWithProrationPrice}"
                    newSubscriptionUnitWithProrationPrice != null ->
                        "Price{newSubscriptionUnitWithProrationPrice=$newSubscriptionUnitWithProrationPrice}"
                    newSubscriptionGroupedAllocationPrice != null ->
                        "Price{newSubscriptionGroupedAllocationPrice=$newSubscriptionGroupedAllocationPrice}"
                    newSubscriptionGroupedWithProratedMinimumPrice != null ->
                        "Price{newSubscriptionGroupedWithProratedMinimumPrice=$newSubscriptionGroupedWithProratedMinimumPrice}"
                    newSubscriptionBulkWithProrationPrice != null ->
                        "Price{newSubscriptionBulkWithProrationPrice=$newSubscriptionBulkWithProrationPrice}"
                    _json != null -> "Price{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid Price")
                }
            }

            companion object {

                @JvmStatic
                fun ofNewSubscriptionUnitPrice(newSubscriptionUnitPrice: NewSubscriptionUnitPrice) =
                    Price(newSubscriptionUnitPrice = newSubscriptionUnitPrice)

                @JvmStatic
                fun ofNewSubscriptionPackagePrice(
                    newSubscriptionPackagePrice: NewSubscriptionPackagePrice
                ) = Price(newSubscriptionPackagePrice = newSubscriptionPackagePrice)

                @JvmStatic
                fun ofNewSubscriptionMatrixPrice(
                    newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice
                ) = Price(newSubscriptionMatrixPrice = newSubscriptionMatrixPrice)

                @JvmStatic
                fun ofNewSubscriptionTieredPrice(
                    newSubscriptionTieredPrice: NewSubscriptionTieredPrice
                ) = Price(newSubscriptionTieredPrice = newSubscriptionTieredPrice)

                @JvmStatic
                fun ofNewSubscriptionTieredBpsPrice(
                    newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                ) = Price(newSubscriptionTieredBpsPrice = newSubscriptionTieredBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBpsPrice(newSubscriptionBpsPrice: NewSubscriptionBpsPrice) =
                    Price(newSubscriptionBpsPrice = newSubscriptionBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBulkBpsPrice(
                    newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice
                ) = Price(newSubscriptionBulkBpsPrice = newSubscriptionBulkBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBulkPrice(newSubscriptionBulkPrice: NewSubscriptionBulkPrice) =
                    Price(newSubscriptionBulkPrice = newSubscriptionBulkPrice)

                @JvmStatic
                fun ofNewSubscriptionThresholdTotalAmountPrice(
                    newSubscriptionThresholdTotalAmountPrice:
                        NewSubscriptionThresholdTotalAmountPrice
                ) =
                    Price(
                        newSubscriptionThresholdTotalAmountPrice =
                            newSubscriptionThresholdTotalAmountPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionTieredPackagePrice(
                    newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                ) = Price(newSubscriptionTieredPackagePrice = newSubscriptionTieredPackagePrice)

                @JvmStatic
                fun ofNewSubscriptionTieredWithMinimumPrice(
                    newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                ) =
                    Price(
                        newSubscriptionTieredWithMinimumPrice =
                            newSubscriptionTieredWithMinimumPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionUnitWithPercentPrice(
                    newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                ) = Price(newSubscriptionUnitWithPercentPrice = newSubscriptionUnitWithPercentPrice)

                @JvmStatic
                fun ofNewSubscriptionPackageWithAllocationPrice(
                    newSubscriptionPackageWithAllocationPrice:
                        NewSubscriptionPackageWithAllocationPrice
                ) =
                    Price(
                        newSubscriptionPackageWithAllocationPrice =
                            newSubscriptionPackageWithAllocationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionTierWithProrationPrice(
                    newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                ) =
                    Price(
                        newSubscriptionTierWithProrationPrice =
                            newSubscriptionTierWithProrationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionUnitWithProrationPrice(
                    newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                ) =
                    Price(
                        newSubscriptionUnitWithProrationPrice =
                            newSubscriptionUnitWithProrationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionGroupedAllocationPrice(
                    newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                ) =
                    Price(
                        newSubscriptionGroupedAllocationPrice =
                            newSubscriptionGroupedAllocationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionGroupedWithProratedMinimumPrice(
                    newSubscriptionGroupedWithProratedMinimumPrice:
                        NewSubscriptionGroupedWithProratedMinimumPrice
                ) =
                    Price(
                        newSubscriptionGroupedWithProratedMinimumPrice =
                            newSubscriptionGroupedWithProratedMinimumPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionBulkWithProrationPrice(
                    newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                ) =
                    Price(
                        newSubscriptionBulkWithProrationPrice =
                            newSubscriptionBulkWithProrationPrice
                    )
            }

            interface Visitor<out T> {

                fun visitNewSubscriptionUnitPrice(
                    newSubscriptionUnitPrice: NewSubscriptionUnitPrice
                ): T

                fun visitNewSubscriptionPackagePrice(
                    newSubscriptionPackagePrice: NewSubscriptionPackagePrice
                ): T

                fun visitNewSubscriptionMatrixPrice(
                    newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice
                ): T

                fun visitNewSubscriptionTieredPrice(
                    newSubscriptionTieredPrice: NewSubscriptionTieredPrice
                ): T

                fun visitNewSubscriptionTieredBpsPrice(
                    newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                ): T

                fun visitNewSubscriptionBpsPrice(
                    newSubscriptionBpsPrice: NewSubscriptionBpsPrice
                ): T

                fun visitNewSubscriptionBulkBpsPrice(
                    newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice
                ): T

                fun visitNewSubscriptionBulkPrice(
                    newSubscriptionBulkPrice: NewSubscriptionBulkPrice
                ): T

                fun visitNewSubscriptionThresholdTotalAmountPrice(
                    newSubscriptionThresholdTotalAmountPrice:
                        NewSubscriptionThresholdTotalAmountPrice
                ): T

                fun visitNewSubscriptionTieredPackagePrice(
                    newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                ): T

                fun visitNewSubscriptionTieredWithMinimumPrice(
                    newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                ): T

                fun visitNewSubscriptionUnitWithPercentPrice(
                    newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                ): T

                fun visitNewSubscriptionPackageWithAllocationPrice(
                    newSubscriptionPackageWithAllocationPrice:
                        NewSubscriptionPackageWithAllocationPrice
                ): T

                fun visitNewSubscriptionTierWithProrationPrice(
                    newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                ): T

                fun visitNewSubscriptionUnitWithProrationPrice(
                    newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                ): T

                fun visitNewSubscriptionGroupedAllocationPrice(
                    newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                ): T

                fun visitNewSubscriptionGroupedWithProratedMinimumPrice(
                    newSubscriptionGroupedWithProratedMinimumPrice:
                        NewSubscriptionGroupedWithProratedMinimumPrice
                ): T

                fun visitNewSubscriptionBulkWithProrationPrice(
                    newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                ): T

                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown Price: $json")
                }
            }

            class Deserializer : BaseDeserializer<Price>(Price::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): Price {
                    val json = JsonValue.fromJsonNode(node)
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionPackagePrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionMatrixPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionMatrixPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionThresholdTotalAmountPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionThresholdTotalAmountPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredPackagePrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredWithMinimumPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithPercentPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitWithPercentPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionPackageWithAllocationPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionPackageWithAllocationPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTierWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTierWithProrationPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitWithProrationPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionGroupedAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionGroupedAllocationPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionGroupedWithProratedMinimumPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionGroupedWithProratedMinimumPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkWithProrationPrice = it, _json = json)
                        }

                    return Price(_json = json)
                }
            }

            class Serializer : BaseSerializer<Price>(Price::class) {

                override fun serialize(
                    value: Price,
                    generator: JsonGenerator,
                    provider: SerializerProvider
                ) {
                    when {
                        value.newSubscriptionUnitPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitPrice)
                        value.newSubscriptionPackagePrice != null ->
                            generator.writeObject(value.newSubscriptionPackagePrice)
                        value.newSubscriptionMatrixPrice != null ->
                            generator.writeObject(value.newSubscriptionMatrixPrice)
                        value.newSubscriptionTieredPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredPrice)
                        value.newSubscriptionTieredBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredBpsPrice)
                        value.newSubscriptionBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionBpsPrice)
                        value.newSubscriptionBulkBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkBpsPrice)
                        value.newSubscriptionBulkPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkPrice)
                        value.newSubscriptionThresholdTotalAmountPrice != null ->
                            generator.writeObject(value.newSubscriptionThresholdTotalAmountPrice)
                        value.newSubscriptionTieredPackagePrice != null ->
                            generator.writeObject(value.newSubscriptionTieredPackagePrice)
                        value.newSubscriptionTieredWithMinimumPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredWithMinimumPrice)
                        value.newSubscriptionUnitWithPercentPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitWithPercentPrice)
                        value.newSubscriptionPackageWithAllocationPrice != null ->
                            generator.writeObject(value.newSubscriptionPackageWithAllocationPrice)
                        value.newSubscriptionTierWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionTierWithProrationPrice)
                        value.newSubscriptionUnitWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitWithProrationPrice)
                        value.newSubscriptionGroupedAllocationPrice != null ->
                            generator.writeObject(value.newSubscriptionGroupedAllocationPrice)
                        value.newSubscriptionGroupedWithProratedMinimumPrice != null ->
                            generator.writeObject(
                                value.newSubscriptionGroupedWithProratedMinimumPrice
                            )
                        value.newSubscriptionBulkWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkWithProrationPrice)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid Price")
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitConfig: JsonField<UnitConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_config") @ExcludeMissing fun _unitConfig() = unitConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitConfig == other.unitConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitConfig=$unitConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitConfig: JsonField<UnitConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionUnitPrice: NewSubscriptionUnitPrice) = apply {
                        this.metadata = newSubscriptionUnitPrice.metadata
                        this.externalPriceId = newSubscriptionUnitPrice.externalPriceId
                        this.name = newSubscriptionUnitPrice.name
                        this.billableMetricId = newSubscriptionUnitPrice.billableMetricId
                        this.itemId = newSubscriptionUnitPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionUnitPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionUnitPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitPrice.conversionRate
                        this.modelType = newSubscriptionUnitPrice.modelType
                        this.unitConfig = newSubscriptionUnitPrice.unitConfig
                        this.currency = newSubscriptionUnitPrice.currency
                        additionalProperties(newSubscriptionUnitPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

                    @JsonProperty("unit_config")
                    @ExcludeMissing
                    fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                        this.unitConfig = unitConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitPrice =
                        NewSubscriptionUnitPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val UNIT = ModelType(JsonField.of("unit"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT,
                    }

                    enum class Value {
                        UNIT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT -> Value.UNIT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT -> Known.UNIT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitConfig.Builder::class)
                @NoAutoDetect
                class UnitConfig
                private constructor(
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Rate per unit of usage */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Rate per unit of usage */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitConfig = apply {
                        if (!validated) {
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitConfig &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(unitAmount, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitConfig: UnitConfig) = apply {
                            this.unitAmount = unitConfig.unitAmount
                            additionalProperties(unitConfig.additionalProperties)
                        }

                        /** Rate per unit of usage */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Rate per unit of usage */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitConfig =
                            UnitConfig(unitAmount, additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionPackagePrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionPackagePrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val packageConfig: JsonField<PackageConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("package_config") @ExcludeMissing fun _packageConfig() = packageConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionPackagePrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        packageConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionPackagePrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.packageConfig == other.packageConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                packageConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageConfig=$packageConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var packageConfig: JsonField<PackageConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionPackagePrice: NewSubscriptionPackagePrice) =
                        apply {
                            this.metadata = newSubscriptionPackagePrice.metadata
                            this.externalPriceId = newSubscriptionPackagePrice.externalPriceId
                            this.name = newSubscriptionPackagePrice.name
                            this.billableMetricId = newSubscriptionPackagePrice.billableMetricId
                            this.itemId = newSubscriptionPackagePrice.itemId
                            this.billedInAdvance = newSubscriptionPackagePrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionPackagePrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionPackagePrice.invoiceGroupingKey
                            this.cadence = newSubscriptionPackagePrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionPackagePrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionPackagePrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionPackagePrice.conversionRate
                            this.modelType = newSubscriptionPackagePrice.modelType
                            this.packageConfig = newSubscriptionPackagePrice.packageConfig
                            this.currency = newSubscriptionPackagePrice.currency
                            additionalProperties(newSubscriptionPackagePrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun packageConfig(packageConfig: PackageConfig) =
                        packageConfig(JsonField.of(packageConfig))

                    @JsonProperty("package_config")
                    @ExcludeMissing
                    fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                        this.packageConfig = packageConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionPackagePrice =
                        NewSubscriptionPackagePrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            packageConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PACKAGE = ModelType(JsonField.of("package"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        PACKAGE,
                    }

                    enum class Value {
                        PACKAGE,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PACKAGE -> Value.PACKAGE
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PACKAGE -> Known.PACKAGE
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = PackageConfig.Builder::class)
                @NoAutoDetect
                class PackageConfig
                private constructor(
                    private val packageAmount: JsonField<String>,
                    private val packageSize: JsonField<Long>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** A currency amount to rate usage by */
                    fun packageAmount(): String = packageAmount.getRequired("package_amount")

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(): Long = packageSize.getRequired("package_size")

                    /** A currency amount to rate usage by */
                    @JsonProperty("package_amount")
                    @ExcludeMissing
                    fun _packageAmount() = packageAmount

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    @JsonProperty("package_size") @ExcludeMissing fun _packageSize() = packageSize

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): PackageConfig = apply {
                        if (!validated) {
                            packageAmount()
                            packageSize()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PackageConfig &&
                            this.packageAmount == other.packageAmount &&
                            this.packageSize == other.packageSize &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    packageAmount,
                                    packageSize,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var packageAmount: JsonField<String> = JsonMissing.of()
                        private var packageSize: JsonField<Long> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(packageConfig: PackageConfig) = apply {
                            this.packageAmount = packageConfig.packageAmount
                            this.packageSize = packageConfig.packageSize
                            additionalProperties(packageConfig.additionalProperties)
                        }

                        /** A currency amount to rate usage by */
                        fun packageAmount(packageAmount: String) =
                            packageAmount(JsonField.of(packageAmount))

                        /** A currency amount to rate usage by */
                        @JsonProperty("package_amount")
                        @ExcludeMissing
                        fun packageAmount(packageAmount: JsonField<String>) = apply {
                            this.packageAmount = packageAmount
                        }

                        /**
                         * An integer amount to represent package size. For example, 1000 here would
                         * divide usage by 1000 before multiplying by package_amount in rating
                         */
                        fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                        /**
                         * An integer amount to represent package size. For example, 1000 here would
                         * divide usage by 1000 before multiplying by package_amount in rating
                         */
                        @JsonProperty("package_size")
                        @ExcludeMissing
                        fun packageSize(packageSize: JsonField<Long>) = apply {
                            this.packageSize = packageSize
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): PackageConfig =
                            PackageConfig(
                                packageAmount,
                                packageSize,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionMatrixPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionMatrixPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val matrixConfig: JsonField<MatrixConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("matrix_config") @ExcludeMissing fun _matrixConfig() = matrixConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionMatrixPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        matrixConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionMatrixPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.matrixConfig == other.matrixConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                matrixConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionMatrixPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, matrixConfig=$matrixConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var matrixConfig: JsonField<MatrixConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice) =
                        apply {
                            this.metadata = newSubscriptionMatrixPrice.metadata
                            this.externalPriceId = newSubscriptionMatrixPrice.externalPriceId
                            this.name = newSubscriptionMatrixPrice.name
                            this.billableMetricId = newSubscriptionMatrixPrice.billableMetricId
                            this.itemId = newSubscriptionMatrixPrice.itemId
                            this.billedInAdvance = newSubscriptionMatrixPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionMatrixPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionMatrixPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionMatrixPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionMatrixPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionMatrixPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionMatrixPrice.conversionRate
                            this.modelType = newSubscriptionMatrixPrice.modelType
                            this.matrixConfig = newSubscriptionMatrixPrice.matrixConfig
                            this.currency = newSubscriptionMatrixPrice.currency
                            additionalProperties(newSubscriptionMatrixPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun matrixConfig(matrixConfig: MatrixConfig) =
                        matrixConfig(JsonField.of(matrixConfig))

                    @JsonProperty("matrix_config")
                    @ExcludeMissing
                    fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                        this.matrixConfig = matrixConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionMatrixPrice =
                        NewSubscriptionMatrixPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            matrixConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = MatrixConfig.Builder::class)
                @NoAutoDetect
                class MatrixConfig
                private constructor(
                    private val dimensions: JsonField<List<String?>>,
                    private val defaultUnitAmount: JsonField<String>,
                    private val matrixValues: JsonField<List<MatrixValue>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(): String =
                        defaultUnitAmount.getRequired("default_unit_amount")

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(): List<MatrixValue> =
                        matrixValues.getRequired("matrix_values")

                    /** One or two event property values to evaluate matrix groups by */
                    @JsonProperty("dimensions") @ExcludeMissing fun _dimensions() = dimensions

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    @JsonProperty("default_unit_amount")
                    @ExcludeMissing
                    fun _defaultUnitAmount() = defaultUnitAmount

                    /** Matrix values for specified matrix grouping keys */
                    @JsonProperty("matrix_values")
                    @ExcludeMissing
                    fun _matrixValues() = matrixValues

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): MatrixConfig = apply {
                        if (!validated) {
                            dimensions()
                            defaultUnitAmount()
                            matrixValues().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MatrixConfig &&
                            this.dimensions == other.dimensions &&
                            this.defaultUnitAmount == other.defaultUnitAmount &&
                            this.matrixValues == other.matrixValues &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    dimensions,
                                    defaultUnitAmount,
                                    matrixValues,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "MatrixConfig{dimensions=$dimensions, defaultUnitAmount=$defaultUnitAmount, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var dimensions: JsonField<List<String?>> = JsonMissing.of()
                        private var defaultUnitAmount: JsonField<String> = JsonMissing.of()
                        private var matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixConfig: MatrixConfig) = apply {
                            this.dimensions = matrixConfig.dimensions
                            this.defaultUnitAmount = matrixConfig.defaultUnitAmount
                            this.matrixValues = matrixConfig.matrixValues
                            additionalProperties(matrixConfig.additionalProperties)
                        }

                        /** One or two event property values to evaluate matrix groups by */
                        fun dimensions(dimensions: List<String?>) =
                            dimensions(JsonField.of(dimensions))

                        /** One or two event property values to evaluate matrix groups by */
                        @JsonProperty("dimensions")
                        @ExcludeMissing
                        fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                            this.dimensions = dimensions
                        }

                        /**
                         * Default per unit rate for any usage not bucketed into a specified
                         * matrix_value
                         */
                        fun defaultUnitAmount(defaultUnitAmount: String) =
                            defaultUnitAmount(JsonField.of(defaultUnitAmount))

                        /**
                         * Default per unit rate for any usage not bucketed into a specified
                         * matrix_value
                         */
                        @JsonProperty("default_unit_amount")
                        @ExcludeMissing
                        fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                            this.defaultUnitAmount = defaultUnitAmount
                        }

                        /** Matrix values for specified matrix grouping keys */
                        fun matrixValues(matrixValues: List<MatrixValue>) =
                            matrixValues(JsonField.of(matrixValues))

                        /** Matrix values for specified matrix grouping keys */
                        @JsonProperty("matrix_values")
                        @ExcludeMissing
                        fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                            this.matrixValues = matrixValues
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): MatrixConfig =
                            MatrixConfig(
                                dimensions.map { it.toUnmodifiable() },
                                defaultUnitAmount,
                                matrixValues.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    @JsonDeserialize(builder = MatrixValue.Builder::class)
                    @NoAutoDetect
                    class MatrixValue
                    private constructor(
                        private val unitAmount: JsonField<String>,
                        private val dimensionValues: JsonField<List<String?>>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(): List<String?> =
                            dimensionValues.getRequired("dimension_values")

                        /** Unit price for the specified dimension_values */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        @JsonProperty("dimension_values")
                        @ExcludeMissing
                        fun _dimensionValues() = dimensionValues

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): MatrixValue = apply {
                            if (!validated) {
                                unitAmount()
                                dimensionValues()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MatrixValue &&
                                this.unitAmount == other.unitAmount &&
                                this.dimensionValues == other.dimensionValues &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        unitAmount,
                                        dimensionValues,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "MatrixValue{unitAmount=$unitAmount, dimensionValues=$dimensionValues, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var dimensionValues: JsonField<List<String?>> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(matrixValue: MatrixValue) = apply {
                                this.unitAmount = matrixValue.unitAmount
                                this.dimensionValues = matrixValue.dimensionValues
                                additionalProperties(matrixValue.additionalProperties)
                            }

                            /** Unit price for the specified dimension_values */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Unit price for the specified dimension_values */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            /**
                             * One or two matrix keys to filter usage to this Matrix value by. For
                             * example, ["region", "tier"] could be used to filter cloud usage by a
                             * cloud region and an instance tier.
                             */
                            fun dimensionValues(dimensionValues: List<String?>) =
                                dimensionValues(JsonField.of(dimensionValues))

                            /**
                             * One or two matrix keys to filter usage to this Matrix value by. For
                             * example, ["region", "tier"] could be used to filter cloud usage by a
                             * cloud region and an instance tier.
                             */
                            @JsonProperty("dimension_values")
                            @ExcludeMissing
                            fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                                this.dimensionValues = dimensionValues
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): MatrixValue =
                                MatrixValue(
                                    unitAmount,
                                    dimensionValues.map { it.toUnmodifiable() },
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MATRIX = ModelType(JsonField.of("matrix"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        MATRIX,
                    }

                    enum class Value {
                        MATRIX,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MATRIX -> Value.MATRIX
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MATRIX -> Known.MATRIX
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredConfig: JsonField<TieredConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_config") @ExcludeMissing fun _tieredConfig() = tieredConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredConfig == other.tieredConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredConfig=$tieredConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredConfig: JsonField<TieredConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionTieredPrice: NewSubscriptionTieredPrice) =
                        apply {
                            this.metadata = newSubscriptionTieredPrice.metadata
                            this.externalPriceId = newSubscriptionTieredPrice.externalPriceId
                            this.name = newSubscriptionTieredPrice.name
                            this.billableMetricId = newSubscriptionTieredPrice.billableMetricId
                            this.itemId = newSubscriptionTieredPrice.itemId
                            this.billedInAdvance = newSubscriptionTieredPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionTieredPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionTieredPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionTieredPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionTieredPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionTieredPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionTieredPrice.conversionRate
                            this.modelType = newSubscriptionTieredPrice.modelType
                            this.tieredConfig = newSubscriptionTieredPrice.tieredConfig
                            this.currency = newSubscriptionTieredPrice.currency
                            additionalProperties(newSubscriptionTieredPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredConfig(tieredConfig: TieredConfig) =
                        tieredConfig(JsonField.of(tieredConfig))

                    @JsonProperty("tiered_config")
                    @ExcludeMissing
                    fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                        this.tieredConfig = tieredConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredPrice =
                        NewSubscriptionTieredPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED = ModelType(JsonField.of("tiered"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED,
                    }

                    enum class Value {
                        TIERED,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED -> Value.TIERED
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED -> Known.TIERED
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredConfig.Builder::class)
                @NoAutoDetect
                class TieredConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredConfig: TieredConfig) = apply {
                            this.tiers = tieredConfig.tiers
                            additionalProperties(tieredConfig.additionalProperties)
                        }

                        /**
                         * Tiers for rating based on total usage quantities into the specified tier
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for rating based on total usage quantities into the specified tier
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredConfig =
                            TieredConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val firstUnit: JsonField<Double>,
                        private val lastUnit: JsonField<Double>,
                        private val unitAmount: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Inclusive tier starting value */
                        fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(): Optional<Double> =
                            Optional.ofNullable(lastUnit.getNullable("last_unit"))

                        /** Amount per unit */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /** Inclusive tier starting value */
                        @JsonProperty("first_unit") @ExcludeMissing fun _firstUnit() = firstUnit

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @JsonProperty("last_unit") @ExcludeMissing fun _lastUnit() = lastUnit

                        /** Amount per unit */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                firstUnit()
                                lastUnit()
                                unitAmount()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.firstUnit == other.firstUnit &&
                                this.lastUnit == other.lastUnit &&
                                this.unitAmount == other.unitAmount &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        firstUnit,
                                        lastUnit,
                                        unitAmount,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{firstUnit=$firstUnit, lastUnit=$lastUnit, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var firstUnit: JsonField<Double> = JsonMissing.of()
                            private var lastUnit: JsonField<Double> = JsonMissing.of()
                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.firstUnit = tier.firstUnit
                                this.lastUnit = tier.lastUnit
                                this.unitAmount = tier.unitAmount
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Inclusive tier starting value */
                            fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                            /** Inclusive tier starting value */
                            @JsonProperty("first_unit")
                            @ExcludeMissing
                            fun firstUnit(firstUnit: JsonField<Double>) = apply {
                                this.firstUnit = firstUnit
                            }

                            /**
                             * Exclusive tier ending value. If null, this is treated as the last
                             * tier
                             */
                            fun lastUnit(lastUnit: Double) = lastUnit(JsonField.of(lastUnit))

                            /**
                             * Exclusive tier ending value. If null, this is treated as the last
                             * tier
                             */
                            @JsonProperty("last_unit")
                            @ExcludeMissing
                            fun lastUnit(lastUnit: JsonField<Double>) = apply {
                                this.lastUnit = lastUnit
                            }

                            /** Amount per unit */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Amount per unit */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    firstUnit,
                                    lastUnit,
                                    unitAmount,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredBpsConfig: JsonField<TieredBpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredBpsConfig(): TieredBpsConfig =
                    tieredBpsConfig.getRequired("tiered_bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_bps_config")
                @ExcludeMissing
                fun _tieredBpsConfig() = tieredBpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredBpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredBpsConfig == other.tieredBpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredBpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredBpsConfig=$tieredBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredBpsPrice.metadata
                        this.externalPriceId = newSubscriptionTieredBpsPrice.externalPriceId
                        this.name = newSubscriptionTieredBpsPrice.name
                        this.billableMetricId = newSubscriptionTieredBpsPrice.billableMetricId
                        this.itemId = newSubscriptionTieredBpsPrice.itemId
                        this.billedInAdvance = newSubscriptionTieredBpsPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionTieredBpsPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionTieredBpsPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredBpsPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredBpsPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredBpsPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredBpsPrice.conversionRate
                        this.modelType = newSubscriptionTieredBpsPrice.modelType
                        this.tieredBpsConfig = newSubscriptionTieredBpsPrice.tieredBpsConfig
                        this.currency = newSubscriptionTieredBpsPrice.currency
                        additionalProperties(newSubscriptionTieredBpsPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                        tieredBpsConfig(JsonField.of(tieredBpsConfig))

                    @JsonProperty("tiered_bps_config")
                    @ExcludeMissing
                    fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                        this.tieredBpsConfig = tieredBpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredBpsPrice =
                        NewSubscriptionTieredBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredBpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED_BPS = ModelType(JsonField.of("tiered_bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_BPS,
                    }

                    enum class Value {
                        TIERED_BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_BPS -> Value.TIERED_BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_BPS -> Known.TIERED_BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredBpsConfig.Builder::class)
                @NoAutoDetect
                class TieredBpsConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredBpsConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredBpsConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                            this.tiers = tieredBpsConfig.tiers
                            additionalProperties(tieredBpsConfig.additionalProperties)
                        }

                        /**
                         * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                         * specified tiers
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                         * specified tiers
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredBpsConfig =
                            TieredBpsConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val minimumAmount: JsonField<String>,
                        private val maximumAmount: JsonField<String>,
                        private val bps: JsonField<Double>,
                        private val perUnitMaximum: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Inclusive tier starting value */
                        fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                        /** Exclusive tier ending value */
                        fun maximumAmount(): Optional<String> =
                            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                        /** Per-event basis point rate */
                        fun bps(): Double = bps.getRequired("bps")

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(): Optional<String> =
                            Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                        /** Inclusive tier starting value */
                        @JsonProperty("minimum_amount")
                        @ExcludeMissing
                        fun _minimumAmount() = minimumAmount

                        /** Exclusive tier ending value */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun _maximumAmount() = maximumAmount

                        /** Per-event basis point rate */
                        @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                        /** Per unit maximum to charge */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun _perUnitMaximum() = perUnitMaximum

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                minimumAmount()
                                maximumAmount()
                                bps()
                                perUnitMaximum()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.minimumAmount == other.minimumAmount &&
                                this.maximumAmount == other.maximumAmount &&
                                this.bps == other.bps &&
                                this.perUnitMaximum == other.perUnitMaximum &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        minimumAmount,
                                        maximumAmount,
                                        bps,
                                        perUnitMaximum,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var minimumAmount: JsonField<String> = JsonMissing.of()
                            private var maximumAmount: JsonField<String> = JsonMissing.of()
                            private var bps: JsonField<Double> = JsonMissing.of()
                            private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.minimumAmount = tier.minimumAmount
                                this.maximumAmount = tier.maximumAmount
                                this.bps = tier.bps
                                this.perUnitMaximum = tier.perUnitMaximum
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Inclusive tier starting value */
                            fun minimumAmount(minimumAmount: String) =
                                minimumAmount(JsonField.of(minimumAmount))

                            /** Inclusive tier starting value */
                            @JsonProperty("minimum_amount")
                            @ExcludeMissing
                            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                                this.minimumAmount = minimumAmount
                            }

                            /** Exclusive tier ending value */
                            fun maximumAmount(maximumAmount: String) =
                                maximumAmount(JsonField.of(maximumAmount))

                            /** Exclusive tier ending value */
                            @JsonProperty("maximum_amount")
                            @ExcludeMissing
                            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                                this.maximumAmount = maximumAmount
                            }

                            /** Per-event basis point rate */
                            fun bps(bps: Double) = bps(JsonField.of(bps))

                            /** Per-event basis point rate */
                            @JsonProperty("bps")
                            @ExcludeMissing
                            fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                            /** Per unit maximum to charge */
                            fun perUnitMaximum(perUnitMaximum: String) =
                                perUnitMaximum(JsonField.of(perUnitMaximum))

                            /** Per unit maximum to charge */
                            @JsonProperty("per_unit_maximum")
                            @ExcludeMissing
                            fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                                this.perUnitMaximum = perUnitMaximum
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    minimumAmount,
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bpsConfig: JsonField<BpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bps_config") @ExcludeMissing fun _bpsConfig() = bpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bpsConfig == other.bpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bpsConfig=$bpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bpsConfig: JsonField<BpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBpsPrice: NewSubscriptionBpsPrice) = apply {
                        this.metadata = newSubscriptionBpsPrice.metadata
                        this.externalPriceId = newSubscriptionBpsPrice.externalPriceId
                        this.name = newSubscriptionBpsPrice.name
                        this.billableMetricId = newSubscriptionBpsPrice.billableMetricId
                        this.itemId = newSubscriptionBpsPrice.itemId
                        this.billedInAdvance = newSubscriptionBpsPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionBpsPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionBpsPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBpsPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBpsPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBpsPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBpsPrice.conversionRate
                        this.modelType = newSubscriptionBpsPrice.modelType
                        this.bpsConfig = newSubscriptionBpsPrice.bpsConfig
                        this.currency = newSubscriptionBpsPrice.currency
                        additionalProperties(newSubscriptionBpsPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

                    @JsonProperty("bps_config")
                    @ExcludeMissing
                    fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply {
                        this.bpsConfig = bpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBpsPrice =
                        NewSubscriptionBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BpsConfig.Builder::class)
                @NoAutoDetect
                class BpsConfig
                private constructor(
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Basis point take rate per event */
                    fun bps(): Double = bps.getRequired("bps")

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Basis point take rate per event */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** Optional currency amount maximum to cap spend per event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BpsConfig = apply {
                        if (!validated) {
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BpsConfig &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bpsConfig: BpsConfig) = apply {
                            this.bps = bpsConfig.bps
                            this.perUnitMaximum = bpsConfig.perUnitMaximum
                            additionalProperties(bpsConfig.additionalProperties)
                        }

                        /** Basis point take rate per event */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Basis point take rate per event */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** Optional currency amount maximum to cap spend per event */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** Optional currency amount maximum to cap spend per event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BpsConfig =
                            BpsConfig(
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BPS = ModelType(JsonField.of("bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BPS,
                    }

                    enum class Value {
                        BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BPS -> Value.BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BPS -> Known.BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkBpsConfig: JsonField<BulkBpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_bps_config")
                @ExcludeMissing
                fun _bulkBpsConfig() = bulkBpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkBpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkBpsConfig == other.bulkBpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkBpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkBpsConfig=$bulkBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice) =
                        apply {
                            this.metadata = newSubscriptionBulkBpsPrice.metadata
                            this.externalPriceId = newSubscriptionBulkBpsPrice.externalPriceId
                            this.name = newSubscriptionBulkBpsPrice.name
                            this.billableMetricId = newSubscriptionBulkBpsPrice.billableMetricId
                            this.itemId = newSubscriptionBulkBpsPrice.itemId
                            this.billedInAdvance = newSubscriptionBulkBpsPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionBulkBpsPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionBulkBpsPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionBulkBpsPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionBulkBpsPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionBulkBpsPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionBulkBpsPrice.conversionRate
                            this.modelType = newSubscriptionBulkBpsPrice.modelType
                            this.bulkBpsConfig = newSubscriptionBulkBpsPrice.bulkBpsConfig
                            this.currency = newSubscriptionBulkBpsPrice.currency
                            additionalProperties(newSubscriptionBulkBpsPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                        bulkBpsConfig(JsonField.of(bulkBpsConfig))

                    @JsonProperty("bulk_bps_config")
                    @ExcludeMissing
                    fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                        this.bulkBpsConfig = bulkBpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkBpsPrice =
                        NewSubscriptionBulkBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkBpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkBpsConfig.Builder::class)
                @NoAutoDetect
                class BulkBpsConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkBpsConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkBpsConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                            this.tiers = bulkBpsConfig.tiers
                            additionalProperties(bulkBpsConfig.additionalProperties)
                        }

                        /**
                         * Tiers for a bulk BPS pricing model where all usage is aggregated to a
                         * single tier based on total volume
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for a bulk BPS pricing model where all usage is aggregated to a
                         * single tier based on total volume
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkBpsConfig =
                            BulkBpsConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val maximumAmount: JsonField<String>,
                        private val bps: JsonField<Double>,
                        private val perUnitMaximum: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Upper bound for tier */
                        fun maximumAmount(): Optional<String> =
                            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                        /** Basis points to rate on */
                        fun bps(): Double = bps.getRequired("bps")

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(): Optional<String> =
                            Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                        /** Upper bound for tier */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun _maximumAmount() = maximumAmount

                        /** Basis points to rate on */
                        @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                        /** The maximum amount to charge for any one event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun _perUnitMaximum() = perUnitMaximum

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                maximumAmount()
                                bps()
                                perUnitMaximum()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.maximumAmount == other.maximumAmount &&
                                this.bps == other.bps &&
                                this.perUnitMaximum == other.perUnitMaximum &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        maximumAmount,
                                        bps,
                                        perUnitMaximum,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var maximumAmount: JsonField<String> = JsonMissing.of()
                            private var bps: JsonField<Double> = JsonMissing.of()
                            private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.maximumAmount = tier.maximumAmount
                                this.bps = tier.bps
                                this.perUnitMaximum = tier.perUnitMaximum
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Upper bound for tier */
                            fun maximumAmount(maximumAmount: String) =
                                maximumAmount(JsonField.of(maximumAmount))

                            /** Upper bound for tier */
                            @JsonProperty("maximum_amount")
                            @ExcludeMissing
                            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                                this.maximumAmount = maximumAmount
                            }

                            /** Basis points to rate on */
                            fun bps(bps: Double) = bps(JsonField.of(bps))

                            /** Basis points to rate on */
                            @JsonProperty("bps")
                            @ExcludeMissing
                            fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                            /** The maximum amount to charge for any one event */
                            fun perUnitMaximum(perUnitMaximum: String) =
                                perUnitMaximum(JsonField.of(perUnitMaximum))

                            /** The maximum amount to charge for any one event */
                            @JsonProperty("per_unit_maximum")
                            @ExcludeMissing
                            fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                                this.perUnitMaximum = perUnitMaximum
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BULK_BPS = ModelType(JsonField.of("bulk_bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK_BPS,
                    }

                    enum class Value {
                        BULK_BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK_BPS -> Value.BULK_BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK_BPS -> Known.BULK_BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkConfig: JsonField<BulkConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_config") @ExcludeMissing fun _bulkConfig() = bulkConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkConfig == other.bulkConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkConfig=$bulkConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkConfig: JsonField<BulkConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBulkPrice: NewSubscriptionBulkPrice) = apply {
                        this.metadata = newSubscriptionBulkPrice.metadata
                        this.externalPriceId = newSubscriptionBulkPrice.externalPriceId
                        this.name = newSubscriptionBulkPrice.name
                        this.billableMetricId = newSubscriptionBulkPrice.billableMetricId
                        this.itemId = newSubscriptionBulkPrice.itemId
                        this.billedInAdvance = newSubscriptionBulkPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionBulkPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionBulkPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBulkPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBulkPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBulkPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBulkPrice.conversionRate
                        this.modelType = newSubscriptionBulkPrice.modelType
                        this.bulkConfig = newSubscriptionBulkPrice.bulkConfig
                        this.currency = newSubscriptionBulkPrice.currency
                        additionalProperties(newSubscriptionBulkPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

                    @JsonProperty("bulk_config")
                    @ExcludeMissing
                    fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                        this.bulkConfig = bulkConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkPrice =
                        NewSubscriptionBulkPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkConfig.Builder::class)
                @NoAutoDetect
                class BulkConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /** Bulk tiers for rating based on total usage volume */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkConfig: BulkConfig) = apply {
                            this.tiers = bulkConfig.tiers
                            additionalProperties(bulkConfig.additionalProperties)
                        }

                        /** Bulk tiers for rating based on total usage volume */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /** Bulk tiers for rating based on total usage volume */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkConfig =
                            BulkConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val maximumUnits: JsonField<Double>,
                        private val unitAmount: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Upper bound for this tier */
                        fun maximumUnits(): Optional<Double> =
                            Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                        /** Amount per unit */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /** Upper bound for this tier */
                        @JsonProperty("maximum_units")
                        @ExcludeMissing
                        fun _maximumUnits() = maximumUnits

                        /** Amount per unit */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                maximumUnits()
                                unitAmount()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.maximumUnits == other.maximumUnits &&
                                this.unitAmount == other.unitAmount &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        maximumUnits,
                                        unitAmount,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{maximumUnits=$maximumUnits, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var maximumUnits: JsonField<Double> = JsonMissing.of()
                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.maximumUnits = tier.maximumUnits
                                this.unitAmount = tier.unitAmount
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Upper bound for this tier */
                            fun maximumUnits(maximumUnits: Double) =
                                maximumUnits(JsonField.of(maximumUnits))

                            /** Upper bound for this tier */
                            @JsonProperty("maximum_units")
                            @ExcludeMissing
                            fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                                this.maximumUnits = maximumUnits
                            }

                            /** Amount per unit */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Amount per unit */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    maximumUnits,
                                    unitAmount,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BULK = ModelType(JsonField.of("bulk"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK,
                    }

                    enum class Value {
                        BULK,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK -> Value.BULK
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK -> Known.BULK
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionThresholdTotalAmountPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionThresholdTotalAmountPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                    thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("threshold_total_amount_config")
                @ExcludeMissing
                fun _thresholdTotalAmountConfig() = thresholdTotalAmountConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionThresholdTotalAmountPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        thresholdTotalAmountConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionThresholdTotalAmountPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.thresholdTotalAmountConfig == other.thresholdTotalAmountConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                thresholdTotalAmountConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionThresholdTotalAmountPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionThresholdTotalAmountPrice:
                            NewSubscriptionThresholdTotalAmountPrice
                    ) = apply {
                        this.metadata = newSubscriptionThresholdTotalAmountPrice.metadata
                        this.externalPriceId =
                            newSubscriptionThresholdTotalAmountPrice.externalPriceId
                        this.name = newSubscriptionThresholdTotalAmountPrice.name
                        this.billableMetricId =
                            newSubscriptionThresholdTotalAmountPrice.billableMetricId
                        this.itemId = newSubscriptionThresholdTotalAmountPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionThresholdTotalAmountPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionThresholdTotalAmountPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionThresholdTotalAmountPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionThresholdTotalAmountPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionThresholdTotalAmountPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionThresholdTotalAmountPrice.invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionThresholdTotalAmountPrice.conversionRate
                        this.modelType = newSubscriptionThresholdTotalAmountPrice.modelType
                        this.thresholdTotalAmountConfig =
                            newSubscriptionThresholdTotalAmountPrice.thresholdTotalAmountConfig
                        this.currency = newSubscriptionThresholdTotalAmountPrice.currency
                        additionalProperties(
                            newSubscriptionThresholdTotalAmountPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun thresholdTotalAmountConfig(
                        thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                    ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

                    @JsonProperty("threshold_total_amount_config")
                    @ExcludeMissing
                    fun thresholdTotalAmountConfig(
                        thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
                    ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionThresholdTotalAmountPrice =
                        NewSubscriptionThresholdTotalAmountPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            thresholdTotalAmountConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val THRESHOLD_TOTAL_AMOUNT =
                            ModelType(JsonField.of("threshold_total_amount"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        THRESHOLD_TOTAL_AMOUNT,
                    }

                    enum class Value {
                        THRESHOLD_TOTAL_AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = ThresholdTotalAmountConfig.Builder::class)
                @NoAutoDetect
                class ThresholdTotalAmountConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): ThresholdTotalAmountConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ThresholdTotalAmountConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                            apply {
                                additionalProperties(
                                    thresholdTotalAmountConfig.additionalProperties
                                )
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): ThresholdTotalAmountConfig =
                            ThresholdTotalAmountConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredPackagePrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredPackagePrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredPackageConfig: JsonField<TieredPackageConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredPackageConfig(): TieredPackageConfig =
                    tieredPackageConfig.getRequired("tiered_package_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_package_config")
                @ExcludeMissing
                fun _tieredPackageConfig() = tieredPackageConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredPackagePrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredPackageConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredPackagePrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredPackageConfig == other.tieredPackageConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredPackageConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredPackageConfig=$tieredPackageConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredPackageConfig: JsonField<TieredPackageConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredPackagePrice.metadata
                        this.externalPriceId = newSubscriptionTieredPackagePrice.externalPriceId
                        this.name = newSubscriptionTieredPackagePrice.name
                        this.billableMetricId = newSubscriptionTieredPackagePrice.billableMetricId
                        this.itemId = newSubscriptionTieredPackagePrice.itemId
                        this.billedInAdvance = newSubscriptionTieredPackagePrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTieredPackagePrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTieredPackagePrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredPackagePrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredPackagePrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredPackagePrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredPackagePrice.conversionRate
                        this.modelType = newSubscriptionTieredPackagePrice.modelType
                        this.tieredPackageConfig =
                            newSubscriptionTieredPackagePrice.tieredPackageConfig
                        this.currency = newSubscriptionTieredPackagePrice.currency
                        additionalProperties(newSubscriptionTieredPackagePrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                        tieredPackageConfig(JsonField.of(tieredPackageConfig))

                    @JsonProperty("tiered_package_config")
                    @ExcludeMissing
                    fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) =
                        apply {
                            this.tieredPackageConfig = tieredPackageConfig
                        }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredPackagePrice =
                        NewSubscriptionTieredPackagePrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredPackageConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED_PACKAGE = ModelType(JsonField.of("tiered_package"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_PACKAGE,
                    }

                    enum class Value {
                        TIERED_PACKAGE,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_PACKAGE -> Value.TIERED_PACKAGE
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_PACKAGE -> Known.TIERED_PACKAGE
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredPackageConfig.Builder::class)
                @NoAutoDetect
                class TieredPackageConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredPackageConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredPackageConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredPackageConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                            additionalProperties(tieredPackageConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredPackageConfig =
                            TieredPackageConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredWithMinimumPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredWithMinimumPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
                    tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_with_minimum_config")
                @ExcludeMissing
                fun _tieredWithMinimumConfig() = tieredWithMinimumConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredWithMinimumPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredWithMinimumConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredWithMinimumPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredWithMinimumConfig == other.tieredWithMinimumConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredWithMinimumConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredWithMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithMinimumConfig=$tieredWithMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredWithMinimumPrice.metadata
                        this.externalPriceId = newSubscriptionTieredWithMinimumPrice.externalPriceId
                        this.name = newSubscriptionTieredWithMinimumPrice.name
                        this.billableMetricId =
                            newSubscriptionTieredWithMinimumPrice.billableMetricId
                        this.itemId = newSubscriptionTieredWithMinimumPrice.itemId
                        this.billedInAdvance = newSubscriptionTieredWithMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTieredWithMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTieredWithMinimumPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredWithMinimumPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredWithMinimumPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredWithMinimumPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredWithMinimumPrice.conversionRate
                        this.modelType = newSubscriptionTieredWithMinimumPrice.modelType
                        this.tieredWithMinimumConfig =
                            newSubscriptionTieredWithMinimumPrice.tieredWithMinimumConfig
                        this.currency = newSubscriptionTieredWithMinimumPrice.currency
                        additionalProperties(
                            newSubscriptionTieredWithMinimumPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                        tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

                    @JsonProperty("tiered_with_minimum_config")
                    @ExcludeMissing
                    fun tieredWithMinimumConfig(
                        tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
                    ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredWithMinimumPrice =
                        NewSubscriptionTieredWithMinimumPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredWithMinimumConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val TIERED_WITH_MINIMUM = ModelType(JsonField.of("tiered_with_minimum"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_WITH_MINIMUM,
                    }

                    enum class Value {
                        TIERED_WITH_MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredWithMinimumConfig.Builder::class)
                @NoAutoDetect
                class TieredWithMinimumConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredWithMinimumConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredWithMinimumConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                            apply {
                                additionalProperties(tieredWithMinimumConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredWithMinimumConfig =
                            TieredWithMinimumConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitWithPercentPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitWithPercentPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitWithPercentConfig(): UnitWithPercentConfig =
                    unitWithPercentConfig.getRequired("unit_with_percent_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_with_percent_config")
                @ExcludeMissing
                fun _unitWithPercentConfig() = unitWithPercentConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitWithPercentPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitWithPercentConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitWithPercentPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitWithPercentConfig == other.unitWithPercentConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitWithPercentConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitWithPercentPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithPercentConfig=$unitWithPercentConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitWithPercentConfig: JsonField<UnitWithPercentConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                    ) = apply {
                        this.metadata = newSubscriptionUnitWithPercentPrice.metadata
                        this.externalPriceId = newSubscriptionUnitWithPercentPrice.externalPriceId
                        this.name = newSubscriptionUnitWithPercentPrice.name
                        this.billableMetricId = newSubscriptionUnitWithPercentPrice.billableMetricId
                        this.itemId = newSubscriptionUnitWithPercentPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitWithPercentPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionUnitWithPercentPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionUnitWithPercentPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitWithPercentPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitWithPercentPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitWithPercentPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitWithPercentPrice.conversionRate
                        this.modelType = newSubscriptionUnitWithPercentPrice.modelType
                        this.unitWithPercentConfig =
                            newSubscriptionUnitWithPercentPrice.unitWithPercentConfig
                        this.currency = newSubscriptionUnitWithPercentPrice.currency
                        additionalProperties(
                            newSubscriptionUnitWithPercentPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                        unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

                    @JsonProperty("unit_with_percent_config")
                    @ExcludeMissing
                    fun unitWithPercentConfig(
                        unitWithPercentConfig: JsonField<UnitWithPercentConfig>
                    ) = apply { this.unitWithPercentConfig = unitWithPercentConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitWithPercentPrice =
                        NewSubscriptionUnitWithPercentPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitWithPercentConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val UNIT_WITH_PERCENT = ModelType(JsonField.of("unit_with_percent"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT_WITH_PERCENT,
                    }

                    enum class Value {
                        UNIT_WITH_PERCENT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitWithPercentConfig.Builder::class)
                @NoAutoDetect
                class UnitWithPercentConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitWithPercentConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitWithPercentConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitWithPercentConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                            additionalProperties(unitWithPercentConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitWithPercentConfig =
                            UnitWithPercentConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionPackageWithAllocationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionPackageWithAllocationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                    packageWithAllocationConfig.getRequired("package_with_allocation_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("package_with_allocation_config")
                @ExcludeMissing
                fun _packageWithAllocationConfig() = packageWithAllocationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionPackageWithAllocationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        packageWithAllocationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionPackageWithAllocationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.packageWithAllocationConfig == other.packageWithAllocationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                packageWithAllocationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionPackageWithAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageWithAllocationConfig=$packageWithAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var packageWithAllocationConfig:
                        JsonField<PackageWithAllocationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionPackageWithAllocationPrice:
                            NewSubscriptionPackageWithAllocationPrice
                    ) = apply {
                        this.metadata = newSubscriptionPackageWithAllocationPrice.metadata
                        this.externalPriceId =
                            newSubscriptionPackageWithAllocationPrice.externalPriceId
                        this.name = newSubscriptionPackageWithAllocationPrice.name
                        this.billableMetricId =
                            newSubscriptionPackageWithAllocationPrice.billableMetricId
                        this.itemId = newSubscriptionPackageWithAllocationPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionPackageWithAllocationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionPackageWithAllocationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionPackageWithAllocationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionPackageWithAllocationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionPackageWithAllocationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionPackageWithAllocationPrice.invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionPackageWithAllocationPrice.conversionRate
                        this.modelType = newSubscriptionPackageWithAllocationPrice.modelType
                        this.packageWithAllocationConfig =
                            newSubscriptionPackageWithAllocationPrice.packageWithAllocationConfig
                        this.currency = newSubscriptionPackageWithAllocationPrice.currency
                        additionalProperties(
                            newSubscriptionPackageWithAllocationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun packageWithAllocationConfig(
                        packageWithAllocationConfig: PackageWithAllocationConfig
                    ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

                    @JsonProperty("package_with_allocation_config")
                    @ExcludeMissing
                    fun packageWithAllocationConfig(
                        packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
                    ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionPackageWithAllocationPrice =
                        NewSubscriptionPackageWithAllocationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            packageWithAllocationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val PACKAGE_WITH_ALLOCATION =
                            ModelType(JsonField.of("package_with_allocation"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        PACKAGE_WITH_ALLOCATION,
                    }

                    enum class Value {
                        PACKAGE_WITH_ALLOCATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = PackageWithAllocationConfig.Builder::class)
                @NoAutoDetect
                class PackageWithAllocationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): PackageWithAllocationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PackageWithAllocationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            packageWithAllocationConfig: PackageWithAllocationConfig
                        ) = apply {
                            additionalProperties(packageWithAllocationConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): PackageWithAllocationConfig =
                            PackageWithAllocationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTierWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTierWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredWithProrationConfig(): TieredWithProrationConfig =
                    tieredWithProrationConfig.getRequired("tiered_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_with_proration_config")
                @ExcludeMissing
                fun _tieredWithProrationConfig() = tieredWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTierWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTierWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredWithProrationConfig == other.tieredWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTierWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithProrationConfig=$tieredWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionTierWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionTierWithProrationPrice.externalPriceId
                        this.name = newSubscriptionTierWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionTierWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionTierWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionTierWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTierWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTierWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTierWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTierWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTierWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTierWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionTierWithProrationPrice.modelType
                        this.tieredWithProrationConfig =
                            newSubscriptionTierWithProrationPrice.tieredWithProrationConfig
                        this.currency = newSubscriptionTierWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionTierWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredWithProrationConfig(
                        tieredWithProrationConfig: TieredWithProrationConfig
                    ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

                    @JsonProperty("tiered_with_proration_config")
                    @ExcludeMissing
                    fun tieredWithProrationConfig(
                        tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
                    ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTierWithProrationPrice =
                        NewSubscriptionTierWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val TIERED_WITH_PRORATION = ModelType(JsonField.of("tiered_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_WITH_PRORATION,
                    }

                    enum class Value {
                        TIERED_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredWithProrationConfig.Builder::class)
                @NoAutoDetect
                class TieredWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                            apply {
                                additionalProperties(tieredWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredWithProrationConfig =
                            TieredWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitWithProrationConfig(): UnitWithProrationConfig =
                    unitWithProrationConfig.getRequired("unit_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_with_proration_config")
                @ExcludeMissing
                fun _unitWithProrationConfig() = unitWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitWithProrationConfig == other.unitWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithProrationConfig=$unitWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitWithProrationConfig: JsonField<UnitWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionUnitWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionUnitWithProrationPrice.externalPriceId
                        this.name = newSubscriptionUnitWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionUnitWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionUnitWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionUnitWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionUnitWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionUnitWithProrationPrice.modelType
                        this.unitWithProrationConfig =
                            newSubscriptionUnitWithProrationPrice.unitWithProrationConfig
                        this.currency = newSubscriptionUnitWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionUnitWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                        unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

                    @JsonProperty("unit_with_proration_config")
                    @ExcludeMissing
                    fun unitWithProrationConfig(
                        unitWithProrationConfig: JsonField<UnitWithProrationConfig>
                    ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitWithProrationPrice =
                        NewSubscriptionUnitWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val UNIT_WITH_PRORATION = ModelType(JsonField.of("unit_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT_WITH_PRORATION,
                    }

                    enum class Value {
                        UNIT_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitWithProrationConfig.Builder::class)
                @NoAutoDetect
                class UnitWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitWithProrationConfig: UnitWithProrationConfig) =
                            apply {
                                additionalProperties(unitWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitWithProrationConfig =
                            UnitWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionGroupedAllocationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionGroupedAllocationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun groupedAllocationConfig(): GroupedAllocationConfig =
                    groupedAllocationConfig.getRequired("grouped_allocation_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("grouped_allocation_config")
                @ExcludeMissing
                fun _groupedAllocationConfig() = groupedAllocationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionGroupedAllocationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        groupedAllocationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionGroupedAllocationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.groupedAllocationConfig == other.groupedAllocationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                groupedAllocationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionGroupedAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedAllocationConfig=$groupedAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var groupedAllocationConfig: JsonField<GroupedAllocationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                    ) = apply {
                        this.metadata = newSubscriptionGroupedAllocationPrice.metadata
                        this.externalPriceId = newSubscriptionGroupedAllocationPrice.externalPriceId
                        this.name = newSubscriptionGroupedAllocationPrice.name
                        this.billableMetricId =
                            newSubscriptionGroupedAllocationPrice.billableMetricId
                        this.itemId = newSubscriptionGroupedAllocationPrice.itemId
                        this.billedInAdvance = newSubscriptionGroupedAllocationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionGroupedAllocationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionGroupedAllocationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionGroupedAllocationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionGroupedAllocationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionGroupedAllocationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionGroupedAllocationPrice.conversionRate
                        this.modelType = newSubscriptionGroupedAllocationPrice.modelType
                        this.groupedAllocationConfig =
                            newSubscriptionGroupedAllocationPrice.groupedAllocationConfig
                        this.currency = newSubscriptionGroupedAllocationPrice.currency
                        additionalProperties(
                            newSubscriptionGroupedAllocationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                        groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

                    @JsonProperty("grouped_allocation_config")
                    @ExcludeMissing
                    fun groupedAllocationConfig(
                        groupedAllocationConfig: JsonField<GroupedAllocationConfig>
                    ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionGroupedAllocationPrice =
                        NewSubscriptionGroupedAllocationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            groupedAllocationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = GroupedAllocationConfig.Builder::class)
                @NoAutoDetect
                class GroupedAllocationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): GroupedAllocationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is GroupedAllocationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "GroupedAllocationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(groupedAllocationConfig: GroupedAllocationConfig) =
                            apply {
                                additionalProperties(groupedAllocationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): GroupedAllocationConfig =
                            GroupedAllocationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val GROUPED_ALLOCATION = ModelType(JsonField.of("grouped_allocation"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        GROUPED_ALLOCATION,
                    }

                    enum class Value {
                        GROUPED_ALLOCATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(
                builder = NewSubscriptionGroupedWithProratedMinimumPrice.Builder::class
            )
            @NoAutoDetect
            class NewSubscriptionGroupedWithProratedMinimumPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val groupedWithProratedMinimumConfig:
                    JsonField<GroupedWithProratedMinimumConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
                    groupedWithProratedMinimumConfig.getRequired(
                        "grouped_with_prorated_minimum_config"
                    )

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("grouped_with_prorated_minimum_config")
                @ExcludeMissing
                fun _groupedWithProratedMinimumConfig() = groupedWithProratedMinimumConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionGroupedWithProratedMinimumPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        groupedWithProratedMinimumConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionGroupedWithProratedMinimumPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.groupedWithProratedMinimumConfig ==
                            other.groupedWithProratedMinimumConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                groupedWithProratedMinimumConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionGroupedWithProratedMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var groupedWithProratedMinimumConfig:
                        JsonField<GroupedWithProratedMinimumConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionGroupedWithProratedMinimumPrice:
                            NewSubscriptionGroupedWithProratedMinimumPrice
                    ) = apply {
                        this.metadata = newSubscriptionGroupedWithProratedMinimumPrice.metadata
                        this.externalPriceId =
                            newSubscriptionGroupedWithProratedMinimumPrice.externalPriceId
                        this.name = newSubscriptionGroupedWithProratedMinimumPrice.name
                        this.billableMetricId =
                            newSubscriptionGroupedWithProratedMinimumPrice.billableMetricId
                        this.itemId = newSubscriptionGroupedWithProratedMinimumPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionGroupedWithProratedMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionGroupedWithProratedMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionGroupedWithProratedMinimumPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionGroupedWithProratedMinimumPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionGroupedWithProratedMinimumPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionGroupedWithProratedMinimumPrice
                                .invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionGroupedWithProratedMinimumPrice.conversionRate
                        this.modelType = newSubscriptionGroupedWithProratedMinimumPrice.modelType
                        this.groupedWithProratedMinimumConfig =
                            newSubscriptionGroupedWithProratedMinimumPrice
                                .groupedWithProratedMinimumConfig
                        this.currency = newSubscriptionGroupedWithProratedMinimumPrice.currency
                        additionalProperties(
                            newSubscriptionGroupedWithProratedMinimumPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun groupedWithProratedMinimumConfig(
                        groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                    ) =
                        groupedWithProratedMinimumConfig(
                            JsonField.of(groupedWithProratedMinimumConfig)
                        )

                    @JsonProperty("grouped_with_prorated_minimum_config")
                    @ExcludeMissing
                    fun groupedWithProratedMinimumConfig(
                        groupedWithProratedMinimumConfig:
                            JsonField<GroupedWithProratedMinimumConfig>
                    ) = apply {
                        this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionGroupedWithProratedMinimumPrice =
                        NewSubscriptionGroupedWithProratedMinimumPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            groupedWithProratedMinimumConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = GroupedWithProratedMinimumConfig.Builder::class)
                @NoAutoDetect
                class GroupedWithProratedMinimumConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): GroupedWithProratedMinimumConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is GroupedWithProratedMinimumConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                        ) = apply {
                            additionalProperties(
                                groupedWithProratedMinimumConfig.additionalProperties
                            )
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): GroupedWithProratedMinimumConfig =
                            GroupedWithProratedMinimumConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val GROUPED_WITH_PRORATED_MINIMUM =
                            ModelType(JsonField.of("grouped_with_prorated_minimum"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        GROUPED_WITH_PRORATED_MINIMUM,
                    }

                    enum class Value {
                        GROUPED_WITH_PRORATED_MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkWithProrationConfig(): BulkWithProrationConfig =
                    bulkWithProrationConfig.getRequired("bulk_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_with_proration_config")
                @ExcludeMissing
                fun _bulkWithProrationConfig() = bulkWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkWithProrationConfig == other.bulkWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkWithProrationConfig=$bulkWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionBulkWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionBulkWithProrationPrice.externalPriceId
                        this.name = newSubscriptionBulkWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionBulkWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionBulkWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionBulkWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionBulkWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionBulkWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBulkWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBulkWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBulkWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBulkWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionBulkWithProrationPrice.modelType
                        this.bulkWithProrationConfig =
                            newSubscriptionBulkWithProrationPrice.bulkWithProrationConfig
                        this.currency = newSubscriptionBulkWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionBulkWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                        bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

                    @JsonProperty("bulk_with_proration_config")
                    @ExcludeMissing
                    fun bulkWithProrationConfig(
                        bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
                    ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkWithProrationPrice =
                        NewSubscriptionBulkWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkWithProrationConfig.Builder::class)
                @NoAutoDetect
                class BulkWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) =
                            apply {
                                additionalProperties(bulkWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkWithProrationConfig =
                            BulkWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val BULK_WITH_PRORATION = ModelType(JsonField.of("bulk_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK_WITH_PRORATION,
                    }

                    enum class Value {
                        BULK_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }
        }
    }

    class BillingCycleAlignment
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is BillingCycleAlignment && this.value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            @JvmField val UNCHANGED = BillingCycleAlignment(JsonField.of("unchanged"))

            @JvmField val PLAN_CHANGE_DATE = BillingCycleAlignment(JsonField.of("plan_change_date"))

            @JvmField val START_OF_MONTH = BillingCycleAlignment(JsonField.of("start_of_month"))

            @JvmStatic fun of(value: String) = BillingCycleAlignment(JsonField.of(value))
        }

        enum class Known {
            UNCHANGED,
            PLAN_CHANGE_DATE,
            START_OF_MONTH,
        }

        enum class Value {
            UNCHANGED,
            PLAN_CHANGE_DATE,
            START_OF_MONTH,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                UNCHANGED -> Value.UNCHANGED
                PLAN_CHANGE_DATE -> Value.PLAN_CHANGE_DATE
                START_OF_MONTH -> Value.START_OF_MONTH
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                UNCHANGED -> Known.UNCHANGED
                PLAN_CHANGE_DATE -> Known.PLAN_CHANGE_DATE
                START_OF_MONTH -> Known.START_OF_MONTH
                else -> throw OrbInvalidDataException("Unknown BillingCycleAlignment: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }

    @JsonDeserialize(using = PriceOverride.Deserializer::class)
    @JsonSerialize(using = PriceOverride.Serializer::class)
    class PriceOverride
    private constructor(
        private val overrideUnitPrice: OverrideUnitPrice? = null,
        private val overridePackagePrice: OverridePackagePrice? = null,
        private val overrideMatrixPrice: OverrideMatrixPrice? = null,
        private val overrideTieredPrice: OverrideTieredPrice? = null,
        private val overrideTieredBpsPrice: OverrideTieredBpsPrice? = null,
        private val overrideBpsPrice: OverrideBpsPrice? = null,
        private val overrideBulkBpsPrice: OverrideBulkBpsPrice? = null,
        private val overrideBulkPrice: OverrideBulkPrice? = null,
        private val overrideThresholdTotalAmountPrice: OverrideThresholdTotalAmountPrice? = null,
        private val overrideTieredPackagePrice: OverrideTieredPackagePrice? = null,
        private val overrideTieredWithMinimumPrice: OverrideTieredWithMinimumPrice? = null,
        private val overridePackageWithAllocationPrice: OverridePackageWithAllocationPrice? = null,
        private val overrideUnitWithPercentPrice: OverrideUnitWithPercentPrice? = null,
        private val overrideGroupedAllocationPrice: OverrideGroupedAllocationPrice? = null,
        private val overrideGroupedWithProratedMinimumPrice:
            OverrideGroupedWithProratedMinimumPrice? =
            null,
        private val overrideGroupedWithMeteredMinimumPrice:
            OverrideGroupedWithMeteredMinimumPrice? =
            null,
        private val overrideBulkWithProrationPrice: OverrideBulkWithProrationPrice? = null,
        private val overrideUnitWithProrationPrice: OverrideUnitWithProrationPrice? = null,
        private val overrideTieredWithProrationPrice: OverrideTieredWithProrationPrice? = null,
        private val _json: JsonValue? = null,
    ) {

        private var validated: Boolean = false

        fun overrideUnitPrice(): Optional<OverrideUnitPrice> =
            Optional.ofNullable(overrideUnitPrice)

        fun overridePackagePrice(): Optional<OverridePackagePrice> =
            Optional.ofNullable(overridePackagePrice)

        fun overrideMatrixPrice(): Optional<OverrideMatrixPrice> =
            Optional.ofNullable(overrideMatrixPrice)

        fun overrideTieredPrice(): Optional<OverrideTieredPrice> =
            Optional.ofNullable(overrideTieredPrice)

        fun overrideTieredBpsPrice(): Optional<OverrideTieredBpsPrice> =
            Optional.ofNullable(overrideTieredBpsPrice)

        fun overrideBpsPrice(): Optional<OverrideBpsPrice> = Optional.ofNullable(overrideBpsPrice)

        fun overrideBulkBpsPrice(): Optional<OverrideBulkBpsPrice> =
            Optional.ofNullable(overrideBulkBpsPrice)

        fun overrideBulkPrice(): Optional<OverrideBulkPrice> =
            Optional.ofNullable(overrideBulkPrice)

        fun overrideThresholdTotalAmountPrice(): Optional<OverrideThresholdTotalAmountPrice> =
            Optional.ofNullable(overrideThresholdTotalAmountPrice)

        fun overrideTieredPackagePrice(): Optional<OverrideTieredPackagePrice> =
            Optional.ofNullable(overrideTieredPackagePrice)

        fun overrideTieredWithMinimumPrice(): Optional<OverrideTieredWithMinimumPrice> =
            Optional.ofNullable(overrideTieredWithMinimumPrice)

        fun overridePackageWithAllocationPrice(): Optional<OverridePackageWithAllocationPrice> =
            Optional.ofNullable(overridePackageWithAllocationPrice)

        fun overrideUnitWithPercentPrice(): Optional<OverrideUnitWithPercentPrice> =
            Optional.ofNullable(overrideUnitWithPercentPrice)

        fun overrideGroupedAllocationPrice(): Optional<OverrideGroupedAllocationPrice> =
            Optional.ofNullable(overrideGroupedAllocationPrice)

        fun overrideGroupedWithProratedMinimumPrice():
            Optional<OverrideGroupedWithProratedMinimumPrice> =
            Optional.ofNullable(overrideGroupedWithProratedMinimumPrice)

        fun overrideGroupedWithMeteredMinimumPrice():
            Optional<OverrideGroupedWithMeteredMinimumPrice> =
            Optional.ofNullable(overrideGroupedWithMeteredMinimumPrice)

        fun overrideBulkWithProrationPrice(): Optional<OverrideBulkWithProrationPrice> =
            Optional.ofNullable(overrideBulkWithProrationPrice)

        fun overrideUnitWithProrationPrice(): Optional<OverrideUnitWithProrationPrice> =
            Optional.ofNullable(overrideUnitWithProrationPrice)

        fun overrideTieredWithProrationPrice(): Optional<OverrideTieredWithProrationPrice> =
            Optional.ofNullable(overrideTieredWithProrationPrice)

        fun isOverrideUnitPrice(): Boolean = overrideUnitPrice != null

        fun isOverridePackagePrice(): Boolean = overridePackagePrice != null

        fun isOverrideMatrixPrice(): Boolean = overrideMatrixPrice != null

        fun isOverrideTieredPrice(): Boolean = overrideTieredPrice != null

        fun isOverrideTieredBpsPrice(): Boolean = overrideTieredBpsPrice != null

        fun isOverrideBpsPrice(): Boolean = overrideBpsPrice != null

        fun isOverrideBulkBpsPrice(): Boolean = overrideBulkBpsPrice != null

        fun isOverrideBulkPrice(): Boolean = overrideBulkPrice != null

        fun isOverrideThresholdTotalAmountPrice(): Boolean =
            overrideThresholdTotalAmountPrice != null

        fun isOverrideTieredPackagePrice(): Boolean = overrideTieredPackagePrice != null

        fun isOverrideTieredWithMinimumPrice(): Boolean = overrideTieredWithMinimumPrice != null

        fun isOverridePackageWithAllocationPrice(): Boolean =
            overridePackageWithAllocationPrice != null

        fun isOverrideUnitWithPercentPrice(): Boolean = overrideUnitWithPercentPrice != null

        fun isOverrideGroupedAllocationPrice(): Boolean = overrideGroupedAllocationPrice != null

        fun isOverrideGroupedWithProratedMinimumPrice(): Boolean =
            overrideGroupedWithProratedMinimumPrice != null

        fun isOverrideGroupedWithMeteredMinimumPrice(): Boolean =
            overrideGroupedWithMeteredMinimumPrice != null

        fun isOverrideBulkWithProrationPrice(): Boolean = overrideBulkWithProrationPrice != null

        fun isOverrideUnitWithProrationPrice(): Boolean = overrideUnitWithProrationPrice != null

        fun isOverrideTieredWithProrationPrice(): Boolean = overrideTieredWithProrationPrice != null

        fun asOverrideUnitPrice(): OverrideUnitPrice =
            overrideUnitPrice.getOrThrow("overrideUnitPrice")

        fun asOverridePackagePrice(): OverridePackagePrice =
            overridePackagePrice.getOrThrow("overridePackagePrice")

        fun asOverrideMatrixPrice(): OverrideMatrixPrice =
            overrideMatrixPrice.getOrThrow("overrideMatrixPrice")

        fun asOverrideTieredPrice(): OverrideTieredPrice =
            overrideTieredPrice.getOrThrow("overrideTieredPrice")

        fun asOverrideTieredBpsPrice(): OverrideTieredBpsPrice =
            overrideTieredBpsPrice.getOrThrow("overrideTieredBpsPrice")

        fun asOverrideBpsPrice(): OverrideBpsPrice = overrideBpsPrice.getOrThrow("overrideBpsPrice")

        fun asOverrideBulkBpsPrice(): OverrideBulkBpsPrice =
            overrideBulkBpsPrice.getOrThrow("overrideBulkBpsPrice")

        fun asOverrideBulkPrice(): OverrideBulkPrice =
            overrideBulkPrice.getOrThrow("overrideBulkPrice")

        fun asOverrideThresholdTotalAmountPrice(): OverrideThresholdTotalAmountPrice =
            overrideThresholdTotalAmountPrice.getOrThrow("overrideThresholdTotalAmountPrice")

        fun asOverrideTieredPackagePrice(): OverrideTieredPackagePrice =
            overrideTieredPackagePrice.getOrThrow("overrideTieredPackagePrice")

        fun asOverrideTieredWithMinimumPrice(): OverrideTieredWithMinimumPrice =
            overrideTieredWithMinimumPrice.getOrThrow("overrideTieredWithMinimumPrice")

        fun asOverridePackageWithAllocationPrice(): OverridePackageWithAllocationPrice =
            overridePackageWithAllocationPrice.getOrThrow("overridePackageWithAllocationPrice")

        fun asOverrideUnitWithPercentPrice(): OverrideUnitWithPercentPrice =
            overrideUnitWithPercentPrice.getOrThrow("overrideUnitWithPercentPrice")

        fun asOverrideGroupedAllocationPrice(): OverrideGroupedAllocationPrice =
            overrideGroupedAllocationPrice.getOrThrow("overrideGroupedAllocationPrice")

        fun asOverrideGroupedWithProratedMinimumPrice(): OverrideGroupedWithProratedMinimumPrice =
            overrideGroupedWithProratedMinimumPrice.getOrThrow(
                "overrideGroupedWithProratedMinimumPrice"
            )

        fun asOverrideGroupedWithMeteredMinimumPrice(): OverrideGroupedWithMeteredMinimumPrice =
            overrideGroupedWithMeteredMinimumPrice.getOrThrow(
                "overrideGroupedWithMeteredMinimumPrice"
            )

        fun asOverrideBulkWithProrationPrice(): OverrideBulkWithProrationPrice =
            overrideBulkWithProrationPrice.getOrThrow("overrideBulkWithProrationPrice")

        fun asOverrideUnitWithProrationPrice(): OverrideUnitWithProrationPrice =
            overrideUnitWithProrationPrice.getOrThrow("overrideUnitWithProrationPrice")

        fun asOverrideTieredWithProrationPrice(): OverrideTieredWithProrationPrice =
            overrideTieredWithProrationPrice.getOrThrow("overrideTieredWithProrationPrice")

        fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                overrideUnitPrice != null -> visitor.visitOverrideUnitPrice(overrideUnitPrice)
                overridePackagePrice != null ->
                    visitor.visitOverridePackagePrice(overridePackagePrice)
                overrideMatrixPrice != null -> visitor.visitOverrideMatrixPrice(overrideMatrixPrice)
                overrideTieredPrice != null -> visitor.visitOverrideTieredPrice(overrideTieredPrice)
                overrideTieredBpsPrice != null ->
                    visitor.visitOverrideTieredBpsPrice(overrideTieredBpsPrice)
                overrideBpsPrice != null -> visitor.visitOverrideBpsPrice(overrideBpsPrice)
                overrideBulkBpsPrice != null ->
                    visitor.visitOverrideBulkBpsPrice(overrideBulkBpsPrice)
                overrideBulkPrice != null -> visitor.visitOverrideBulkPrice(overrideBulkPrice)
                overrideThresholdTotalAmountPrice != null ->
                    visitor.visitOverrideThresholdTotalAmountPrice(
                        overrideThresholdTotalAmountPrice
                    )
                overrideTieredPackagePrice != null ->
                    visitor.visitOverrideTieredPackagePrice(overrideTieredPackagePrice)
                overrideTieredWithMinimumPrice != null ->
                    visitor.visitOverrideTieredWithMinimumPrice(overrideTieredWithMinimumPrice)
                overridePackageWithAllocationPrice != null ->
                    visitor.visitOverridePackageWithAllocationPrice(
                        overridePackageWithAllocationPrice
                    )
                overrideUnitWithPercentPrice != null ->
                    visitor.visitOverrideUnitWithPercentPrice(overrideUnitWithPercentPrice)
                overrideGroupedAllocationPrice != null ->
                    visitor.visitOverrideGroupedAllocationPrice(overrideGroupedAllocationPrice)
                overrideGroupedWithProratedMinimumPrice != null ->
                    visitor.visitOverrideGroupedWithProratedMinimumPrice(
                        overrideGroupedWithProratedMinimumPrice
                    )
                overrideGroupedWithMeteredMinimumPrice != null ->
                    visitor.visitOverrideGroupedWithMeteredMinimumPrice(
                        overrideGroupedWithMeteredMinimumPrice
                    )
                overrideBulkWithProrationPrice != null ->
                    visitor.visitOverrideBulkWithProrationPrice(overrideBulkWithProrationPrice)
                overrideUnitWithProrationPrice != null ->
                    visitor.visitOverrideUnitWithProrationPrice(overrideUnitWithProrationPrice)
                overrideTieredWithProrationPrice != null ->
                    visitor.visitOverrideTieredWithProrationPrice(overrideTieredWithProrationPrice)
                else -> visitor.unknown(_json)
            }
        }

        fun validate(): PriceOverride = apply {
            if (!validated) {
                if (
                    overrideUnitPrice == null &&
                        overridePackagePrice == null &&
                        overrideMatrixPrice == null &&
                        overrideTieredPrice == null &&
                        overrideTieredBpsPrice == null &&
                        overrideBpsPrice == null &&
                        overrideBulkBpsPrice == null &&
                        overrideBulkPrice == null &&
                        overrideThresholdTotalAmountPrice == null &&
                        overrideTieredPackagePrice == null &&
                        overrideTieredWithMinimumPrice == null &&
                        overridePackageWithAllocationPrice == null &&
                        overrideUnitWithPercentPrice == null &&
                        overrideGroupedAllocationPrice == null &&
                        overrideGroupedWithProratedMinimumPrice == null &&
                        overrideGroupedWithMeteredMinimumPrice == null &&
                        overrideBulkWithProrationPrice == null &&
                        overrideUnitWithProrationPrice == null &&
                        overrideTieredWithProrationPrice == null
                ) {
                    throw OrbInvalidDataException("Unknown PriceOverride: $_json")
                }
                overrideUnitPrice?.validate()
                overridePackagePrice?.validate()
                overrideMatrixPrice?.validate()
                overrideTieredPrice?.validate()
                overrideTieredBpsPrice?.validate()
                overrideBpsPrice?.validate()
                overrideBulkBpsPrice?.validate()
                overrideBulkPrice?.validate()
                overrideThresholdTotalAmountPrice?.validate()
                overrideTieredPackagePrice?.validate()
                overrideTieredWithMinimumPrice?.validate()
                overridePackageWithAllocationPrice?.validate()
                overrideUnitWithPercentPrice?.validate()
                overrideGroupedAllocationPrice?.validate()
                overrideGroupedWithProratedMinimumPrice?.validate()
                overrideGroupedWithMeteredMinimumPrice?.validate()
                overrideBulkWithProrationPrice?.validate()
                overrideUnitWithProrationPrice?.validate()
                overrideTieredWithProrationPrice?.validate()
                validated = true
            }
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is PriceOverride &&
                this.overrideUnitPrice == other.overrideUnitPrice &&
                this.overridePackagePrice == other.overridePackagePrice &&
                this.overrideMatrixPrice == other.overrideMatrixPrice &&
                this.overrideTieredPrice == other.overrideTieredPrice &&
                this.overrideTieredBpsPrice == other.overrideTieredBpsPrice &&
                this.overrideBpsPrice == other.overrideBpsPrice &&
                this.overrideBulkBpsPrice == other.overrideBulkBpsPrice &&
                this.overrideBulkPrice == other.overrideBulkPrice &&
                this.overrideThresholdTotalAmountPrice == other.overrideThresholdTotalAmountPrice &&
                this.overrideTieredPackagePrice == other.overrideTieredPackagePrice &&
                this.overrideTieredWithMinimumPrice == other.overrideTieredWithMinimumPrice &&
                this.overridePackageWithAllocationPrice ==
                    other.overridePackageWithAllocationPrice &&
                this.overrideUnitWithPercentPrice == other.overrideUnitWithPercentPrice &&
                this.overrideGroupedAllocationPrice == other.overrideGroupedAllocationPrice &&
                this.overrideGroupedWithProratedMinimumPrice ==
                    other.overrideGroupedWithProratedMinimumPrice &&
                this.overrideGroupedWithMeteredMinimumPrice ==
                    other.overrideGroupedWithMeteredMinimumPrice &&
                this.overrideBulkWithProrationPrice == other.overrideBulkWithProrationPrice &&
                this.overrideUnitWithProrationPrice == other.overrideUnitWithProrationPrice &&
                this.overrideTieredWithProrationPrice == other.overrideTieredWithProrationPrice
        }

        override fun hashCode(): Int {
            return Objects.hash(
                overrideUnitPrice,
                overridePackagePrice,
                overrideMatrixPrice,
                overrideTieredPrice,
                overrideTieredBpsPrice,
                overrideBpsPrice,
                overrideBulkBpsPrice,
                overrideBulkPrice,
                overrideThresholdTotalAmountPrice,
                overrideTieredPackagePrice,
                overrideTieredWithMinimumPrice,
                overridePackageWithAllocationPrice,
                overrideUnitWithPercentPrice,
                overrideGroupedAllocationPrice,
                overrideGroupedWithProratedMinimumPrice,
                overrideGroupedWithMeteredMinimumPrice,
                overrideBulkWithProrationPrice,
                overrideUnitWithProrationPrice,
                overrideTieredWithProrationPrice,
            )
        }

        override fun toString(): String {
            return when {
                overrideUnitPrice != null -> "PriceOverride{overrideUnitPrice=$overrideUnitPrice}"
                overridePackagePrice != null ->
                    "PriceOverride{overridePackagePrice=$overridePackagePrice}"
                overrideMatrixPrice != null ->
                    "PriceOverride{overrideMatrixPrice=$overrideMatrixPrice}"
                overrideTieredPrice != null ->
                    "PriceOverride{overrideTieredPrice=$overrideTieredPrice}"
                overrideTieredBpsPrice != null ->
                    "PriceOverride{overrideTieredBpsPrice=$overrideTieredBpsPrice}"
                overrideBpsPrice != null -> "PriceOverride{overrideBpsPrice=$overrideBpsPrice}"
                overrideBulkBpsPrice != null ->
                    "PriceOverride{overrideBulkBpsPrice=$overrideBulkBpsPrice}"
                overrideBulkPrice != null -> "PriceOverride{overrideBulkPrice=$overrideBulkPrice}"
                overrideThresholdTotalAmountPrice != null ->
                    "PriceOverride{overrideThresholdTotalAmountPrice=$overrideThresholdTotalAmountPrice}"
                overrideTieredPackagePrice != null ->
                    "PriceOverride{overrideTieredPackagePrice=$overrideTieredPackagePrice}"
                overrideTieredWithMinimumPrice != null ->
                    "PriceOverride{overrideTieredWithMinimumPrice=$overrideTieredWithMinimumPrice}"
                overridePackageWithAllocationPrice != null ->
                    "PriceOverride{overridePackageWithAllocationPrice=$overridePackageWithAllocationPrice}"
                overrideUnitWithPercentPrice != null ->
                    "PriceOverride{overrideUnitWithPercentPrice=$overrideUnitWithPercentPrice}"
                overrideGroupedAllocationPrice != null ->
                    "PriceOverride{overrideGroupedAllocationPrice=$overrideGroupedAllocationPrice}"
                overrideGroupedWithProratedMinimumPrice != null ->
                    "PriceOverride{overrideGroupedWithProratedMinimumPrice=$overrideGroupedWithProratedMinimumPrice}"
                overrideGroupedWithMeteredMinimumPrice != null ->
                    "PriceOverride{overrideGroupedWithMeteredMinimumPrice=$overrideGroupedWithMeteredMinimumPrice}"
                overrideBulkWithProrationPrice != null ->
                    "PriceOverride{overrideBulkWithProrationPrice=$overrideBulkWithProrationPrice}"
                overrideUnitWithProrationPrice != null ->
                    "PriceOverride{overrideUnitWithProrationPrice=$overrideUnitWithProrationPrice}"
                overrideTieredWithProrationPrice != null ->
                    "PriceOverride{overrideTieredWithProrationPrice=$overrideTieredWithProrationPrice}"
                _json != null -> "PriceOverride{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid PriceOverride")
            }
        }

        companion object {

            @JvmStatic
            fun ofOverrideUnitPrice(overrideUnitPrice: OverrideUnitPrice) =
                PriceOverride(overrideUnitPrice = overrideUnitPrice)

            @JvmStatic
            fun ofOverridePackagePrice(overridePackagePrice: OverridePackagePrice) =
                PriceOverride(overridePackagePrice = overridePackagePrice)

            @JvmStatic
            fun ofOverrideMatrixPrice(overrideMatrixPrice: OverrideMatrixPrice) =
                PriceOverride(overrideMatrixPrice = overrideMatrixPrice)

            @JvmStatic
            fun ofOverrideTieredPrice(overrideTieredPrice: OverrideTieredPrice) =
                PriceOverride(overrideTieredPrice = overrideTieredPrice)

            @JvmStatic
            fun ofOverrideTieredBpsPrice(overrideTieredBpsPrice: OverrideTieredBpsPrice) =
                PriceOverride(overrideTieredBpsPrice = overrideTieredBpsPrice)

            @JvmStatic
            fun ofOverrideBpsPrice(overrideBpsPrice: OverrideBpsPrice) =
                PriceOverride(overrideBpsPrice = overrideBpsPrice)

            @JvmStatic
            fun ofOverrideBulkBpsPrice(overrideBulkBpsPrice: OverrideBulkBpsPrice) =
                PriceOverride(overrideBulkBpsPrice = overrideBulkBpsPrice)

            @JvmStatic
            fun ofOverrideBulkPrice(overrideBulkPrice: OverrideBulkPrice) =
                PriceOverride(overrideBulkPrice = overrideBulkPrice)

            @JvmStatic
            fun ofOverrideThresholdTotalAmountPrice(
                overrideThresholdTotalAmountPrice: OverrideThresholdTotalAmountPrice
            ) = PriceOverride(overrideThresholdTotalAmountPrice = overrideThresholdTotalAmountPrice)

            @JvmStatic
            fun ofOverrideTieredPackagePrice(
                overrideTieredPackagePrice: OverrideTieredPackagePrice
            ) = PriceOverride(overrideTieredPackagePrice = overrideTieredPackagePrice)

            @JvmStatic
            fun ofOverrideTieredWithMinimumPrice(
                overrideTieredWithMinimumPrice: OverrideTieredWithMinimumPrice
            ) = PriceOverride(overrideTieredWithMinimumPrice = overrideTieredWithMinimumPrice)

            @JvmStatic
            fun ofOverridePackageWithAllocationPrice(
                overridePackageWithAllocationPrice: OverridePackageWithAllocationPrice
            ) =
                PriceOverride(
                    overridePackageWithAllocationPrice = overridePackageWithAllocationPrice
                )

            @JvmStatic
            fun ofOverrideUnitWithPercentPrice(
                overrideUnitWithPercentPrice: OverrideUnitWithPercentPrice
            ) = PriceOverride(overrideUnitWithPercentPrice = overrideUnitWithPercentPrice)

            @JvmStatic
            fun ofOverrideGroupedAllocationPrice(
                overrideGroupedAllocationPrice: OverrideGroupedAllocationPrice
            ) = PriceOverride(overrideGroupedAllocationPrice = overrideGroupedAllocationPrice)

            @JvmStatic
            fun ofOverrideGroupedWithProratedMinimumPrice(
                overrideGroupedWithProratedMinimumPrice: OverrideGroupedWithProratedMinimumPrice
            ) =
                PriceOverride(
                    overrideGroupedWithProratedMinimumPrice =
                        overrideGroupedWithProratedMinimumPrice
                )

            @JvmStatic
            fun ofOverrideGroupedWithMeteredMinimumPrice(
                overrideGroupedWithMeteredMinimumPrice: OverrideGroupedWithMeteredMinimumPrice
            ) =
                PriceOverride(
                    overrideGroupedWithMeteredMinimumPrice = overrideGroupedWithMeteredMinimumPrice
                )

            @JvmStatic
            fun ofOverrideBulkWithProrationPrice(
                overrideBulkWithProrationPrice: OverrideBulkWithProrationPrice
            ) = PriceOverride(overrideBulkWithProrationPrice = overrideBulkWithProrationPrice)

            @JvmStatic
            fun ofOverrideUnitWithProrationPrice(
                overrideUnitWithProrationPrice: OverrideUnitWithProrationPrice
            ) = PriceOverride(overrideUnitWithProrationPrice = overrideUnitWithProrationPrice)

            @JvmStatic
            fun ofOverrideTieredWithProrationPrice(
                overrideTieredWithProrationPrice: OverrideTieredWithProrationPrice
            ) = PriceOverride(overrideTieredWithProrationPrice = overrideTieredWithProrationPrice)
        }

        interface Visitor<out T> {

            fun visitOverrideUnitPrice(overrideUnitPrice: OverrideUnitPrice): T

            fun visitOverridePackagePrice(overridePackagePrice: OverridePackagePrice): T

            fun visitOverrideMatrixPrice(overrideMatrixPrice: OverrideMatrixPrice): T

            fun visitOverrideTieredPrice(overrideTieredPrice: OverrideTieredPrice): T

            fun visitOverrideTieredBpsPrice(overrideTieredBpsPrice: OverrideTieredBpsPrice): T

            fun visitOverrideBpsPrice(overrideBpsPrice: OverrideBpsPrice): T

            fun visitOverrideBulkBpsPrice(overrideBulkBpsPrice: OverrideBulkBpsPrice): T

            fun visitOverrideBulkPrice(overrideBulkPrice: OverrideBulkPrice): T

            fun visitOverrideThresholdTotalAmountPrice(
                overrideThresholdTotalAmountPrice: OverrideThresholdTotalAmountPrice
            ): T

            fun visitOverrideTieredPackagePrice(
                overrideTieredPackagePrice: OverrideTieredPackagePrice
            ): T

            fun visitOverrideTieredWithMinimumPrice(
                overrideTieredWithMinimumPrice: OverrideTieredWithMinimumPrice
            ): T

            fun visitOverridePackageWithAllocationPrice(
                overridePackageWithAllocationPrice: OverridePackageWithAllocationPrice
            ): T

            fun visitOverrideUnitWithPercentPrice(
                overrideUnitWithPercentPrice: OverrideUnitWithPercentPrice
            ): T

            fun visitOverrideGroupedAllocationPrice(
                overrideGroupedAllocationPrice: OverrideGroupedAllocationPrice
            ): T

            fun visitOverrideGroupedWithProratedMinimumPrice(
                overrideGroupedWithProratedMinimumPrice: OverrideGroupedWithProratedMinimumPrice
            ): T

            fun visitOverrideGroupedWithMeteredMinimumPrice(
                overrideGroupedWithMeteredMinimumPrice: OverrideGroupedWithMeteredMinimumPrice
            ): T

            fun visitOverrideBulkWithProrationPrice(
                overrideBulkWithProrationPrice: OverrideBulkWithProrationPrice
            ): T

            fun visitOverrideUnitWithProrationPrice(
                overrideUnitWithProrationPrice: OverrideUnitWithProrationPrice
            ): T

            fun visitOverrideTieredWithProrationPrice(
                overrideTieredWithProrationPrice: OverrideTieredWithProrationPrice
            ): T

            fun unknown(json: JsonValue?): T {
                throw OrbInvalidDataException("Unknown PriceOverride: $json")
            }
        }

        class Deserializer : BaseDeserializer<PriceOverride>(PriceOverride::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): PriceOverride {
                val json = JsonValue.fromJsonNode(node)
                tryDeserialize(node, jacksonTypeRef<OverrideUnitPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideUnitPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverridePackagePrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overridePackagePrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideMatrixPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideMatrixPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideTieredPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideTieredPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideTieredBpsPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideTieredBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideBpsPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideBulkBpsPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideBulkBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideBulkPrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideBulkPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideThresholdTotalAmountPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideThresholdTotalAmountPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideTieredPackagePrice>()) { it.validate() }
                    ?.let {
                        return PriceOverride(overrideTieredPackagePrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideTieredWithMinimumPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideTieredWithMinimumPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverridePackageWithAllocationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overridePackageWithAllocationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideUnitWithPercentPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideUnitWithPercentPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideGroupedAllocationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideGroupedAllocationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideGroupedWithProratedMinimumPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(
                            overrideGroupedWithProratedMinimumPrice = it,
                            _json = json
                        )
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideGroupedWithMeteredMinimumPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(
                            overrideGroupedWithMeteredMinimumPrice = it,
                            _json = json
                        )
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideBulkWithProrationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideBulkWithProrationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideUnitWithProrationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideUnitWithProrationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<OverrideTieredWithProrationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return PriceOverride(overrideTieredWithProrationPrice = it, _json = json)
                    }

                return PriceOverride(_json = json)
            }
        }

        class Serializer : BaseSerializer<PriceOverride>(PriceOverride::class) {

            override fun serialize(
                value: PriceOverride,
                generator: JsonGenerator,
                provider: SerializerProvider
            ) {
                when {
                    value.overrideUnitPrice != null ->
                        generator.writeObject(value.overrideUnitPrice)
                    value.overridePackagePrice != null ->
                        generator.writeObject(value.overridePackagePrice)
                    value.overrideMatrixPrice != null ->
                        generator.writeObject(value.overrideMatrixPrice)
                    value.overrideTieredPrice != null ->
                        generator.writeObject(value.overrideTieredPrice)
                    value.overrideTieredBpsPrice != null ->
                        generator.writeObject(value.overrideTieredBpsPrice)
                    value.overrideBpsPrice != null -> generator.writeObject(value.overrideBpsPrice)
                    value.overrideBulkBpsPrice != null ->
                        generator.writeObject(value.overrideBulkBpsPrice)
                    value.overrideBulkPrice != null ->
                        generator.writeObject(value.overrideBulkPrice)
                    value.overrideThresholdTotalAmountPrice != null ->
                        generator.writeObject(value.overrideThresholdTotalAmountPrice)
                    value.overrideTieredPackagePrice != null ->
                        generator.writeObject(value.overrideTieredPackagePrice)
                    value.overrideTieredWithMinimumPrice != null ->
                        generator.writeObject(value.overrideTieredWithMinimumPrice)
                    value.overridePackageWithAllocationPrice != null ->
                        generator.writeObject(value.overridePackageWithAllocationPrice)
                    value.overrideUnitWithPercentPrice != null ->
                        generator.writeObject(value.overrideUnitWithPercentPrice)
                    value.overrideGroupedAllocationPrice != null ->
                        generator.writeObject(value.overrideGroupedAllocationPrice)
                    value.overrideGroupedWithProratedMinimumPrice != null ->
                        generator.writeObject(value.overrideGroupedWithProratedMinimumPrice)
                    value.overrideGroupedWithMeteredMinimumPrice != null ->
                        generator.writeObject(value.overrideGroupedWithMeteredMinimumPrice)
                    value.overrideBulkWithProrationPrice != null ->
                        generator.writeObject(value.overrideBulkWithProrationPrice)
                    value.overrideUnitWithProrationPrice != null ->
                        generator.writeObject(value.overrideUnitWithProrationPrice)
                    value.overrideTieredWithProrationPrice != null ->
                        generator.writeObject(value.overrideTieredWithProrationPrice)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid PriceOverride")
                }
            }
        }

        @JsonDeserialize(builder = OverrideUnitPrice.Builder::class)
        @NoAutoDetect
        class OverrideUnitPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val unitConfig: JsonField<UnitConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("unit_config") @ExcludeMissing fun _unitConfig() = unitConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideUnitPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    unitConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideUnitPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.unitConfig == other.unitConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            unitConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideUnitPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, unitConfig=$unitConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var unitConfig: JsonField<UnitConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideUnitPrice: OverrideUnitPrice) = apply {
                    this.id = overrideUnitPrice.id
                    this.modelType = overrideUnitPrice.modelType
                    this.minimumAmount = overrideUnitPrice.minimumAmount
                    this.maximumAmount = overrideUnitPrice.maximumAmount
                    this.currency = overrideUnitPrice.currency
                    this.conversionRate = overrideUnitPrice.conversionRate
                    this.discount = overrideUnitPrice.discount
                    this.fixedPriceQuantity = overrideUnitPrice.fixedPriceQuantity
                    this.unitConfig = overrideUnitPrice.unitConfig
                    additionalProperties(overrideUnitPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

                @JsonProperty("unit_config")
                @ExcludeMissing
                fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                    this.unitConfig = unitConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideUnitPrice =
                    OverrideUnitPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        unitConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT = ModelType(JsonField.of("unit"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT,
                }

                enum class Value {
                    UNIT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT -> Value.UNIT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT -> Known.UNIT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitConfig.Builder::class)
            @NoAutoDetect
            class UnitConfig
            private constructor(
                private val unitAmount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Rate per unit of usage */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /** Rate per unit of usage */
                @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitConfig = apply {
                    if (!validated) {
                        unitAmount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitConfig &&
                        this.unitAmount == other.unitAmount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(unitAmount, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var unitAmount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitConfig: UnitConfig) = apply {
                        this.unitAmount = unitConfig.unitAmount
                        additionalProperties(unitConfig.additionalProperties)
                    }

                    /** Rate per unit of usage */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Rate per unit of usage */
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitConfig =
                        UnitConfig(unitAmount, additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverridePackagePrice.Builder::class)
        @NoAutoDetect
        class OverridePackagePrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val packageConfig: JsonField<PackageConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("package_config") @ExcludeMissing fun _packageConfig() = packageConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverridePackagePrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    packageConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverridePackagePrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.packageConfig == other.packageConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            packageConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverridePackagePrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, packageConfig=$packageConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var packageConfig: JsonField<PackageConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overridePackagePrice: OverridePackagePrice) = apply {
                    this.id = overridePackagePrice.id
                    this.modelType = overridePackagePrice.modelType
                    this.minimumAmount = overridePackagePrice.minimumAmount
                    this.maximumAmount = overridePackagePrice.maximumAmount
                    this.currency = overridePackagePrice.currency
                    this.conversionRate = overridePackagePrice.conversionRate
                    this.discount = overridePackagePrice.discount
                    this.fixedPriceQuantity = overridePackagePrice.fixedPriceQuantity
                    this.packageConfig = overridePackagePrice.packageConfig
                    additionalProperties(overridePackagePrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun packageConfig(packageConfig: PackageConfig) =
                    packageConfig(JsonField.of(packageConfig))

                @JsonProperty("package_config")
                @ExcludeMissing
                fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                    this.packageConfig = packageConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverridePackagePrice =
                    OverridePackagePrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        packageConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val PACKAGE = ModelType(JsonField.of("package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE,
                }

                enum class Value {
                    PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE -> Value.PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE -> Known.PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageConfig.Builder::class)
            @NoAutoDetect
            class PackageConfig
            private constructor(
                private val packageAmount: JsonField<String>,
                private val packageSize: JsonField<Long>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** A currency amount to rate usage by */
                fun packageAmount(): String = packageAmount.getRequired("package_amount")

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(): Long = packageSize.getRequired("package_size")

                /** A currency amount to rate usage by */
                @JsonProperty("package_amount") @ExcludeMissing fun _packageAmount() = packageAmount

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                @JsonProperty("package_size") @ExcludeMissing fun _packageSize() = packageSize

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageConfig = apply {
                    if (!validated) {
                        packageAmount()
                        packageSize()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PackageConfig &&
                        this.packageAmount == other.packageAmount &&
                        this.packageSize == other.packageSize &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                packageAmount,
                                packageSize,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var packageAmount: JsonField<String> = JsonMissing.of()
                    private var packageSize: JsonField<Long> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageConfig: PackageConfig) = apply {
                        this.packageAmount = packageConfig.packageAmount
                        this.packageSize = packageConfig.packageSize
                        additionalProperties(packageConfig.additionalProperties)
                    }

                    /** A currency amount to rate usage by */
                    fun packageAmount(packageAmount: String) =
                        packageAmount(JsonField.of(packageAmount))

                    /** A currency amount to rate usage by */
                    @JsonProperty("package_amount")
                    @ExcludeMissing
                    fun packageAmount(packageAmount: JsonField<String>) = apply {
                        this.packageAmount = packageAmount
                    }

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    @JsonProperty("package_size")
                    @ExcludeMissing
                    fun packageSize(packageSize: JsonField<Long>) = apply {
                        this.packageSize = packageSize
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageConfig =
                        PackageConfig(
                            packageAmount,
                            packageSize,
                            additionalProperties.toUnmodifiable(),
                        )
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideMatrixPrice.Builder::class)
        @NoAutoDetect
        class OverrideMatrixPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val matrixConfig: JsonField<MatrixConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("matrix_config") @ExcludeMissing fun _matrixConfig() = matrixConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideMatrixPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    matrixConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideMatrixPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.matrixConfig == other.matrixConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            matrixConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideMatrixPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, matrixConfig=$matrixConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var matrixConfig: JsonField<MatrixConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideMatrixPrice: OverrideMatrixPrice) = apply {
                    this.id = overrideMatrixPrice.id
                    this.modelType = overrideMatrixPrice.modelType
                    this.minimumAmount = overrideMatrixPrice.minimumAmount
                    this.maximumAmount = overrideMatrixPrice.maximumAmount
                    this.currency = overrideMatrixPrice.currency
                    this.conversionRate = overrideMatrixPrice.conversionRate
                    this.discount = overrideMatrixPrice.discount
                    this.fixedPriceQuantity = overrideMatrixPrice.fixedPriceQuantity
                    this.matrixConfig = overrideMatrixPrice.matrixConfig
                    additionalProperties(overrideMatrixPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun matrixConfig(matrixConfig: MatrixConfig) =
                    matrixConfig(JsonField.of(matrixConfig))

                @JsonProperty("matrix_config")
                @ExcludeMissing
                fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                    this.matrixConfig = matrixConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideMatrixPrice =
                    OverrideMatrixPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        matrixConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = MatrixConfig.Builder::class)
            @NoAutoDetect
            class MatrixConfig
            private constructor(
                private val dimensions: JsonField<List<String?>>,
                private val defaultUnitAmount: JsonField<String>,
                private val matrixValues: JsonField<List<MatrixValue>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(): String =
                    defaultUnitAmount.getRequired("default_unit_amount")

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

                /** One or two event property values to evaluate matrix groups by */
                @JsonProperty("dimensions") @ExcludeMissing fun _dimensions() = dimensions

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                @JsonProperty("default_unit_amount")
                @ExcludeMissing
                fun _defaultUnitAmount() = defaultUnitAmount

                /** Matrix values for specified matrix grouping keys */
                @JsonProperty("matrix_values") @ExcludeMissing fun _matrixValues() = matrixValues

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): MatrixConfig = apply {
                    if (!validated) {
                        dimensions()
                        defaultUnitAmount()
                        matrixValues().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MatrixConfig &&
                        this.dimensions == other.dimensions &&
                        this.defaultUnitAmount == other.defaultUnitAmount &&
                        this.matrixValues == other.matrixValues &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                dimensions,
                                defaultUnitAmount,
                                matrixValues,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "MatrixConfig{dimensions=$dimensions, defaultUnitAmount=$defaultUnitAmount, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var dimensions: JsonField<List<String?>> = JsonMissing.of()
                    private var defaultUnitAmount: JsonField<String> = JsonMissing.of()
                    private var matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixConfig: MatrixConfig) = apply {
                        this.dimensions = matrixConfig.dimensions
                        this.defaultUnitAmount = matrixConfig.defaultUnitAmount
                        this.matrixValues = matrixConfig.matrixValues
                        additionalProperties(matrixConfig.additionalProperties)
                    }

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                    /** One or two event property values to evaluate matrix groups by */
                    @JsonProperty("dimensions")
                    @ExcludeMissing
                    fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                        this.dimensions = dimensions
                    }

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(defaultUnitAmount: String) =
                        defaultUnitAmount(JsonField.of(defaultUnitAmount))

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    @JsonProperty("default_unit_amount")
                    @ExcludeMissing
                    fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                        this.defaultUnitAmount = defaultUnitAmount
                    }

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(matrixValues: List<MatrixValue>) =
                        matrixValues(JsonField.of(matrixValues))

                    /** Matrix values for specified matrix grouping keys */
                    @JsonProperty("matrix_values")
                    @ExcludeMissing
                    fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                        this.matrixValues = matrixValues
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): MatrixConfig =
                        MatrixConfig(
                            dimensions.map { it.toUnmodifiable() },
                            defaultUnitAmount,
                            matrixValues.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = MatrixValue.Builder::class)
                @NoAutoDetect
                class MatrixValue
                private constructor(
                    private val unitAmount: JsonField<String>,
                    private val dimensionValues: JsonField<List<String?>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(): List<String?> =
                        dimensionValues.getRequired("dimension_values")

                    /** Unit price for the specified dimension_values */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    @JsonProperty("dimension_values")
                    @ExcludeMissing
                    fun _dimensionValues() = dimensionValues

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): MatrixValue = apply {
                        if (!validated) {
                            unitAmount()
                            dimensionValues()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MatrixValue &&
                            this.unitAmount == other.unitAmount &&
                            this.dimensionValues == other.dimensionValues &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    unitAmount,
                                    dimensionValues,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "MatrixValue{unitAmount=$unitAmount, dimensionValues=$dimensionValues, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var dimensionValues: JsonField<List<String?>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixValue: MatrixValue) = apply {
                            this.unitAmount = matrixValue.unitAmount
                            this.dimensionValues = matrixValue.dimensionValues
                            additionalProperties(matrixValue.additionalProperties)
                        }

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Unit price for the specified dimension_values */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(dimensionValues: List<String?>) =
                            dimensionValues(JsonField.of(dimensionValues))

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        @JsonProperty("dimension_values")
                        @ExcludeMissing
                        fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                            this.dimensionValues = dimensionValues
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): MatrixValue =
                            MatrixValue(
                                unitAmount,
                                dimensionValues.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val MATRIX = ModelType(JsonField.of("matrix"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX,
                }

                enum class Value {
                    MATRIX,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX -> Value.MATRIX
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX -> Known.MATRIX
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideTieredPrice.Builder::class)
        @NoAutoDetect
        class OverrideTieredPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val tieredConfig: JsonField<TieredConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("tiered_config") @ExcludeMissing fun _tieredConfig() = tieredConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideTieredPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    tieredConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideTieredPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.tieredConfig == other.tieredConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            tieredConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideTieredPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, tieredConfig=$tieredConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var tieredConfig: JsonField<TieredConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideTieredPrice: OverrideTieredPrice) = apply {
                    this.id = overrideTieredPrice.id
                    this.modelType = overrideTieredPrice.modelType
                    this.minimumAmount = overrideTieredPrice.minimumAmount
                    this.maximumAmount = overrideTieredPrice.maximumAmount
                    this.currency = overrideTieredPrice.currency
                    this.conversionRate = overrideTieredPrice.conversionRate
                    this.discount = overrideTieredPrice.discount
                    this.fixedPriceQuantity = overrideTieredPrice.fixedPriceQuantity
                    this.tieredConfig = overrideTieredPrice.tieredConfig
                    additionalProperties(overrideTieredPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun tieredConfig(tieredConfig: TieredConfig) =
                    tieredConfig(JsonField.of(tieredConfig))

                @JsonProperty("tiered_config")
                @ExcludeMissing
                fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                    this.tieredConfig = tieredConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideTieredPrice =
                    OverrideTieredPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        tieredConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED = ModelType(JsonField.of("tiered"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED,
                }

                enum class Value {
                    TIERED,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED -> Value.TIERED
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED -> Known.TIERED
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredConfig.Builder::class)
            @NoAutoDetect
            class TieredConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Tiers for rating based on total usage quantities into the specified tier */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredConfig: TieredConfig) = apply {
                        this.tiers = tieredConfig.tiers
                        additionalProperties(tieredConfig.additionalProperties)
                    }

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredConfig =
                        TieredConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val firstUnit: JsonField<Double>,
                    private val lastUnit: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Inclusive tier starting value */
                    fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(): Optional<Double> =
                        Optional.ofNullable(lastUnit.getNullable("last_unit"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Inclusive tier starting value */
                    @JsonProperty("first_unit") @ExcludeMissing fun _firstUnit() = firstUnit

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    @JsonProperty("last_unit") @ExcludeMissing fun _lastUnit() = lastUnit

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            firstUnit()
                            lastUnit()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.firstUnit == other.firstUnit &&
                            this.lastUnit == other.lastUnit &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    firstUnit,
                                    lastUnit,
                                    unitAmount,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{firstUnit=$firstUnit, lastUnit=$lastUnit, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var firstUnit: JsonField<Double> = JsonMissing.of()
                        private var lastUnit: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.firstUnit = tier.firstUnit
                            this.lastUnit = tier.lastUnit
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                        /** Inclusive tier starting value */
                        @JsonProperty("first_unit")
                        @ExcludeMissing
                        fun firstUnit(firstUnit: JsonField<Double>) = apply {
                            this.firstUnit = firstUnit
                        }

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(lastUnit: Double) = lastUnit(JsonField.of(lastUnit))

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @JsonProperty("last_unit")
                        @ExcludeMissing
                        fun lastUnit(lastUnit: JsonField<Double>) = apply {
                            this.lastUnit = lastUnit
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                firstUnit,
                                lastUnit,
                                unitAmount,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideTieredBpsPrice.Builder::class)
        @NoAutoDetect
        class OverrideTieredBpsPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val tieredBpsConfig: JsonField<TieredBpsConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun tieredBpsConfig(): TieredBpsConfig =
                tieredBpsConfig.getRequired("tiered_bps_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("tiered_bps_config")
            @ExcludeMissing
            fun _tieredBpsConfig() = tieredBpsConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideTieredBpsPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    tieredBpsConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideTieredBpsPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.tieredBpsConfig == other.tieredBpsConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            tieredBpsConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideTieredBpsPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, tieredBpsConfig=$tieredBpsConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideTieredBpsPrice: OverrideTieredBpsPrice) = apply {
                    this.id = overrideTieredBpsPrice.id
                    this.modelType = overrideTieredBpsPrice.modelType
                    this.minimumAmount = overrideTieredBpsPrice.minimumAmount
                    this.maximumAmount = overrideTieredBpsPrice.maximumAmount
                    this.currency = overrideTieredBpsPrice.currency
                    this.conversionRate = overrideTieredBpsPrice.conversionRate
                    this.discount = overrideTieredBpsPrice.discount
                    this.fixedPriceQuantity = overrideTieredBpsPrice.fixedPriceQuantity
                    this.tieredBpsConfig = overrideTieredBpsPrice.tieredBpsConfig
                    additionalProperties(overrideTieredBpsPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                    tieredBpsConfig(JsonField.of(tieredBpsConfig))

                @JsonProperty("tiered_bps_config")
                @ExcludeMissing
                fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                    this.tieredBpsConfig = tieredBpsConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideTieredBpsPrice =
                    OverrideTieredBpsPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        tieredBpsConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_BPS = ModelType(JsonField.of("tiered_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_BPS,
                }

                enum class Value {
                    TIERED_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_BPS -> Value.TIERED_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_BPS -> Known.TIERED_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredBpsConfig.Builder::class)
            @NoAutoDetect
            class TieredBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredBpsConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                        this.tiers = tieredBpsConfig.tiers
                        additionalProperties(tieredBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredBpsConfig =
                        TieredBpsConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val minimumAmount: JsonField<String>,
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Inclusive tier starting value */
                    fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                    /** Exclusive tier ending value */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Per-event basis point rate */
                    fun bps(): Double = bps.getRequired("bps")

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Inclusive tier starting value */
                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    fun _minimumAmount() = minimumAmount

                    /** Exclusive tier ending value */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Per-event basis point rate */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** Per unit maximum to charge */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            minimumAmount()
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.minimumAmount == other.minimumAmount &&
                            this.maximumAmount == other.maximumAmount &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    minimumAmount,
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var minimumAmount: JsonField<String> = JsonMissing.of()
                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.minimumAmount = tier.minimumAmount
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun minimumAmount(minimumAmount: String) =
                            minimumAmount(JsonField.of(minimumAmount))

                        /** Inclusive tier starting value */
                        @JsonProperty("minimum_amount")
                        @ExcludeMissing
                        fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                            this.minimumAmount = minimumAmount
                        }

                        /** Exclusive tier ending value */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Exclusive tier ending value */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Per-event basis point rate */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Per-event basis point rate */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** Per unit maximum to charge */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                minimumAmount,
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideBpsPrice.Builder::class)
        @NoAutoDetect
        class OverrideBpsPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val bpsConfig: JsonField<BpsConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("bps_config") @ExcludeMissing fun _bpsConfig() = bpsConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideBpsPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    bpsConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideBpsPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.bpsConfig == other.bpsConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            bpsConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideBpsPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, bpsConfig=$bpsConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var bpsConfig: JsonField<BpsConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideBpsPrice: OverrideBpsPrice) = apply {
                    this.id = overrideBpsPrice.id
                    this.modelType = overrideBpsPrice.modelType
                    this.minimumAmount = overrideBpsPrice.minimumAmount
                    this.maximumAmount = overrideBpsPrice.maximumAmount
                    this.currency = overrideBpsPrice.currency
                    this.conversionRate = overrideBpsPrice.conversionRate
                    this.discount = overrideBpsPrice.discount
                    this.fixedPriceQuantity = overrideBpsPrice.fixedPriceQuantity
                    this.bpsConfig = overrideBpsPrice.bpsConfig
                    additionalProperties(overrideBpsPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

                @JsonProperty("bps_config")
                @ExcludeMissing
                fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply {
                    this.bpsConfig = bpsConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideBpsPrice =
                    OverrideBpsPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        bpsConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BpsConfig.Builder::class)
            @NoAutoDetect
            class BpsConfig
            private constructor(
                private val bps: JsonField<Double>,
                private val perUnitMaximum: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Basis point take rate per event */
                fun bps(): Double = bps.getRequired("bps")

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /** Basis point take rate per event */
                @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                /** Optional currency amount maximum to cap spend per event */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum() = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BpsConfig = apply {
                    if (!validated) {
                        bps()
                        perUnitMaximum()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BpsConfig &&
                        this.bps == other.bps &&
                        this.perUnitMaximum == other.perUnitMaximum &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                bps,
                                perUnitMaximum,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: JsonField<Double> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bpsConfig: BpsConfig) = apply {
                        this.bps = bpsConfig.bps
                        this.perUnitMaximum = bpsConfig.perUnitMaximum
                        additionalProperties(bpsConfig.additionalProperties)
                    }

                    /** Basis point take rate per event */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /** Basis point take rate per event */
                    @JsonProperty("bps")
                    @ExcludeMissing
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(perUnitMaximum: String) =
                        perUnitMaximum(JsonField.of(perUnitMaximum))

                    /** Optional currency amount maximum to cap spend per event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BpsConfig =
                        BpsConfig(
                            bps,
                            perUnitMaximum,
                            additionalProperties.toUnmodifiable(),
                        )
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BPS = ModelType(JsonField.of("bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BPS,
                }

                enum class Value {
                    BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BPS -> Value.BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BPS -> Known.BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideBulkBpsPrice.Builder::class)
        @NoAutoDetect
        class OverrideBulkBpsPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val bulkBpsConfig: JsonField<BulkBpsConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("bulk_bps_config") @ExcludeMissing fun _bulkBpsConfig() = bulkBpsConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideBulkBpsPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    bulkBpsConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideBulkBpsPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.bulkBpsConfig == other.bulkBpsConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            bulkBpsConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideBulkBpsPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, bulkBpsConfig=$bulkBpsConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideBulkBpsPrice: OverrideBulkBpsPrice) = apply {
                    this.id = overrideBulkBpsPrice.id
                    this.modelType = overrideBulkBpsPrice.modelType
                    this.minimumAmount = overrideBulkBpsPrice.minimumAmount
                    this.maximumAmount = overrideBulkBpsPrice.maximumAmount
                    this.currency = overrideBulkBpsPrice.currency
                    this.conversionRate = overrideBulkBpsPrice.conversionRate
                    this.discount = overrideBulkBpsPrice.discount
                    this.fixedPriceQuantity = overrideBulkBpsPrice.fixedPriceQuantity
                    this.bulkBpsConfig = overrideBulkBpsPrice.bulkBpsConfig
                    additionalProperties(overrideBulkBpsPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                    bulkBpsConfig(JsonField.of(bulkBpsConfig))

                @JsonProperty("bulk_bps_config")
                @ExcludeMissing
                fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                    this.bulkBpsConfig = bulkBpsConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideBulkBpsPrice =
                    OverrideBulkBpsPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        bulkBpsConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BulkBpsConfig.Builder::class)
            @NoAutoDetect
            class BulkBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BulkBpsConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                        this.tiers = bulkBpsConfig.tiers
                        additionalProperties(bulkBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkBpsConfig =
                        BulkBpsConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Upper bound for tier */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Basis points to rate on */
                    fun bps(): Double = bps.getRequired("bps")

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Upper bound for tier */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Basis points to rate on */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** The maximum amount to charge for any one event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.maximumAmount == other.maximumAmount &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for tier */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Upper bound for tier */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Basis points to rate on */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Basis points to rate on */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** The maximum amount to charge for any one event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK_BPS = ModelType(JsonField.of("bulk_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_BPS,
                }

                enum class Value {
                    BULK_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_BPS -> Value.BULK_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_BPS -> Known.BULK_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideBulkPrice.Builder::class)
        @NoAutoDetect
        class OverrideBulkPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val bulkConfig: JsonField<BulkConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("bulk_config") @ExcludeMissing fun _bulkConfig() = bulkConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideBulkPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    bulkConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideBulkPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.bulkConfig == other.bulkConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            bulkConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideBulkPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, bulkConfig=$bulkConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var bulkConfig: JsonField<BulkConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideBulkPrice: OverrideBulkPrice) = apply {
                    this.id = overrideBulkPrice.id
                    this.modelType = overrideBulkPrice.modelType
                    this.minimumAmount = overrideBulkPrice.minimumAmount
                    this.maximumAmount = overrideBulkPrice.maximumAmount
                    this.currency = overrideBulkPrice.currency
                    this.conversionRate = overrideBulkPrice.conversionRate
                    this.discount = overrideBulkPrice.discount
                    this.fixedPriceQuantity = overrideBulkPrice.fixedPriceQuantity
                    this.bulkConfig = overrideBulkPrice.bulkConfig
                    additionalProperties(overrideBulkPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

                @JsonProperty("bulk_config")
                @ExcludeMissing
                fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                    this.bulkConfig = bulkConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideBulkPrice =
                    OverrideBulkPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        bulkConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BulkConfig.Builder::class)
            @NoAutoDetect
            class BulkConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Bulk tiers for rating based on total usage volume */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BulkConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkConfig: BulkConfig) = apply {
                        this.tiers = bulkConfig.tiers
                        additionalProperties(bulkConfig.additionalProperties)
                    }

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Bulk tiers for rating based on total usage volume */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkConfig =
                        BulkConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumUnits: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Upper bound for this tier */
                    fun maximumUnits(): Optional<Double> =
                        Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Upper bound for this tier */
                    @JsonProperty("maximum_units")
                    @ExcludeMissing
                    fun _maximumUnits() = maximumUnits

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumUnits()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.maximumUnits == other.maximumUnits &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    maximumUnits,
                                    unitAmount,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumUnits=$maximumUnits, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumUnits: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumUnits = tier.maximumUnits
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for this tier */
                        fun maximumUnits(maximumUnits: Double) =
                            maximumUnits(JsonField.of(maximumUnits))

                        /** Upper bound for this tier */
                        @JsonProperty("maximum_units")
                        @ExcludeMissing
                        fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                            this.maximumUnits = maximumUnits
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumUnits,
                                unitAmount,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK = ModelType(JsonField.of("bulk"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK,
                }

                enum class Value {
                    BULK,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK -> Value.BULK
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK -> Known.BULK
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideThresholdTotalAmountPrice.Builder::class)
        @NoAutoDetect
        class OverrideThresholdTotalAmountPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("threshold_total_amount_config")
            @ExcludeMissing
            fun _thresholdTotalAmountConfig() = thresholdTotalAmountConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideThresholdTotalAmountPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    thresholdTotalAmountConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideThresholdTotalAmountPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.thresholdTotalAmountConfig == other.thresholdTotalAmountConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            thresholdTotalAmountConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideThresholdTotalAmountPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    overrideThresholdTotalAmountPrice: OverrideThresholdTotalAmountPrice
                ) = apply {
                    this.id = overrideThresholdTotalAmountPrice.id
                    this.modelType = overrideThresholdTotalAmountPrice.modelType
                    this.minimumAmount = overrideThresholdTotalAmountPrice.minimumAmount
                    this.maximumAmount = overrideThresholdTotalAmountPrice.maximumAmount
                    this.currency = overrideThresholdTotalAmountPrice.currency
                    this.conversionRate = overrideThresholdTotalAmountPrice.conversionRate
                    this.discount = overrideThresholdTotalAmountPrice.discount
                    this.fixedPriceQuantity = overrideThresholdTotalAmountPrice.fixedPriceQuantity
                    this.thresholdTotalAmountConfig =
                        overrideThresholdTotalAmountPrice.thresholdTotalAmountConfig
                    additionalProperties(overrideThresholdTotalAmountPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

                @JsonProperty("threshold_total_amount_config")
                @ExcludeMissing
                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
                ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideThresholdTotalAmountPrice =
                    OverrideThresholdTotalAmountPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        thresholdTotalAmountConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val THRESHOLD_TOTAL_AMOUNT = ModelType(JsonField.of("threshold_total_amount"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    THRESHOLD_TOTAL_AMOUNT,
                }

                enum class Value {
                    THRESHOLD_TOTAL_AMOUNT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = ThresholdTotalAmountConfig.Builder::class)
            @NoAutoDetect
            class ThresholdTotalAmountConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): ThresholdTotalAmountConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ThresholdTotalAmountConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                        apply {
                            additionalProperties(thresholdTotalAmountConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): ThresholdTotalAmountConfig =
                        ThresholdTotalAmountConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideTieredPackagePrice.Builder::class)
        @NoAutoDetect
        class OverrideTieredPackagePrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val tieredPackageConfig: JsonField<TieredPackageConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun tieredPackageConfig(): TieredPackageConfig =
                tieredPackageConfig.getRequired("tiered_package_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("tiered_package_config")
            @ExcludeMissing
            fun _tieredPackageConfig() = tieredPackageConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideTieredPackagePrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    tieredPackageConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideTieredPackagePrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.tieredPackageConfig == other.tieredPackageConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            tieredPackageConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideTieredPackagePrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, tieredPackageConfig=$tieredPackageConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideTieredPackagePrice: OverrideTieredPackagePrice) = apply {
                    this.id = overrideTieredPackagePrice.id
                    this.modelType = overrideTieredPackagePrice.modelType
                    this.minimumAmount = overrideTieredPackagePrice.minimumAmount
                    this.maximumAmount = overrideTieredPackagePrice.maximumAmount
                    this.currency = overrideTieredPackagePrice.currency
                    this.conversionRate = overrideTieredPackagePrice.conversionRate
                    this.discount = overrideTieredPackagePrice.discount
                    this.fixedPriceQuantity = overrideTieredPackagePrice.fixedPriceQuantity
                    this.tieredPackageConfig = overrideTieredPackagePrice.tieredPackageConfig
                    additionalProperties(overrideTieredPackagePrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                    tieredPackageConfig(JsonField.of(tieredPackageConfig))

                @JsonProperty("tiered_package_config")
                @ExcludeMissing
                fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) =
                    apply {
                        this.tieredPackageConfig = tieredPackageConfig
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideTieredPackagePrice =
                    OverrideTieredPackagePrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        tieredPackageConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_PACKAGE = ModelType(JsonField.of("tiered_package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_PACKAGE,
                }

                enum class Value {
                    TIERED_PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_PACKAGE -> Value.TIERED_PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_PACKAGE -> Known.TIERED_PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredPackageConfig.Builder::class)
            @NoAutoDetect
            class TieredPackageConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredPackageConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredPackageConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredPackageConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                        additionalProperties(tieredPackageConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredPackageConfig =
                        TieredPackageConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideTieredWithMinimumPrice.Builder::class)
        @NoAutoDetect
        class OverrideTieredWithMinimumPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
                tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("tiered_with_minimum_config")
            @ExcludeMissing
            fun _tieredWithMinimumConfig() = tieredWithMinimumConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideTieredWithMinimumPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    tieredWithMinimumConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideTieredWithMinimumPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.tieredWithMinimumConfig == other.tieredWithMinimumConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            tieredWithMinimumConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideTieredWithMinimumPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, tieredWithMinimumConfig=$tieredWithMinimumConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideTieredWithMinimumPrice: OverrideTieredWithMinimumPrice) =
                    apply {
                        this.id = overrideTieredWithMinimumPrice.id
                        this.modelType = overrideTieredWithMinimumPrice.modelType
                        this.minimumAmount = overrideTieredWithMinimumPrice.minimumAmount
                        this.maximumAmount = overrideTieredWithMinimumPrice.maximumAmount
                        this.currency = overrideTieredWithMinimumPrice.currency
                        this.conversionRate = overrideTieredWithMinimumPrice.conversionRate
                        this.discount = overrideTieredWithMinimumPrice.discount
                        this.fixedPriceQuantity = overrideTieredWithMinimumPrice.fixedPriceQuantity
                        this.tieredWithMinimumConfig =
                            overrideTieredWithMinimumPrice.tieredWithMinimumConfig
                        additionalProperties(overrideTieredWithMinimumPrice.additionalProperties)
                    }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                    tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

                @JsonProperty("tiered_with_minimum_config")
                @ExcludeMissing
                fun tieredWithMinimumConfig(
                    tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
                ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideTieredWithMinimumPrice =
                    OverrideTieredWithMinimumPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        tieredWithMinimumConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_MINIMUM = ModelType(JsonField.of("tiered_with_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_MINIMUM,
                }

                enum class Value {
                    TIERED_WITH_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithMinimumConfig.Builder::class)
            @NoAutoDetect
            class TieredWithMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredWithMinimumConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                        additionalProperties(tieredWithMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithMinimumConfig =
                        TieredWithMinimumConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverridePackageWithAllocationPrice.Builder::class)
        @NoAutoDetect
        class OverridePackageWithAllocationPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                packageWithAllocationConfig.getRequired("package_with_allocation_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("package_with_allocation_config")
            @ExcludeMissing
            fun _packageWithAllocationConfig() = packageWithAllocationConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverridePackageWithAllocationPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    packageWithAllocationConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverridePackageWithAllocationPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.packageWithAllocationConfig == other.packageWithAllocationConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            packageWithAllocationConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverridePackageWithAllocationPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, packageWithAllocationConfig=$packageWithAllocationConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    overridePackageWithAllocationPrice: OverridePackageWithAllocationPrice
                ) = apply {
                    this.id = overridePackageWithAllocationPrice.id
                    this.modelType = overridePackageWithAllocationPrice.modelType
                    this.minimumAmount = overridePackageWithAllocationPrice.minimumAmount
                    this.maximumAmount = overridePackageWithAllocationPrice.maximumAmount
                    this.currency = overridePackageWithAllocationPrice.currency
                    this.conversionRate = overridePackageWithAllocationPrice.conversionRate
                    this.discount = overridePackageWithAllocationPrice.discount
                    this.fixedPriceQuantity = overridePackageWithAllocationPrice.fixedPriceQuantity
                    this.packageWithAllocationConfig =
                        overridePackageWithAllocationPrice.packageWithAllocationConfig
                    additionalProperties(overridePackageWithAllocationPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: PackageWithAllocationConfig
                ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

                @JsonProperty("package_with_allocation_config")
                @ExcludeMissing
                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
                ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverridePackageWithAllocationPrice =
                    OverridePackageWithAllocationPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        packageWithAllocationConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val PACKAGE_WITH_ALLOCATION = ModelType(JsonField.of("package_with_allocation"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE_WITH_ALLOCATION,
                }

                enum class Value {
                    PACKAGE_WITH_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageWithAllocationConfig.Builder::class)
            @NoAutoDetect
            class PackageWithAllocationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageWithAllocationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PackageWithAllocationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                        apply {
                            additionalProperties(packageWithAllocationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageWithAllocationConfig =
                        PackageWithAllocationConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideUnitWithPercentPrice.Builder::class)
        @NoAutoDetect
        class OverrideUnitWithPercentPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun unitWithPercentConfig(): UnitWithPercentConfig =
                unitWithPercentConfig.getRequired("unit_with_percent_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("unit_with_percent_config")
            @ExcludeMissing
            fun _unitWithPercentConfig() = unitWithPercentConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideUnitWithPercentPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    unitWithPercentConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideUnitWithPercentPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.unitWithPercentConfig == other.unitWithPercentConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            unitWithPercentConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideUnitWithPercentPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, unitWithPercentConfig=$unitWithPercentConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var unitWithPercentConfig: JsonField<UnitWithPercentConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideUnitWithPercentPrice: OverrideUnitWithPercentPrice) =
                    apply {
                        this.id = overrideUnitWithPercentPrice.id
                        this.modelType = overrideUnitWithPercentPrice.modelType
                        this.minimumAmount = overrideUnitWithPercentPrice.minimumAmount
                        this.maximumAmount = overrideUnitWithPercentPrice.maximumAmount
                        this.currency = overrideUnitWithPercentPrice.currency
                        this.conversionRate = overrideUnitWithPercentPrice.conversionRate
                        this.discount = overrideUnitWithPercentPrice.discount
                        this.fixedPriceQuantity = overrideUnitWithPercentPrice.fixedPriceQuantity
                        this.unitWithPercentConfig =
                            overrideUnitWithPercentPrice.unitWithPercentConfig
                        additionalProperties(overrideUnitWithPercentPrice.additionalProperties)
                    }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                    unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

                @JsonProperty("unit_with_percent_config")
                @ExcludeMissing
                fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                    apply {
                        this.unitWithPercentConfig = unitWithPercentConfig
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideUnitWithPercentPrice =
                    OverrideUnitWithPercentPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        unitWithPercentConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT_WITH_PERCENT = ModelType(JsonField.of("unit_with_percent"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PERCENT,
                }

                enum class Value {
                    UNIT_WITH_PERCENT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithPercentConfig.Builder::class)
            @NoAutoDetect
            class UnitWithPercentConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithPercentConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitWithPercentConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithPercentConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                        additionalProperties(unitWithPercentConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithPercentConfig =
                        UnitWithPercentConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideGroupedAllocationPrice.Builder::class)
        @NoAutoDetect
        class OverrideGroupedAllocationPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun groupedAllocationConfig(): GroupedAllocationConfig =
                groupedAllocationConfig.getRequired("grouped_allocation_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("grouped_allocation_config")
            @ExcludeMissing
            fun _groupedAllocationConfig() = groupedAllocationConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideGroupedAllocationPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    groupedAllocationConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideGroupedAllocationPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.groupedAllocationConfig == other.groupedAllocationConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            groupedAllocationConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideGroupedAllocationPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var groupedAllocationConfig: JsonField<GroupedAllocationConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideGroupedAllocationPrice: OverrideGroupedAllocationPrice) =
                    apply {
                        this.id = overrideGroupedAllocationPrice.id
                        this.modelType = overrideGroupedAllocationPrice.modelType
                        this.minimumAmount = overrideGroupedAllocationPrice.minimumAmount
                        this.maximumAmount = overrideGroupedAllocationPrice.maximumAmount
                        this.currency = overrideGroupedAllocationPrice.currency
                        this.conversionRate = overrideGroupedAllocationPrice.conversionRate
                        this.discount = overrideGroupedAllocationPrice.discount
                        this.fixedPriceQuantity = overrideGroupedAllocationPrice.fixedPriceQuantity
                        this.groupedAllocationConfig =
                            overrideGroupedAllocationPrice.groupedAllocationConfig
                        additionalProperties(overrideGroupedAllocationPrice.additionalProperties)
                    }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                    groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

                @JsonProperty("grouped_allocation_config")
                @ExcludeMissing
                fun groupedAllocationConfig(
                    groupedAllocationConfig: JsonField<GroupedAllocationConfig>
                ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideGroupedAllocationPrice =
                    OverrideGroupedAllocationPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        groupedAllocationConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = GroupedAllocationConfig.Builder::class)
            @NoAutoDetect
            class GroupedAllocationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedAllocationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is GroupedAllocationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedAllocationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                        additionalProperties(groupedAllocationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedAllocationConfig =
                        GroupedAllocationConfig(additionalProperties.toUnmodifiable())
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val GROUPED_ALLOCATION = ModelType(JsonField.of("grouped_allocation"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_ALLOCATION,
                }

                enum class Value {
                    GROUPED_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideGroupedWithProratedMinimumPrice.Builder::class)
        @NoAutoDetect
        class OverrideGroupedWithProratedMinimumPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
                groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("grouped_with_prorated_minimum_config")
            @ExcludeMissing
            fun _groupedWithProratedMinimumConfig() = groupedWithProratedMinimumConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideGroupedWithProratedMinimumPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    groupedWithProratedMinimumConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideGroupedWithProratedMinimumPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.groupedWithProratedMinimumConfig ==
                        other.groupedWithProratedMinimumConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            groupedWithProratedMinimumConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideGroupedWithProratedMinimumPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var groupedWithProratedMinimumConfig:
                    JsonField<GroupedWithProratedMinimumConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    overrideGroupedWithProratedMinimumPrice: OverrideGroupedWithProratedMinimumPrice
                ) = apply {
                    this.id = overrideGroupedWithProratedMinimumPrice.id
                    this.modelType = overrideGroupedWithProratedMinimumPrice.modelType
                    this.minimumAmount = overrideGroupedWithProratedMinimumPrice.minimumAmount
                    this.maximumAmount = overrideGroupedWithProratedMinimumPrice.maximumAmount
                    this.currency = overrideGroupedWithProratedMinimumPrice.currency
                    this.conversionRate = overrideGroupedWithProratedMinimumPrice.conversionRate
                    this.discount = overrideGroupedWithProratedMinimumPrice.discount
                    this.fixedPriceQuantity =
                        overrideGroupedWithProratedMinimumPrice.fixedPriceQuantity
                    this.groupedWithProratedMinimumConfig =
                        overrideGroupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    additionalProperties(
                        overrideGroupedWithProratedMinimumPrice.additionalProperties
                    )
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun groupedWithProratedMinimumConfig(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

                @JsonProperty("grouped_with_prorated_minimum_config")
                @ExcludeMissing
                fun groupedWithProratedMinimumConfig(
                    groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
                ) = apply {
                    this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideGroupedWithProratedMinimumPrice =
                    OverrideGroupedWithProratedMinimumPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        groupedWithProratedMinimumConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = GroupedWithProratedMinimumConfig.Builder::class)
            @NoAutoDetect
            class GroupedWithProratedMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedWithProratedMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is GroupedWithProratedMinimumConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                    ) = apply {
                        additionalProperties(groupedWithProratedMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedWithProratedMinimumConfig =
                        GroupedWithProratedMinimumConfig(additionalProperties.toUnmodifiable())
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val GROUPED_WITH_PRORATED_MINIMUM =
                        ModelType(JsonField.of("grouped_with_prorated_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_PRORATED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_PRORATED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideGroupedWithMeteredMinimumPrice.Builder::class)
        @NoAutoDetect
        class OverrideGroupedWithMeteredMinimumPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
                groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("grouped_with_metered_minimum_config")
            @ExcludeMissing
            fun _groupedWithMeteredMinimumConfig() = groupedWithMeteredMinimumConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideGroupedWithMeteredMinimumPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    groupedWithMeteredMinimumConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideGroupedWithMeteredMinimumPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            groupedWithMeteredMinimumConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideGroupedWithMeteredMinimumPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var groupedWithMeteredMinimumConfig:
                    JsonField<GroupedWithMeteredMinimumConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    overrideGroupedWithMeteredMinimumPrice: OverrideGroupedWithMeteredMinimumPrice
                ) = apply {
                    this.id = overrideGroupedWithMeteredMinimumPrice.id
                    this.modelType = overrideGroupedWithMeteredMinimumPrice.modelType
                    this.minimumAmount = overrideGroupedWithMeteredMinimumPrice.minimumAmount
                    this.maximumAmount = overrideGroupedWithMeteredMinimumPrice.maximumAmount
                    this.currency = overrideGroupedWithMeteredMinimumPrice.currency
                    this.conversionRate = overrideGroupedWithMeteredMinimumPrice.conversionRate
                    this.discount = overrideGroupedWithMeteredMinimumPrice.discount
                    this.fixedPriceQuantity =
                        overrideGroupedWithMeteredMinimumPrice.fixedPriceQuantity
                    this.groupedWithMeteredMinimumConfig =
                        overrideGroupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    additionalProperties(
                        overrideGroupedWithMeteredMinimumPrice.additionalProperties
                    )
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun groupedWithMeteredMinimumConfig(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

                @JsonProperty("grouped_with_metered_minimum_config")
                @ExcludeMissing
                fun groupedWithMeteredMinimumConfig(
                    groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
                ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideGroupedWithMeteredMinimumPrice =
                    OverrideGroupedWithMeteredMinimumPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        groupedWithMeteredMinimumConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = GroupedWithMeteredMinimumConfig.Builder::class)
            @NoAutoDetect
            class GroupedWithMeteredMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedWithMeteredMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is GroupedWithMeteredMinimumConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                    ) = apply {
                        additionalProperties(groupedWithMeteredMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedWithMeteredMinimumConfig =
                        GroupedWithMeteredMinimumConfig(additionalProperties.toUnmodifiable())
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val GROUPED_WITH_METERED_MINIMUM =
                        ModelType(JsonField.of("grouped_with_metered_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_METERED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_METERED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideBulkWithProrationPrice.Builder::class)
        @NoAutoDetect
        class OverrideBulkWithProrationPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun bulkWithProrationConfig(): BulkWithProrationConfig =
                bulkWithProrationConfig.getRequired("bulk_with_proration_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("bulk_with_proration_config")
            @ExcludeMissing
            fun _bulkWithProrationConfig() = bulkWithProrationConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideBulkWithProrationPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    bulkWithProrationConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideBulkWithProrationPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.bulkWithProrationConfig == other.bulkWithProrationConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            bulkWithProrationConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideBulkWithProrationPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, bulkWithProrationConfig=$bulkWithProrationConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideBulkWithProrationPrice: OverrideBulkWithProrationPrice) =
                    apply {
                        this.id = overrideBulkWithProrationPrice.id
                        this.modelType = overrideBulkWithProrationPrice.modelType
                        this.minimumAmount = overrideBulkWithProrationPrice.minimumAmount
                        this.maximumAmount = overrideBulkWithProrationPrice.maximumAmount
                        this.currency = overrideBulkWithProrationPrice.currency
                        this.conversionRate = overrideBulkWithProrationPrice.conversionRate
                        this.discount = overrideBulkWithProrationPrice.discount
                        this.fixedPriceQuantity = overrideBulkWithProrationPrice.fixedPriceQuantity
                        this.bulkWithProrationConfig =
                            overrideBulkWithProrationPrice.bulkWithProrationConfig
                        additionalProperties(overrideBulkWithProrationPrice.additionalProperties)
                    }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                    bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

                @JsonProperty("bulk_with_proration_config")
                @ExcludeMissing
                fun bulkWithProrationConfig(
                    bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
                ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideBulkWithProrationPrice =
                    OverrideBulkWithProrationPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        bulkWithProrationConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BulkWithProrationConfig.Builder::class)
            @NoAutoDetect
            class BulkWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BulkWithProrationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkWithProrationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                        additionalProperties(bulkWithProrationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkWithProrationConfig =
                        BulkWithProrationConfig(additionalProperties.toUnmodifiable())
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val BULK_WITH_PRORATION = ModelType(JsonField.of("bulk_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_WITH_PRORATION,
                }

                enum class Value {
                    BULK_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideUnitWithProrationPrice.Builder::class)
        @NoAutoDetect
        class OverrideUnitWithProrationPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun unitWithProrationConfig(): UnitWithProrationConfig =
                unitWithProrationConfig.getRequired("unit_with_proration_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("unit_with_proration_config")
            @ExcludeMissing
            fun _unitWithProrationConfig() = unitWithProrationConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideUnitWithProrationPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    unitWithProrationConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideUnitWithProrationPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.unitWithProrationConfig == other.unitWithProrationConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            unitWithProrationConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideUnitWithProrationPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, unitWithProrationConfig=$unitWithProrationConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var unitWithProrationConfig: JsonField<UnitWithProrationConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(overrideUnitWithProrationPrice: OverrideUnitWithProrationPrice) =
                    apply {
                        this.id = overrideUnitWithProrationPrice.id
                        this.modelType = overrideUnitWithProrationPrice.modelType
                        this.minimumAmount = overrideUnitWithProrationPrice.minimumAmount
                        this.maximumAmount = overrideUnitWithProrationPrice.maximumAmount
                        this.currency = overrideUnitWithProrationPrice.currency
                        this.conversionRate = overrideUnitWithProrationPrice.conversionRate
                        this.discount = overrideUnitWithProrationPrice.discount
                        this.fixedPriceQuantity = overrideUnitWithProrationPrice.fixedPriceQuantity
                        this.unitWithProrationConfig =
                            overrideUnitWithProrationPrice.unitWithProrationConfig
                        additionalProperties(overrideUnitWithProrationPrice.additionalProperties)
                    }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                    unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

                @JsonProperty("unit_with_proration_config")
                @ExcludeMissing
                fun unitWithProrationConfig(
                    unitWithProrationConfig: JsonField<UnitWithProrationConfig>
                ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideUnitWithProrationPrice =
                    OverrideUnitWithProrationPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        unitWithProrationConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val UNIT_WITH_PRORATION = ModelType(JsonField.of("unit_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PRORATION,
                }

                enum class Value {
                    UNIT_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithProrationConfig.Builder::class)
            @NoAutoDetect
            class UnitWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitWithProrationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithProrationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                        additionalProperties(unitWithProrationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithProrationConfig =
                        UnitWithProrationConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }

        @JsonDeserialize(builder = OverrideTieredWithProrationPrice.Builder::class)
        @NoAutoDetect
        class OverrideTieredWithProrationPrice
        private constructor(
            private val id: JsonField<String>,
            private val modelType: JsonField<ModelType>,
            private val minimumAmount: JsonField<String>,
            private val maximumAmount: JsonField<String>,
            private val currency: JsonField<String>,
            private val conversionRate: JsonField<Double>,
            private val discount: JsonField<Discount>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            fun id(): String = id.getRequired("id")

            fun modelType(): ModelType = modelType.getRequired("model_type")

            /** The subscription's override minimum amount for the plan. */
            fun minimumAmount(): Optional<String> =
                Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

            /** The subscription's override maximum amount for the plan. */
            fun maximumAmount(): Optional<String> =
                Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            /** The subscription's override discount for the plan. */
            fun discount(): Optional<Discount> =
                Optional.ofNullable(discount.getNullable("discount"))

            /** The starting quantity of the price, if the price is a fixed price. */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            fun tieredWithProrationConfig(): TieredWithProrationConfig =
                tieredWithProrationConfig.getRequired("tiered_with_proration_config")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            /** The subscription's override minimum amount for the plan. */
            @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

            /** The subscription's override maximum amount for the plan. */
            @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

            /**
             * The currency of the price. If not provided, the currency of the plan will be used.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            /** The subscription's override discount for the plan. */
            @JsonProperty("discount") @ExcludeMissing fun _discount() = discount

            /** The starting quantity of the price, if the price is a fixed price. */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            @JsonProperty("tiered_with_proration_config")
            @ExcludeMissing
            fun _tieredWithProrationConfig() = tieredWithProrationConfig

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): OverrideTieredWithProrationPrice = apply {
                if (!validated) {
                    id()
                    modelType()
                    minimumAmount()
                    maximumAmount()
                    currency()
                    conversionRate()
                    discount().map { it.validate() }
                    fixedPriceQuantity()
                    tieredWithProrationConfig().validate()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is OverrideTieredWithProrationPrice &&
                    this.id == other.id &&
                    this.modelType == other.modelType &&
                    this.minimumAmount == other.minimumAmount &&
                    this.maximumAmount == other.maximumAmount &&
                    this.currency == other.currency &&
                    this.conversionRate == other.conversionRate &&
                    this.discount == other.discount &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.tieredWithProrationConfig == other.tieredWithProrationConfig &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            id,
                            modelType,
                            minimumAmount,
                            maximumAmount,
                            currency,
                            conversionRate,
                            discount,
                            fixedPriceQuantity,
                            tieredWithProrationConfig,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "OverrideTieredWithProrationPrice{id=$id, modelType=$modelType, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, currency=$currency, conversionRate=$conversionRate, discount=$discount, fixedPriceQuantity=$fixedPriceQuantity, tieredWithProrationConfig=$tieredWithProrationConfig, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var minimumAmount: JsonField<String> = JsonMissing.of()
                private var maximumAmount: JsonField<String> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var discount: JsonField<Discount> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
                    JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    overrideTieredWithProrationPrice: OverrideTieredWithProrationPrice
                ) = apply {
                    this.id = overrideTieredWithProrationPrice.id
                    this.modelType = overrideTieredWithProrationPrice.modelType
                    this.minimumAmount = overrideTieredWithProrationPrice.minimumAmount
                    this.maximumAmount = overrideTieredWithProrationPrice.maximumAmount
                    this.currency = overrideTieredWithProrationPrice.currency
                    this.conversionRate = overrideTieredWithProrationPrice.conversionRate
                    this.discount = overrideTieredWithProrationPrice.discount
                    this.fixedPriceQuantity = overrideTieredWithProrationPrice.fixedPriceQuantity
                    this.tieredWithProrationConfig =
                        overrideTieredWithProrationPrice.tieredWithProrationConfig
                    additionalProperties(overrideTieredWithProrationPrice.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                /** The subscription's override minimum amount for the plan. */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** The subscription's override minimum amount for the plan. */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** The subscription's override maximum amount for the plan. */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** The subscription's override maximum amount for the plan. */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * The currency of the price. If not provided, the currency of the plan will be
                 * used.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                /** The subscription's override discount for the plan. */
                fun discount(discount: Discount) = discount(JsonField.of(discount))

                /** The subscription's override discount for the plan. */
                @JsonProperty("discount")
                @ExcludeMissing
                fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

                /** The starting quantity of the price, if the price is a fixed price. */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /** The starting quantity of the price, if the price is a fixed price. */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: TieredWithProrationConfig
                ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

                @JsonProperty("tiered_with_proration_config")
                @ExcludeMissing
                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
                ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): OverrideTieredWithProrationPrice =
                    OverrideTieredWithProrationPrice(
                        id,
                        modelType,
                        minimumAmount,
                        maximumAmount,
                        currency,
                        conversionRate,
                        discount,
                        fixedPriceQuantity,
                        tieredWithProrationConfig,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_PRORATION = ModelType(JsonField.of("tiered_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_PRORATION,
                }

                enum class Value {
                    TIERED_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithProrationConfig.Builder::class)
            @NoAutoDetect
            class TieredWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredWithProrationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithProrationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                        apply {
                            additionalProperties(tieredWithProrationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithProrationConfig =
                        TieredWithProrationConfig(additionalProperties.toUnmodifiable())
                }
            }

            /** The subscription's override discount for the plan. */
            @JsonDeserialize(builder = Discount.Builder::class)
            @NoAutoDetect
            class Discount
            private constructor(
                private val discountType: JsonField<DiscountType>,
                private val percentageDiscount: JsonField<Double>,
                private val trialAmountDiscount: JsonField<String>,
                private val usageDiscount: JsonField<Double>,
                private val amountDiscount: JsonField<String>,
                private val appliesToPriceIds: JsonField<List<String>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                fun discountType(): DiscountType = discountType.getRequired("discount_type")

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                fun percentageDiscount(): Optional<Double> =
                    Optional.ofNullable(percentageDiscount.getNullable("percentage_discount"))

                /** Only available if discount_type is `trial` */
                fun trialAmountDiscount(): Optional<String> =
                    Optional.ofNullable(trialAmountDiscount.getNullable("trial_amount_discount"))

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                fun usageDiscount(): Optional<Double> =
                    Optional.ofNullable(usageDiscount.getNullable("usage_discount"))

                /** Only available if discount_type is `amount`. */
                fun amountDiscount(): Optional<String> =
                    Optional.ofNullable(amountDiscount.getNullable("amount_discount"))

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                fun appliesToPriceIds(): Optional<List<String>> =
                    Optional.ofNullable(appliesToPriceIds.getNullable("applies_to_price_ids"))

                @JsonProperty("discount_type") @ExcludeMissing fun _discountType() = discountType

                /**
                 * Only available if discount_type is `percentage`. This is a number between 0
                 * and 1.
                 */
                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                /** Only available if discount_type is `trial` */
                @JsonProperty("trial_amount_discount")
                @ExcludeMissing
                fun _trialAmountDiscount() = trialAmountDiscount

                /**
                 * Only available if discount_type is `usage`. Number of usage units that this
                 * discount is for
                 */
                @JsonProperty("usage_discount") @ExcludeMissing fun _usageDiscount() = usageDiscount

                /** Only available if discount_type is `amount`. */
                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                /**
                 * List of price_ids that this discount applies to. For plan/plan phase discounts,
                 * this can be a subset of prices.
                 */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Discount = apply {
                    if (!validated) {
                        discountType()
                        percentageDiscount()
                        trialAmountDiscount()
                        usageDiscount()
                        amountDiscount()
                        appliesToPriceIds()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Discount &&
                        this.discountType == other.discountType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.trialAmountDiscount == other.trialAmountDiscount &&
                        this.usageDiscount == other.usageDiscount &&
                        this.amountDiscount == other.amountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                discountType,
                                percentageDiscount,
                                trialAmountDiscount,
                                usageDiscount,
                                amountDiscount,
                                appliesToPriceIds,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "Discount{discountType=$discountType, percentageDiscount=$percentageDiscount, trialAmountDiscount=$trialAmountDiscount, usageDiscount=$usageDiscount, amountDiscount=$amountDiscount, appliesToPriceIds=$appliesToPriceIds, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var discountType: JsonField<DiscountType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var trialAmountDiscount: JsonField<String> = JsonMissing.of()
                    private var usageDiscount: JsonField<Double> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(discount: Discount) = apply {
                        this.discountType = discount.discountType
                        this.percentageDiscount = discount.percentageDiscount
                        this.trialAmountDiscount = discount.trialAmountDiscount
                        this.usageDiscount = discount.usageDiscount
                        this.amountDiscount = discount.amountDiscount
                        this.appliesToPriceIds = discount.appliesToPriceIds
                        additionalProperties(discount.additionalProperties)
                    }

                    fun discountType(discountType: DiscountType) =
                        discountType(JsonField.of(discountType))

                    @JsonProperty("discount_type")
                    @ExcludeMissing
                    fun discountType(discountType: JsonField<DiscountType>) = apply {
                        this.discountType = discountType
                    }

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    /**
                     * Only available if discount_type is `percentage`. This is a number between 0
                     * and 1.
                     */
                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    /** Only available if discount_type is `trial` */
                    fun trialAmountDiscount(trialAmountDiscount: String) =
                        trialAmountDiscount(JsonField.of(trialAmountDiscount))

                    /** Only available if discount_type is `trial` */
                    @JsonProperty("trial_amount_discount")
                    @ExcludeMissing
                    fun trialAmountDiscount(trialAmountDiscount: JsonField<String>) = apply {
                        this.trialAmountDiscount = trialAmountDiscount
                    }

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    fun usageDiscount(usageDiscount: Double) =
                        usageDiscount(JsonField.of(usageDiscount))

                    /**
                     * Only available if discount_type is `usage`. Number of usage units that this
                     * discount is for
                     */
                    @JsonProperty("usage_discount")
                    @ExcludeMissing
                    fun usageDiscount(usageDiscount: JsonField<Double>) = apply {
                        this.usageDiscount = usageDiscount
                    }

                    /** Only available if discount_type is `amount`. */
                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    /** Only available if discount_type is `amount`. */
                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /**
                     * List of price_ids that this discount applies to. For plan/plan phase
                     * discounts, this can be a subset of prices.
                     */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Discount =
                        Discount(
                            discountType,
                            percentageDiscount,
                            trialAmountDiscount,
                            usageDiscount,
                            amountDiscount,
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class DiscountType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DiscountType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PERCENTAGE = DiscountType(JsonField.of("percentage"))

                        @JvmField val TRIAL = DiscountType(JsonField.of("trial"))

                        @JvmField val USAGE = DiscountType(JsonField.of("usage"))

                        @JvmField val AMOUNT = DiscountType(JsonField.of("amount"))

                        @JvmStatic fun of(value: String) = DiscountType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                    }

                    enum class Value {
                        PERCENTAGE,
                        TRIAL,
                        USAGE,
                        AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE -> Value.PERCENTAGE
                            TRIAL -> Value.TRIAL
                            USAGE -> Value.USAGE
                            AMOUNT -> Value.AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE -> Known.PERCENTAGE
                            TRIAL -> Known.TRIAL
                            USAGE -> Known.USAGE
                            AMOUNT -> Known.AMOUNT
                            else -> throw OrbInvalidDataException("Unknown DiscountType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }
    }

    @JsonDeserialize(builder = RemoveAdjustment.Builder::class)
    @NoAutoDetect
    class RemoveAdjustment
    private constructor(
        private val adjustmentId: String?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The id of the adjustment to remove on the subscription. */
        @JsonProperty("adjustment_id") fun adjustmentId(): String? = adjustmentId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is RemoveAdjustment &&
                this.adjustmentId == other.adjustmentId &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode = Objects.hash(adjustmentId, additionalProperties)
            }
            return hashCode
        }

        override fun toString() =
            "RemoveAdjustment{adjustmentId=$adjustmentId, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var adjustmentId: String? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(removeAdjustment: RemoveAdjustment) = apply {
                this.adjustmentId = removeAdjustment.adjustmentId
                additionalProperties(removeAdjustment.additionalProperties)
            }

            /** The id of the adjustment to remove on the subscription. */
            @JsonProperty("adjustment_id")
            fun adjustmentId(adjustmentId: String) = apply { this.adjustmentId = adjustmentId }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): RemoveAdjustment =
                RemoveAdjustment(
                    checkNotNull(adjustmentId) { "`adjustmentId` is required but was not set" },
                    additionalProperties.toUnmodifiable()
                )
        }
    }

    @JsonDeserialize(builder = RemovePrice.Builder::class)
    @NoAutoDetect
    class RemovePrice
    private constructor(
        private val priceId: String?,
        private val externalPriceId: String?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The id of the price to remove on the subscription. */
        @JsonProperty("price_id") fun priceId(): String? = priceId

        /** The external price id of the price to remove on the subscription. */
        @JsonProperty("external_price_id") fun externalPriceId(): String? = externalPriceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is RemovePrice &&
                this.priceId == other.priceId &&
                this.externalPriceId == other.externalPriceId &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        priceId,
                        externalPriceId,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "RemovePrice{priceId=$priceId, externalPriceId=$externalPriceId, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var priceId: String? = null
            private var externalPriceId: String? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(removePrice: RemovePrice) = apply {
                this.priceId = removePrice.priceId
                this.externalPriceId = removePrice.externalPriceId
                additionalProperties(removePrice.additionalProperties)
            }

            /** The id of the price to remove on the subscription. */
            @JsonProperty("price_id")
            fun priceId(priceId: String) = apply { this.priceId = priceId }

            /** The external price id of the price to remove on the subscription. */
            @JsonProperty("external_price_id")
            fun externalPriceId(externalPriceId: String) = apply {
                this.externalPriceId = externalPriceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): RemovePrice =
                RemovePrice(
                    priceId,
                    externalPriceId,
                    additionalProperties.toUnmodifiable(),
                )
        }
    }

    @JsonDeserialize(builder = ReplaceAdjustment.Builder::class)
    @NoAutoDetect
    class ReplaceAdjustment
    private constructor(
        private val adjustment: Adjustment?,
        private val replacesAdjustmentId: String?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The definition of a new adjustment to create and add to the subscription. */
        @JsonProperty("adjustment") fun adjustment(): Adjustment? = adjustment

        /** The id of the adjustment on the plan to replace in the subscription. */
        @JsonProperty("replaces_adjustment_id")
        fun replacesAdjustmentId(): String? = replacesAdjustmentId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ReplaceAdjustment &&
                this.adjustment == other.adjustment &&
                this.replacesAdjustmentId == other.replacesAdjustmentId &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        adjustment,
                        replacesAdjustmentId,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "ReplaceAdjustment{adjustment=$adjustment, replacesAdjustmentId=$replacesAdjustmentId, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var adjustment: Adjustment? = null
            private var replacesAdjustmentId: String? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(replaceAdjustment: ReplaceAdjustment) = apply {
                this.adjustment = replaceAdjustment.adjustment
                this.replacesAdjustmentId = replaceAdjustment.replacesAdjustmentId
                additionalProperties(replaceAdjustment.additionalProperties)
            }

            /** The definition of a new adjustment to create and add to the subscription. */
            @JsonProperty("adjustment")
            fun adjustment(adjustment: Adjustment) = apply { this.adjustment = adjustment }

            /** The id of the adjustment on the plan to replace in the subscription. */
            @JsonProperty("replaces_adjustment_id")
            fun replacesAdjustmentId(replacesAdjustmentId: String) = apply {
                this.replacesAdjustmentId = replacesAdjustmentId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): ReplaceAdjustment =
                ReplaceAdjustment(
                    checkNotNull(adjustment) { "`adjustment` is required but was not set" },
                    checkNotNull(replacesAdjustmentId) {
                        "`replacesAdjustmentId` is required but was not set"
                    },
                    additionalProperties.toUnmodifiable(),
                )
        }

        @JsonDeserialize(using = Adjustment.Deserializer::class)
        @JsonSerialize(using = Adjustment.Serializer::class)
        class Adjustment
        private constructor(
            private val newPercentageDiscount: NewPercentageDiscount? = null,
            private val newAmountDiscount: NewAmountDiscount? = null,
            private val newMinimum: NewMinimum? = null,
            private val newMaximum: NewMaximum? = null,
            private val _json: JsonValue? = null,
        ) {

            private var validated: Boolean = false

            fun newPercentageDiscount(): Optional<NewPercentageDiscount> =
                Optional.ofNullable(newPercentageDiscount)

            fun newAmountDiscount(): Optional<NewAmountDiscount> =
                Optional.ofNullable(newAmountDiscount)

            fun newMinimum(): Optional<NewMinimum> = Optional.ofNullable(newMinimum)

            fun newMaximum(): Optional<NewMaximum> = Optional.ofNullable(newMaximum)

            fun isNewPercentageDiscount(): Boolean = newPercentageDiscount != null

            fun isNewAmountDiscount(): Boolean = newAmountDiscount != null

            fun isNewMinimum(): Boolean = newMinimum != null

            fun isNewMaximum(): Boolean = newMaximum != null

            fun asNewPercentageDiscount(): NewPercentageDiscount =
                newPercentageDiscount.getOrThrow("newPercentageDiscount")

            fun asNewAmountDiscount(): NewAmountDiscount =
                newAmountDiscount.getOrThrow("newAmountDiscount")

            fun asNewMinimum(): NewMinimum = newMinimum.getOrThrow("newMinimum")

            fun asNewMaximum(): NewMaximum = newMaximum.getOrThrow("newMaximum")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T {
                return when {
                    newPercentageDiscount != null ->
                        visitor.visitNewPercentageDiscount(newPercentageDiscount)
                    newAmountDiscount != null -> visitor.visitNewAmountDiscount(newAmountDiscount)
                    newMinimum != null -> visitor.visitNewMinimum(newMinimum)
                    newMaximum != null -> visitor.visitNewMaximum(newMaximum)
                    else -> visitor.unknown(_json)
                }
            }

            fun validate(): Adjustment = apply {
                if (!validated) {
                    if (
                        newPercentageDiscount == null &&
                            newAmountDiscount == null &&
                            newMinimum == null &&
                            newMaximum == null
                    ) {
                        throw OrbInvalidDataException("Unknown Adjustment: $_json")
                    }
                    newPercentageDiscount?.validate()
                    newAmountDiscount?.validate()
                    newMinimum?.validate()
                    newMaximum?.validate()
                    validated = true
                }
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Adjustment &&
                    this.newPercentageDiscount == other.newPercentageDiscount &&
                    this.newAmountDiscount == other.newAmountDiscount &&
                    this.newMinimum == other.newMinimum &&
                    this.newMaximum == other.newMaximum
            }

            override fun hashCode(): Int {
                return Objects.hash(
                    newPercentageDiscount,
                    newAmountDiscount,
                    newMinimum,
                    newMaximum,
                )
            }

            override fun toString(): String {
                return when {
                    newPercentageDiscount != null ->
                        "Adjustment{newPercentageDiscount=$newPercentageDiscount}"
                    newAmountDiscount != null -> "Adjustment{newAmountDiscount=$newAmountDiscount}"
                    newMinimum != null -> "Adjustment{newMinimum=$newMinimum}"
                    newMaximum != null -> "Adjustment{newMaximum=$newMaximum}"
                    _json != null -> "Adjustment{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid Adjustment")
                }
            }

            companion object {

                @JvmStatic
                fun ofNewPercentageDiscount(newPercentageDiscount: NewPercentageDiscount) =
                    Adjustment(newPercentageDiscount = newPercentageDiscount)

                @JvmStatic
                fun ofNewAmountDiscount(newAmountDiscount: NewAmountDiscount) =
                    Adjustment(newAmountDiscount = newAmountDiscount)

                @JvmStatic
                fun ofNewMinimum(newMinimum: NewMinimum) = Adjustment(newMinimum = newMinimum)

                @JvmStatic
                fun ofNewMaximum(newMaximum: NewMaximum) = Adjustment(newMaximum = newMaximum)
            }

            interface Visitor<out T> {

                fun visitNewPercentageDiscount(newPercentageDiscount: NewPercentageDiscount): T

                fun visitNewAmountDiscount(newAmountDiscount: NewAmountDiscount): T

                fun visitNewMinimum(newMinimum: NewMinimum): T

                fun visitNewMaximum(newMaximum: NewMaximum): T

                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown Adjustment: $json")
                }
            }

            class Deserializer : BaseDeserializer<Adjustment>(Adjustment::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): Adjustment {
                    val json = JsonValue.fromJsonNode(node)
                    tryDeserialize(node, jacksonTypeRef<NewPercentageDiscount>()) { it.validate() }
                        ?.let {
                            return Adjustment(newPercentageDiscount = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewAmountDiscount>()) { it.validate() }
                        ?.let {
                            return Adjustment(newAmountDiscount = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewMinimum>()) { it.validate() }
                        ?.let {
                            return Adjustment(newMinimum = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewMaximum>()) { it.validate() }
                        ?.let {
                            return Adjustment(newMaximum = it, _json = json)
                        }

                    return Adjustment(_json = json)
                }
            }

            class Serializer : BaseSerializer<Adjustment>(Adjustment::class) {

                override fun serialize(
                    value: Adjustment,
                    generator: JsonGenerator,
                    provider: SerializerProvider
                ) {
                    when {
                        value.newPercentageDiscount != null ->
                            generator.writeObject(value.newPercentageDiscount)
                        value.newAmountDiscount != null ->
                            generator.writeObject(value.newAmountDiscount)
                        value.newMinimum != null -> generator.writeObject(value.newMinimum)
                        value.newMaximum != null -> generator.writeObject(value.newMaximum)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid Adjustment")
                    }
                }
            }

            @JsonDeserialize(builder = NewPercentageDiscount.Builder::class)
            @NoAutoDetect
            class NewPercentageDiscount
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val percentageDiscount: JsonField<Double>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun percentageDiscount(): Double =
                    percentageDiscount.getRequired("percentage_discount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("percentage_discount")
                @ExcludeMissing
                fun _percentageDiscount() = percentageDiscount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewPercentageDiscount = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        percentageDiscount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewPercentageDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.percentageDiscount == other.percentageDiscount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                percentageDiscount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewPercentageDiscount{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, percentageDiscount=$percentageDiscount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var percentageDiscount: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newPercentageDiscount: NewPercentageDiscount) = apply {
                        this.appliesToPriceIds = newPercentageDiscount.appliesToPriceIds
                        this.adjustmentType = newPercentageDiscount.adjustmentType
                        this.percentageDiscount = newPercentageDiscount.percentageDiscount
                        additionalProperties(newPercentageDiscount.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun percentageDiscount(percentageDiscount: Double) =
                        percentageDiscount(JsonField.of(percentageDiscount))

                    @JsonProperty("percentage_discount")
                    @ExcludeMissing
                    fun percentageDiscount(percentageDiscount: JsonField<Double>) = apply {
                        this.percentageDiscount = percentageDiscount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewPercentageDiscount =
                        NewPercentageDiscount(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            percentageDiscount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val PERCENTAGE_DISCOUNT =
                            AdjustmentType(JsonField.of("percentage_discount"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        PERCENTAGE_DISCOUNT,
                    }

                    enum class Value {
                        PERCENTAGE_DISCOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PERCENTAGE_DISCOUNT -> Value.PERCENTAGE_DISCOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PERCENTAGE_DISCOUNT -> Known.PERCENTAGE_DISCOUNT
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewAmountDiscount.Builder::class)
            @NoAutoDetect
            class NewAmountDiscount
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val amountDiscount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun amountDiscount(): String = amountDiscount.getRequired("amount_discount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("amount_discount")
                @ExcludeMissing
                fun _amountDiscount() = amountDiscount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewAmountDiscount = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        amountDiscount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewAmountDiscount &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.amountDiscount == other.amountDiscount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                amountDiscount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewAmountDiscount{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, amountDiscount=$amountDiscount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var amountDiscount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newAmountDiscount: NewAmountDiscount) = apply {
                        this.appliesToPriceIds = newAmountDiscount.appliesToPriceIds
                        this.adjustmentType = newAmountDiscount.adjustmentType
                        this.amountDiscount = newAmountDiscount.amountDiscount
                        additionalProperties(newAmountDiscount.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun amountDiscount(amountDiscount: String) =
                        amountDiscount(JsonField.of(amountDiscount))

                    @JsonProperty("amount_discount")
                    @ExcludeMissing
                    fun amountDiscount(amountDiscount: JsonField<String>) = apply {
                        this.amountDiscount = amountDiscount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewAmountDiscount =
                        NewAmountDiscount(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            amountDiscount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val AMOUNT_DISCOUNT = AdjustmentType(JsonField.of("amount_discount"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        AMOUNT_DISCOUNT,
                    }

                    enum class Value {
                        AMOUNT_DISCOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            AMOUNT_DISCOUNT -> Value.AMOUNT_DISCOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            AMOUNT_DISCOUNT -> Known.AMOUNT_DISCOUNT
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewMinimum.Builder::class)
            @NoAutoDetect
            class NewMinimum
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val minimumAmount: JsonField<String>,
                private val itemId: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /** The item ID that revenue from this minimum will be attributed to. */
                fun itemId(): String = itemId.getRequired("item_id")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("minimum_amount") @ExcludeMissing fun _minimumAmount() = minimumAmount

                /** The item ID that revenue from this minimum will be attributed to. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewMinimum = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        minimumAmount()
                        itemId()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewMinimum &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.minimumAmount == other.minimumAmount &&
                        this.itemId == other.itemId &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                minimumAmount,
                                itemId,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewMinimum{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, minimumAmount=$minimumAmount, itemId=$itemId, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var minimumAmount: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newMinimum: NewMinimum) = apply {
                        this.appliesToPriceIds = newMinimum.appliesToPriceIds
                        this.adjustmentType = newMinimum.adjustmentType
                        this.minimumAmount = newMinimum.minimumAmount
                        this.itemId = newMinimum.itemId
                        additionalProperties(newMinimum.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** The item ID that revenue from this minimum will be attributed to. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The item ID that revenue from this minimum will be attributed to. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewMinimum =
                        NewMinimum(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            minimumAmount,
                            itemId,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MINIMUM = AdjustmentType(JsonField.of("minimum"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        MINIMUM,
                    }

                    enum class Value {
                        MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MINIMUM -> Value.MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MINIMUM -> Known.MINIMUM
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }

            @JsonDeserialize(builder = NewMaximum.Builder::class)
            @NoAutoDetect
            class NewMaximum
            private constructor(
                private val appliesToPriceIds: JsonField<List<String>>,
                private val adjustmentType: JsonField<AdjustmentType>,
                private val maximumAmount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** The set of price IDs to which this adjustment applies. */
                fun appliesToPriceIds(): List<String> =
                    appliesToPriceIds.getRequired("applies_to_price_ids")

                fun adjustmentType(): AdjustmentType = adjustmentType.getRequired("adjustment_type")

                fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

                /** The set of price IDs to which this adjustment applies. */
                @JsonProperty("applies_to_price_ids")
                @ExcludeMissing
                fun _appliesToPriceIds() = appliesToPriceIds

                @JsonProperty("adjustment_type")
                @ExcludeMissing
                fun _adjustmentType() = adjustmentType

                @JsonProperty("maximum_amount") @ExcludeMissing fun _maximumAmount() = maximumAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewMaximum = apply {
                    if (!validated) {
                        appliesToPriceIds()
                        adjustmentType()
                        maximumAmount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewMaximum &&
                        this.appliesToPriceIds == other.appliesToPriceIds &&
                        this.adjustmentType == other.adjustmentType &&
                        this.maximumAmount == other.maximumAmount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                appliesToPriceIds,
                                adjustmentType,
                                maximumAmount,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewMaximum{appliesToPriceIds=$appliesToPriceIds, adjustmentType=$adjustmentType, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var appliesToPriceIds: JsonField<List<String>> = JsonMissing.of()
                    private var adjustmentType: JsonField<AdjustmentType> = JsonMissing.of()
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newMaximum: NewMaximum) = apply {
                        this.appliesToPriceIds = newMaximum.appliesToPriceIds
                        this.adjustmentType = newMaximum.adjustmentType
                        this.maximumAmount = newMaximum.maximumAmount
                        additionalProperties(newMaximum.additionalProperties)
                    }

                    /** The set of price IDs to which this adjustment applies. */
                    fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                        appliesToPriceIds(JsonField.of(appliesToPriceIds))

                    /** The set of price IDs to which this adjustment applies. */
                    @JsonProperty("applies_to_price_ids")
                    @ExcludeMissing
                    fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                        this.appliesToPriceIds = appliesToPriceIds
                    }

                    fun adjustmentType(adjustmentType: AdjustmentType) =
                        adjustmentType(JsonField.of(adjustmentType))

                    @JsonProperty("adjustment_type")
                    @ExcludeMissing
                    fun adjustmentType(adjustmentType: JsonField<AdjustmentType>) = apply {
                        this.adjustmentType = adjustmentType
                    }

                    fun maximumAmount(maximumAmount: String) =
                        maximumAmount(JsonField.of(maximumAmount))

                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewMaximum =
                        NewMaximum(
                            appliesToPriceIds.map { it.toUnmodifiable() },
                            adjustmentType,
                            maximumAmount,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class AdjustmentType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AdjustmentType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MAXIMUM = AdjustmentType(JsonField.of("maximum"))

                        @JvmStatic fun of(value: String) = AdjustmentType(JsonField.of(value))
                    }

                    enum class Known {
                        MAXIMUM,
                    }

                    enum class Value {
                        MAXIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MAXIMUM -> Value.MAXIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MAXIMUM -> Known.MAXIMUM
                            else -> throw OrbInvalidDataException("Unknown AdjustmentType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }
            }
        }
    }

    @JsonDeserialize(builder = ReplacePrice.Builder::class)
    @NoAutoDetect
    class ReplacePrice
    private constructor(
        private val price: Price?,
        private val replacesPriceId: String?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** The definition of a new price to create and add to the subscription. */
        @JsonProperty("price") fun price(): Price? = price

        /** The id of the price on the plan to replace in the subscription. */
        @JsonProperty("replaces_price_id") fun replacesPriceId(): String? = replacesPriceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ReplacePrice &&
                this.price == other.price &&
                this.replacesPriceId == other.replacesPriceId &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        price,
                        replacesPriceId,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "ReplacePrice{price=$price, replacesPriceId=$replacesPriceId, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var price: Price? = null
            private var replacesPriceId: String? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(replacePrice: ReplacePrice) = apply {
                this.price = replacePrice.price
                this.replacesPriceId = replacePrice.replacesPriceId
                additionalProperties(replacePrice.additionalProperties)
            }

            /** The definition of a new price to create and add to the subscription. */
            @JsonProperty("price") fun price(price: Price) = apply { this.price = price }

            /** The id of the price on the plan to replace in the subscription. */
            @JsonProperty("replaces_price_id")
            fun replacesPriceId(replacesPriceId: String) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): ReplacePrice =
                ReplacePrice(
                    checkNotNull(price) { "`price` is required but was not set" },
                    checkNotNull(replacesPriceId) {
                        "`replacesPriceId` is required but was not set"
                    },
                    additionalProperties.toUnmodifiable(),
                )
        }

        @JsonDeserialize(using = Price.Deserializer::class)
        @JsonSerialize(using = Price.Serializer::class)
        class Price
        private constructor(
            private val newSubscriptionUnitPrice: NewSubscriptionUnitPrice? = null,
            private val newSubscriptionPackagePrice: NewSubscriptionPackagePrice? = null,
            private val newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice? = null,
            private val newSubscriptionTieredPrice: NewSubscriptionTieredPrice? = null,
            private val newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice? = null,
            private val newSubscriptionBpsPrice: NewSubscriptionBpsPrice? = null,
            private val newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice? = null,
            private val newSubscriptionBulkPrice: NewSubscriptionBulkPrice? = null,
            private val newSubscriptionThresholdTotalAmountPrice:
                NewSubscriptionThresholdTotalAmountPrice? =
                null,
            private val newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice? =
                null,
            private val newSubscriptionTieredWithMinimumPrice:
                NewSubscriptionTieredWithMinimumPrice? =
                null,
            private val newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice? =
                null,
            private val newSubscriptionPackageWithAllocationPrice:
                NewSubscriptionPackageWithAllocationPrice? =
                null,
            private val newSubscriptionTierWithProrationPrice:
                NewSubscriptionTierWithProrationPrice? =
                null,
            private val newSubscriptionUnitWithProrationPrice:
                NewSubscriptionUnitWithProrationPrice? =
                null,
            private val newSubscriptionGroupedAllocationPrice:
                NewSubscriptionGroupedAllocationPrice? =
                null,
            private val newSubscriptionGroupedWithProratedMinimumPrice:
                NewSubscriptionGroupedWithProratedMinimumPrice? =
                null,
            private val newSubscriptionBulkWithProrationPrice:
                NewSubscriptionBulkWithProrationPrice? =
                null,
            private val _json: JsonValue? = null,
        ) {

            private var validated: Boolean = false

            fun newSubscriptionUnitPrice(): Optional<NewSubscriptionUnitPrice> =
                Optional.ofNullable(newSubscriptionUnitPrice)

            fun newSubscriptionPackagePrice(): Optional<NewSubscriptionPackagePrice> =
                Optional.ofNullable(newSubscriptionPackagePrice)

            fun newSubscriptionMatrixPrice(): Optional<NewSubscriptionMatrixPrice> =
                Optional.ofNullable(newSubscriptionMatrixPrice)

            fun newSubscriptionTieredPrice(): Optional<NewSubscriptionTieredPrice> =
                Optional.ofNullable(newSubscriptionTieredPrice)

            fun newSubscriptionTieredBpsPrice(): Optional<NewSubscriptionTieredBpsPrice> =
                Optional.ofNullable(newSubscriptionTieredBpsPrice)

            fun newSubscriptionBpsPrice(): Optional<NewSubscriptionBpsPrice> =
                Optional.ofNullable(newSubscriptionBpsPrice)

            fun newSubscriptionBulkBpsPrice(): Optional<NewSubscriptionBulkBpsPrice> =
                Optional.ofNullable(newSubscriptionBulkBpsPrice)

            fun newSubscriptionBulkPrice(): Optional<NewSubscriptionBulkPrice> =
                Optional.ofNullable(newSubscriptionBulkPrice)

            fun newSubscriptionThresholdTotalAmountPrice():
                Optional<NewSubscriptionThresholdTotalAmountPrice> =
                Optional.ofNullable(newSubscriptionThresholdTotalAmountPrice)

            fun newSubscriptionTieredPackagePrice(): Optional<NewSubscriptionTieredPackagePrice> =
                Optional.ofNullable(newSubscriptionTieredPackagePrice)

            fun newSubscriptionTieredWithMinimumPrice():
                Optional<NewSubscriptionTieredWithMinimumPrice> =
                Optional.ofNullable(newSubscriptionTieredWithMinimumPrice)

            fun newSubscriptionUnitWithPercentPrice():
                Optional<NewSubscriptionUnitWithPercentPrice> =
                Optional.ofNullable(newSubscriptionUnitWithPercentPrice)

            fun newSubscriptionPackageWithAllocationPrice():
                Optional<NewSubscriptionPackageWithAllocationPrice> =
                Optional.ofNullable(newSubscriptionPackageWithAllocationPrice)

            fun newSubscriptionTierWithProrationPrice():
                Optional<NewSubscriptionTierWithProrationPrice> =
                Optional.ofNullable(newSubscriptionTierWithProrationPrice)

            fun newSubscriptionUnitWithProrationPrice():
                Optional<NewSubscriptionUnitWithProrationPrice> =
                Optional.ofNullable(newSubscriptionUnitWithProrationPrice)

            fun newSubscriptionGroupedAllocationPrice():
                Optional<NewSubscriptionGroupedAllocationPrice> =
                Optional.ofNullable(newSubscriptionGroupedAllocationPrice)

            fun newSubscriptionGroupedWithProratedMinimumPrice():
                Optional<NewSubscriptionGroupedWithProratedMinimumPrice> =
                Optional.ofNullable(newSubscriptionGroupedWithProratedMinimumPrice)

            fun newSubscriptionBulkWithProrationPrice():
                Optional<NewSubscriptionBulkWithProrationPrice> =
                Optional.ofNullable(newSubscriptionBulkWithProrationPrice)

            fun isNewSubscriptionUnitPrice(): Boolean = newSubscriptionUnitPrice != null

            fun isNewSubscriptionPackagePrice(): Boolean = newSubscriptionPackagePrice != null

            fun isNewSubscriptionMatrixPrice(): Boolean = newSubscriptionMatrixPrice != null

            fun isNewSubscriptionTieredPrice(): Boolean = newSubscriptionTieredPrice != null

            fun isNewSubscriptionTieredBpsPrice(): Boolean = newSubscriptionTieredBpsPrice != null

            fun isNewSubscriptionBpsPrice(): Boolean = newSubscriptionBpsPrice != null

            fun isNewSubscriptionBulkBpsPrice(): Boolean = newSubscriptionBulkBpsPrice != null

            fun isNewSubscriptionBulkPrice(): Boolean = newSubscriptionBulkPrice != null

            fun isNewSubscriptionThresholdTotalAmountPrice(): Boolean =
                newSubscriptionThresholdTotalAmountPrice != null

            fun isNewSubscriptionTieredPackagePrice(): Boolean =
                newSubscriptionTieredPackagePrice != null

            fun isNewSubscriptionTieredWithMinimumPrice(): Boolean =
                newSubscriptionTieredWithMinimumPrice != null

            fun isNewSubscriptionUnitWithPercentPrice(): Boolean =
                newSubscriptionUnitWithPercentPrice != null

            fun isNewSubscriptionPackageWithAllocationPrice(): Boolean =
                newSubscriptionPackageWithAllocationPrice != null

            fun isNewSubscriptionTierWithProrationPrice(): Boolean =
                newSubscriptionTierWithProrationPrice != null

            fun isNewSubscriptionUnitWithProrationPrice(): Boolean =
                newSubscriptionUnitWithProrationPrice != null

            fun isNewSubscriptionGroupedAllocationPrice(): Boolean =
                newSubscriptionGroupedAllocationPrice != null

            fun isNewSubscriptionGroupedWithProratedMinimumPrice(): Boolean =
                newSubscriptionGroupedWithProratedMinimumPrice != null

            fun isNewSubscriptionBulkWithProrationPrice(): Boolean =
                newSubscriptionBulkWithProrationPrice != null

            fun asNewSubscriptionUnitPrice(): NewSubscriptionUnitPrice =
                newSubscriptionUnitPrice.getOrThrow("newSubscriptionUnitPrice")

            fun asNewSubscriptionPackagePrice(): NewSubscriptionPackagePrice =
                newSubscriptionPackagePrice.getOrThrow("newSubscriptionPackagePrice")

            fun asNewSubscriptionMatrixPrice(): NewSubscriptionMatrixPrice =
                newSubscriptionMatrixPrice.getOrThrow("newSubscriptionMatrixPrice")

            fun asNewSubscriptionTieredPrice(): NewSubscriptionTieredPrice =
                newSubscriptionTieredPrice.getOrThrow("newSubscriptionTieredPrice")

            fun asNewSubscriptionTieredBpsPrice(): NewSubscriptionTieredBpsPrice =
                newSubscriptionTieredBpsPrice.getOrThrow("newSubscriptionTieredBpsPrice")

            fun asNewSubscriptionBpsPrice(): NewSubscriptionBpsPrice =
                newSubscriptionBpsPrice.getOrThrow("newSubscriptionBpsPrice")

            fun asNewSubscriptionBulkBpsPrice(): NewSubscriptionBulkBpsPrice =
                newSubscriptionBulkBpsPrice.getOrThrow("newSubscriptionBulkBpsPrice")

            fun asNewSubscriptionBulkPrice(): NewSubscriptionBulkPrice =
                newSubscriptionBulkPrice.getOrThrow("newSubscriptionBulkPrice")

            fun asNewSubscriptionThresholdTotalAmountPrice():
                NewSubscriptionThresholdTotalAmountPrice =
                newSubscriptionThresholdTotalAmountPrice.getOrThrow(
                    "newSubscriptionThresholdTotalAmountPrice"
                )

            fun asNewSubscriptionTieredPackagePrice(): NewSubscriptionTieredPackagePrice =
                newSubscriptionTieredPackagePrice.getOrThrow("newSubscriptionTieredPackagePrice")

            fun asNewSubscriptionTieredWithMinimumPrice(): NewSubscriptionTieredWithMinimumPrice =
                newSubscriptionTieredWithMinimumPrice.getOrThrow(
                    "newSubscriptionTieredWithMinimumPrice"
                )

            fun asNewSubscriptionUnitWithPercentPrice(): NewSubscriptionUnitWithPercentPrice =
                newSubscriptionUnitWithPercentPrice.getOrThrow(
                    "newSubscriptionUnitWithPercentPrice"
                )

            fun asNewSubscriptionPackageWithAllocationPrice():
                NewSubscriptionPackageWithAllocationPrice =
                newSubscriptionPackageWithAllocationPrice.getOrThrow(
                    "newSubscriptionPackageWithAllocationPrice"
                )

            fun asNewSubscriptionTierWithProrationPrice(): NewSubscriptionTierWithProrationPrice =
                newSubscriptionTierWithProrationPrice.getOrThrow(
                    "newSubscriptionTierWithProrationPrice"
                )

            fun asNewSubscriptionUnitWithProrationPrice(): NewSubscriptionUnitWithProrationPrice =
                newSubscriptionUnitWithProrationPrice.getOrThrow(
                    "newSubscriptionUnitWithProrationPrice"
                )

            fun asNewSubscriptionGroupedAllocationPrice(): NewSubscriptionGroupedAllocationPrice =
                newSubscriptionGroupedAllocationPrice.getOrThrow(
                    "newSubscriptionGroupedAllocationPrice"
                )

            fun asNewSubscriptionGroupedWithProratedMinimumPrice():
                NewSubscriptionGroupedWithProratedMinimumPrice =
                newSubscriptionGroupedWithProratedMinimumPrice.getOrThrow(
                    "newSubscriptionGroupedWithProratedMinimumPrice"
                )

            fun asNewSubscriptionBulkWithProrationPrice(): NewSubscriptionBulkWithProrationPrice =
                newSubscriptionBulkWithProrationPrice.getOrThrow(
                    "newSubscriptionBulkWithProrationPrice"
                )

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T {
                return when {
                    newSubscriptionUnitPrice != null ->
                        visitor.visitNewSubscriptionUnitPrice(newSubscriptionUnitPrice)
                    newSubscriptionPackagePrice != null ->
                        visitor.visitNewSubscriptionPackagePrice(newSubscriptionPackagePrice)
                    newSubscriptionMatrixPrice != null ->
                        visitor.visitNewSubscriptionMatrixPrice(newSubscriptionMatrixPrice)
                    newSubscriptionTieredPrice != null ->
                        visitor.visitNewSubscriptionTieredPrice(newSubscriptionTieredPrice)
                    newSubscriptionTieredBpsPrice != null ->
                        visitor.visitNewSubscriptionTieredBpsPrice(newSubscriptionTieredBpsPrice)
                    newSubscriptionBpsPrice != null ->
                        visitor.visitNewSubscriptionBpsPrice(newSubscriptionBpsPrice)
                    newSubscriptionBulkBpsPrice != null ->
                        visitor.visitNewSubscriptionBulkBpsPrice(newSubscriptionBulkBpsPrice)
                    newSubscriptionBulkPrice != null ->
                        visitor.visitNewSubscriptionBulkPrice(newSubscriptionBulkPrice)
                    newSubscriptionThresholdTotalAmountPrice != null ->
                        visitor.visitNewSubscriptionThresholdTotalAmountPrice(
                            newSubscriptionThresholdTotalAmountPrice
                        )
                    newSubscriptionTieredPackagePrice != null ->
                        visitor.visitNewSubscriptionTieredPackagePrice(
                            newSubscriptionTieredPackagePrice
                        )
                    newSubscriptionTieredWithMinimumPrice != null ->
                        visitor.visitNewSubscriptionTieredWithMinimumPrice(
                            newSubscriptionTieredWithMinimumPrice
                        )
                    newSubscriptionUnitWithPercentPrice != null ->
                        visitor.visitNewSubscriptionUnitWithPercentPrice(
                            newSubscriptionUnitWithPercentPrice
                        )
                    newSubscriptionPackageWithAllocationPrice != null ->
                        visitor.visitNewSubscriptionPackageWithAllocationPrice(
                            newSubscriptionPackageWithAllocationPrice
                        )
                    newSubscriptionTierWithProrationPrice != null ->
                        visitor.visitNewSubscriptionTierWithProrationPrice(
                            newSubscriptionTierWithProrationPrice
                        )
                    newSubscriptionUnitWithProrationPrice != null ->
                        visitor.visitNewSubscriptionUnitWithProrationPrice(
                            newSubscriptionUnitWithProrationPrice
                        )
                    newSubscriptionGroupedAllocationPrice != null ->
                        visitor.visitNewSubscriptionGroupedAllocationPrice(
                            newSubscriptionGroupedAllocationPrice
                        )
                    newSubscriptionGroupedWithProratedMinimumPrice != null ->
                        visitor.visitNewSubscriptionGroupedWithProratedMinimumPrice(
                            newSubscriptionGroupedWithProratedMinimumPrice
                        )
                    newSubscriptionBulkWithProrationPrice != null ->
                        visitor.visitNewSubscriptionBulkWithProrationPrice(
                            newSubscriptionBulkWithProrationPrice
                        )
                    else -> visitor.unknown(_json)
                }
            }

            fun validate(): Price = apply {
                if (!validated) {
                    if (
                        newSubscriptionUnitPrice == null &&
                            newSubscriptionPackagePrice == null &&
                            newSubscriptionMatrixPrice == null &&
                            newSubscriptionTieredPrice == null &&
                            newSubscriptionTieredBpsPrice == null &&
                            newSubscriptionBpsPrice == null &&
                            newSubscriptionBulkBpsPrice == null &&
                            newSubscriptionBulkPrice == null &&
                            newSubscriptionThresholdTotalAmountPrice == null &&
                            newSubscriptionTieredPackagePrice == null &&
                            newSubscriptionTieredWithMinimumPrice == null &&
                            newSubscriptionUnitWithPercentPrice == null &&
                            newSubscriptionPackageWithAllocationPrice == null &&
                            newSubscriptionTierWithProrationPrice == null &&
                            newSubscriptionUnitWithProrationPrice == null &&
                            newSubscriptionGroupedAllocationPrice == null &&
                            newSubscriptionGroupedWithProratedMinimumPrice == null &&
                            newSubscriptionBulkWithProrationPrice == null
                    ) {
                        throw OrbInvalidDataException("Unknown Price: $_json")
                    }
                    newSubscriptionUnitPrice?.validate()
                    newSubscriptionPackagePrice?.validate()
                    newSubscriptionMatrixPrice?.validate()
                    newSubscriptionTieredPrice?.validate()
                    newSubscriptionTieredBpsPrice?.validate()
                    newSubscriptionBpsPrice?.validate()
                    newSubscriptionBulkBpsPrice?.validate()
                    newSubscriptionBulkPrice?.validate()
                    newSubscriptionThresholdTotalAmountPrice?.validate()
                    newSubscriptionTieredPackagePrice?.validate()
                    newSubscriptionTieredWithMinimumPrice?.validate()
                    newSubscriptionUnitWithPercentPrice?.validate()
                    newSubscriptionPackageWithAllocationPrice?.validate()
                    newSubscriptionTierWithProrationPrice?.validate()
                    newSubscriptionUnitWithProrationPrice?.validate()
                    newSubscriptionGroupedAllocationPrice?.validate()
                    newSubscriptionGroupedWithProratedMinimumPrice?.validate()
                    newSubscriptionBulkWithProrationPrice?.validate()
                    validated = true
                }
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Price &&
                    this.newSubscriptionUnitPrice == other.newSubscriptionUnitPrice &&
                    this.newSubscriptionPackagePrice == other.newSubscriptionPackagePrice &&
                    this.newSubscriptionMatrixPrice == other.newSubscriptionMatrixPrice &&
                    this.newSubscriptionTieredPrice == other.newSubscriptionTieredPrice &&
                    this.newSubscriptionTieredBpsPrice == other.newSubscriptionTieredBpsPrice &&
                    this.newSubscriptionBpsPrice == other.newSubscriptionBpsPrice &&
                    this.newSubscriptionBulkBpsPrice == other.newSubscriptionBulkBpsPrice &&
                    this.newSubscriptionBulkPrice == other.newSubscriptionBulkPrice &&
                    this.newSubscriptionThresholdTotalAmountPrice ==
                        other.newSubscriptionThresholdTotalAmountPrice &&
                    this.newSubscriptionTieredPackagePrice ==
                        other.newSubscriptionTieredPackagePrice &&
                    this.newSubscriptionTieredWithMinimumPrice ==
                        other.newSubscriptionTieredWithMinimumPrice &&
                    this.newSubscriptionUnitWithPercentPrice ==
                        other.newSubscriptionUnitWithPercentPrice &&
                    this.newSubscriptionPackageWithAllocationPrice ==
                        other.newSubscriptionPackageWithAllocationPrice &&
                    this.newSubscriptionTierWithProrationPrice ==
                        other.newSubscriptionTierWithProrationPrice &&
                    this.newSubscriptionUnitWithProrationPrice ==
                        other.newSubscriptionUnitWithProrationPrice &&
                    this.newSubscriptionGroupedAllocationPrice ==
                        other.newSubscriptionGroupedAllocationPrice &&
                    this.newSubscriptionGroupedWithProratedMinimumPrice ==
                        other.newSubscriptionGroupedWithProratedMinimumPrice &&
                    this.newSubscriptionBulkWithProrationPrice ==
                        other.newSubscriptionBulkWithProrationPrice
            }

            override fun hashCode(): Int {
                return Objects.hash(
                    newSubscriptionUnitPrice,
                    newSubscriptionPackagePrice,
                    newSubscriptionMatrixPrice,
                    newSubscriptionTieredPrice,
                    newSubscriptionTieredBpsPrice,
                    newSubscriptionBpsPrice,
                    newSubscriptionBulkBpsPrice,
                    newSubscriptionBulkPrice,
                    newSubscriptionThresholdTotalAmountPrice,
                    newSubscriptionTieredPackagePrice,
                    newSubscriptionTieredWithMinimumPrice,
                    newSubscriptionUnitWithPercentPrice,
                    newSubscriptionPackageWithAllocationPrice,
                    newSubscriptionTierWithProrationPrice,
                    newSubscriptionUnitWithProrationPrice,
                    newSubscriptionGroupedAllocationPrice,
                    newSubscriptionGroupedWithProratedMinimumPrice,
                    newSubscriptionBulkWithProrationPrice,
                )
            }

            override fun toString(): String {
                return when {
                    newSubscriptionUnitPrice != null ->
                        "Price{newSubscriptionUnitPrice=$newSubscriptionUnitPrice}"
                    newSubscriptionPackagePrice != null ->
                        "Price{newSubscriptionPackagePrice=$newSubscriptionPackagePrice}"
                    newSubscriptionMatrixPrice != null ->
                        "Price{newSubscriptionMatrixPrice=$newSubscriptionMatrixPrice}"
                    newSubscriptionTieredPrice != null ->
                        "Price{newSubscriptionTieredPrice=$newSubscriptionTieredPrice}"
                    newSubscriptionTieredBpsPrice != null ->
                        "Price{newSubscriptionTieredBpsPrice=$newSubscriptionTieredBpsPrice}"
                    newSubscriptionBpsPrice != null ->
                        "Price{newSubscriptionBpsPrice=$newSubscriptionBpsPrice}"
                    newSubscriptionBulkBpsPrice != null ->
                        "Price{newSubscriptionBulkBpsPrice=$newSubscriptionBulkBpsPrice}"
                    newSubscriptionBulkPrice != null ->
                        "Price{newSubscriptionBulkPrice=$newSubscriptionBulkPrice}"
                    newSubscriptionThresholdTotalAmountPrice != null ->
                        "Price{newSubscriptionThresholdTotalAmountPrice=$newSubscriptionThresholdTotalAmountPrice}"
                    newSubscriptionTieredPackagePrice != null ->
                        "Price{newSubscriptionTieredPackagePrice=$newSubscriptionTieredPackagePrice}"
                    newSubscriptionTieredWithMinimumPrice != null ->
                        "Price{newSubscriptionTieredWithMinimumPrice=$newSubscriptionTieredWithMinimumPrice}"
                    newSubscriptionUnitWithPercentPrice != null ->
                        "Price{newSubscriptionUnitWithPercentPrice=$newSubscriptionUnitWithPercentPrice}"
                    newSubscriptionPackageWithAllocationPrice != null ->
                        "Price{newSubscriptionPackageWithAllocationPrice=$newSubscriptionPackageWithAllocationPrice}"
                    newSubscriptionTierWithProrationPrice != null ->
                        "Price{newSubscriptionTierWithProrationPrice=$newSubscriptionTierWithProrationPrice}"
                    newSubscriptionUnitWithProrationPrice != null ->
                        "Price{newSubscriptionUnitWithProrationPrice=$newSubscriptionUnitWithProrationPrice}"
                    newSubscriptionGroupedAllocationPrice != null ->
                        "Price{newSubscriptionGroupedAllocationPrice=$newSubscriptionGroupedAllocationPrice}"
                    newSubscriptionGroupedWithProratedMinimumPrice != null ->
                        "Price{newSubscriptionGroupedWithProratedMinimumPrice=$newSubscriptionGroupedWithProratedMinimumPrice}"
                    newSubscriptionBulkWithProrationPrice != null ->
                        "Price{newSubscriptionBulkWithProrationPrice=$newSubscriptionBulkWithProrationPrice}"
                    _json != null -> "Price{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid Price")
                }
            }

            companion object {

                @JvmStatic
                fun ofNewSubscriptionUnitPrice(newSubscriptionUnitPrice: NewSubscriptionUnitPrice) =
                    Price(newSubscriptionUnitPrice = newSubscriptionUnitPrice)

                @JvmStatic
                fun ofNewSubscriptionPackagePrice(
                    newSubscriptionPackagePrice: NewSubscriptionPackagePrice
                ) = Price(newSubscriptionPackagePrice = newSubscriptionPackagePrice)

                @JvmStatic
                fun ofNewSubscriptionMatrixPrice(
                    newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice
                ) = Price(newSubscriptionMatrixPrice = newSubscriptionMatrixPrice)

                @JvmStatic
                fun ofNewSubscriptionTieredPrice(
                    newSubscriptionTieredPrice: NewSubscriptionTieredPrice
                ) = Price(newSubscriptionTieredPrice = newSubscriptionTieredPrice)

                @JvmStatic
                fun ofNewSubscriptionTieredBpsPrice(
                    newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                ) = Price(newSubscriptionTieredBpsPrice = newSubscriptionTieredBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBpsPrice(newSubscriptionBpsPrice: NewSubscriptionBpsPrice) =
                    Price(newSubscriptionBpsPrice = newSubscriptionBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBulkBpsPrice(
                    newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice
                ) = Price(newSubscriptionBulkBpsPrice = newSubscriptionBulkBpsPrice)

                @JvmStatic
                fun ofNewSubscriptionBulkPrice(newSubscriptionBulkPrice: NewSubscriptionBulkPrice) =
                    Price(newSubscriptionBulkPrice = newSubscriptionBulkPrice)

                @JvmStatic
                fun ofNewSubscriptionThresholdTotalAmountPrice(
                    newSubscriptionThresholdTotalAmountPrice:
                        NewSubscriptionThresholdTotalAmountPrice
                ) =
                    Price(
                        newSubscriptionThresholdTotalAmountPrice =
                            newSubscriptionThresholdTotalAmountPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionTieredPackagePrice(
                    newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                ) = Price(newSubscriptionTieredPackagePrice = newSubscriptionTieredPackagePrice)

                @JvmStatic
                fun ofNewSubscriptionTieredWithMinimumPrice(
                    newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                ) =
                    Price(
                        newSubscriptionTieredWithMinimumPrice =
                            newSubscriptionTieredWithMinimumPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionUnitWithPercentPrice(
                    newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                ) = Price(newSubscriptionUnitWithPercentPrice = newSubscriptionUnitWithPercentPrice)

                @JvmStatic
                fun ofNewSubscriptionPackageWithAllocationPrice(
                    newSubscriptionPackageWithAllocationPrice:
                        NewSubscriptionPackageWithAllocationPrice
                ) =
                    Price(
                        newSubscriptionPackageWithAllocationPrice =
                            newSubscriptionPackageWithAllocationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionTierWithProrationPrice(
                    newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                ) =
                    Price(
                        newSubscriptionTierWithProrationPrice =
                            newSubscriptionTierWithProrationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionUnitWithProrationPrice(
                    newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                ) =
                    Price(
                        newSubscriptionUnitWithProrationPrice =
                            newSubscriptionUnitWithProrationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionGroupedAllocationPrice(
                    newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                ) =
                    Price(
                        newSubscriptionGroupedAllocationPrice =
                            newSubscriptionGroupedAllocationPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionGroupedWithProratedMinimumPrice(
                    newSubscriptionGroupedWithProratedMinimumPrice:
                        NewSubscriptionGroupedWithProratedMinimumPrice
                ) =
                    Price(
                        newSubscriptionGroupedWithProratedMinimumPrice =
                            newSubscriptionGroupedWithProratedMinimumPrice
                    )

                @JvmStatic
                fun ofNewSubscriptionBulkWithProrationPrice(
                    newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                ) =
                    Price(
                        newSubscriptionBulkWithProrationPrice =
                            newSubscriptionBulkWithProrationPrice
                    )
            }

            interface Visitor<out T> {

                fun visitNewSubscriptionUnitPrice(
                    newSubscriptionUnitPrice: NewSubscriptionUnitPrice
                ): T

                fun visitNewSubscriptionPackagePrice(
                    newSubscriptionPackagePrice: NewSubscriptionPackagePrice
                ): T

                fun visitNewSubscriptionMatrixPrice(
                    newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice
                ): T

                fun visitNewSubscriptionTieredPrice(
                    newSubscriptionTieredPrice: NewSubscriptionTieredPrice
                ): T

                fun visitNewSubscriptionTieredBpsPrice(
                    newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                ): T

                fun visitNewSubscriptionBpsPrice(
                    newSubscriptionBpsPrice: NewSubscriptionBpsPrice
                ): T

                fun visitNewSubscriptionBulkBpsPrice(
                    newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice
                ): T

                fun visitNewSubscriptionBulkPrice(
                    newSubscriptionBulkPrice: NewSubscriptionBulkPrice
                ): T

                fun visitNewSubscriptionThresholdTotalAmountPrice(
                    newSubscriptionThresholdTotalAmountPrice:
                        NewSubscriptionThresholdTotalAmountPrice
                ): T

                fun visitNewSubscriptionTieredPackagePrice(
                    newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                ): T

                fun visitNewSubscriptionTieredWithMinimumPrice(
                    newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                ): T

                fun visitNewSubscriptionUnitWithPercentPrice(
                    newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                ): T

                fun visitNewSubscriptionPackageWithAllocationPrice(
                    newSubscriptionPackageWithAllocationPrice:
                        NewSubscriptionPackageWithAllocationPrice
                ): T

                fun visitNewSubscriptionTierWithProrationPrice(
                    newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                ): T

                fun visitNewSubscriptionUnitWithProrationPrice(
                    newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                ): T

                fun visitNewSubscriptionGroupedAllocationPrice(
                    newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                ): T

                fun visitNewSubscriptionGroupedWithProratedMinimumPrice(
                    newSubscriptionGroupedWithProratedMinimumPrice:
                        NewSubscriptionGroupedWithProratedMinimumPrice
                ): T

                fun visitNewSubscriptionBulkWithProrationPrice(
                    newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                ): T

                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown Price: $json")
                }
            }

            class Deserializer : BaseDeserializer<Price>(Price::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): Price {
                    val json = JsonValue.fromJsonNode(node)
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionPackagePrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionMatrixPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionMatrixPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkBpsPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionThresholdTotalAmountPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionThresholdTotalAmountPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredPackagePrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTieredWithMinimumPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithPercentPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitWithPercentPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionPackageWithAllocationPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionPackageWithAllocationPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTierWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionTierWithProrationPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionUnitWithProrationPrice = it, _json = json)
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionGroupedAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionGroupedAllocationPrice = it, _json = json)
                        }
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionGroupedWithProratedMinimumPrice>()
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return Price(
                                newSubscriptionGroupedWithProratedMinimumPrice = it,
                                _json = json
                            )
                        }
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(newSubscriptionBulkWithProrationPrice = it, _json = json)
                        }

                    return Price(_json = json)
                }
            }

            class Serializer : BaseSerializer<Price>(Price::class) {

                override fun serialize(
                    value: Price,
                    generator: JsonGenerator,
                    provider: SerializerProvider
                ) {
                    when {
                        value.newSubscriptionUnitPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitPrice)
                        value.newSubscriptionPackagePrice != null ->
                            generator.writeObject(value.newSubscriptionPackagePrice)
                        value.newSubscriptionMatrixPrice != null ->
                            generator.writeObject(value.newSubscriptionMatrixPrice)
                        value.newSubscriptionTieredPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredPrice)
                        value.newSubscriptionTieredBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredBpsPrice)
                        value.newSubscriptionBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionBpsPrice)
                        value.newSubscriptionBulkBpsPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkBpsPrice)
                        value.newSubscriptionBulkPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkPrice)
                        value.newSubscriptionThresholdTotalAmountPrice != null ->
                            generator.writeObject(value.newSubscriptionThresholdTotalAmountPrice)
                        value.newSubscriptionTieredPackagePrice != null ->
                            generator.writeObject(value.newSubscriptionTieredPackagePrice)
                        value.newSubscriptionTieredWithMinimumPrice != null ->
                            generator.writeObject(value.newSubscriptionTieredWithMinimumPrice)
                        value.newSubscriptionUnitWithPercentPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitWithPercentPrice)
                        value.newSubscriptionPackageWithAllocationPrice != null ->
                            generator.writeObject(value.newSubscriptionPackageWithAllocationPrice)
                        value.newSubscriptionTierWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionTierWithProrationPrice)
                        value.newSubscriptionUnitWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionUnitWithProrationPrice)
                        value.newSubscriptionGroupedAllocationPrice != null ->
                            generator.writeObject(value.newSubscriptionGroupedAllocationPrice)
                        value.newSubscriptionGroupedWithProratedMinimumPrice != null ->
                            generator.writeObject(
                                value.newSubscriptionGroupedWithProratedMinimumPrice
                            )
                        value.newSubscriptionBulkWithProrationPrice != null ->
                            generator.writeObject(value.newSubscriptionBulkWithProrationPrice)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid Price")
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitConfig: JsonField<UnitConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_config") @ExcludeMissing fun _unitConfig() = unitConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitConfig == other.unitConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitConfig=$unitConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitConfig: JsonField<UnitConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionUnitPrice: NewSubscriptionUnitPrice) = apply {
                        this.metadata = newSubscriptionUnitPrice.metadata
                        this.externalPriceId = newSubscriptionUnitPrice.externalPriceId
                        this.name = newSubscriptionUnitPrice.name
                        this.billableMetricId = newSubscriptionUnitPrice.billableMetricId
                        this.itemId = newSubscriptionUnitPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionUnitPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionUnitPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitPrice.conversionRate
                        this.modelType = newSubscriptionUnitPrice.modelType
                        this.unitConfig = newSubscriptionUnitPrice.unitConfig
                        this.currency = newSubscriptionUnitPrice.currency
                        additionalProperties(newSubscriptionUnitPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

                    @JsonProperty("unit_config")
                    @ExcludeMissing
                    fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                        this.unitConfig = unitConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitPrice =
                        NewSubscriptionUnitPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val UNIT = ModelType(JsonField.of("unit"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT,
                    }

                    enum class Value {
                        UNIT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT -> Value.UNIT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT -> Known.UNIT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitConfig.Builder::class)
                @NoAutoDetect
                class UnitConfig
                private constructor(
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Rate per unit of usage */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Rate per unit of usage */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitConfig = apply {
                        if (!validated) {
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitConfig &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(unitAmount, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitConfig: UnitConfig) = apply {
                            this.unitAmount = unitConfig.unitAmount
                            additionalProperties(unitConfig.additionalProperties)
                        }

                        /** Rate per unit of usage */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Rate per unit of usage */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitConfig =
                            UnitConfig(unitAmount, additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionPackagePrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionPackagePrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val packageConfig: JsonField<PackageConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("package_config") @ExcludeMissing fun _packageConfig() = packageConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionPackagePrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        packageConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionPackagePrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.packageConfig == other.packageConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                packageConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageConfig=$packageConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var packageConfig: JsonField<PackageConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionPackagePrice: NewSubscriptionPackagePrice) =
                        apply {
                            this.metadata = newSubscriptionPackagePrice.metadata
                            this.externalPriceId = newSubscriptionPackagePrice.externalPriceId
                            this.name = newSubscriptionPackagePrice.name
                            this.billableMetricId = newSubscriptionPackagePrice.billableMetricId
                            this.itemId = newSubscriptionPackagePrice.itemId
                            this.billedInAdvance = newSubscriptionPackagePrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionPackagePrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionPackagePrice.invoiceGroupingKey
                            this.cadence = newSubscriptionPackagePrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionPackagePrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionPackagePrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionPackagePrice.conversionRate
                            this.modelType = newSubscriptionPackagePrice.modelType
                            this.packageConfig = newSubscriptionPackagePrice.packageConfig
                            this.currency = newSubscriptionPackagePrice.currency
                            additionalProperties(newSubscriptionPackagePrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun packageConfig(packageConfig: PackageConfig) =
                        packageConfig(JsonField.of(packageConfig))

                    @JsonProperty("package_config")
                    @ExcludeMissing
                    fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                        this.packageConfig = packageConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionPackagePrice =
                        NewSubscriptionPackagePrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            packageConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val PACKAGE = ModelType(JsonField.of("package"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        PACKAGE,
                    }

                    enum class Value {
                        PACKAGE,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PACKAGE -> Value.PACKAGE
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PACKAGE -> Known.PACKAGE
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = PackageConfig.Builder::class)
                @NoAutoDetect
                class PackageConfig
                private constructor(
                    private val packageAmount: JsonField<String>,
                    private val packageSize: JsonField<Long>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** A currency amount to rate usage by */
                    fun packageAmount(): String = packageAmount.getRequired("package_amount")

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(): Long = packageSize.getRequired("package_size")

                    /** A currency amount to rate usage by */
                    @JsonProperty("package_amount")
                    @ExcludeMissing
                    fun _packageAmount() = packageAmount

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    @JsonProperty("package_size") @ExcludeMissing fun _packageSize() = packageSize

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): PackageConfig = apply {
                        if (!validated) {
                            packageAmount()
                            packageSize()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PackageConfig &&
                            this.packageAmount == other.packageAmount &&
                            this.packageSize == other.packageSize &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    packageAmount,
                                    packageSize,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var packageAmount: JsonField<String> = JsonMissing.of()
                        private var packageSize: JsonField<Long> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(packageConfig: PackageConfig) = apply {
                            this.packageAmount = packageConfig.packageAmount
                            this.packageSize = packageConfig.packageSize
                            additionalProperties(packageConfig.additionalProperties)
                        }

                        /** A currency amount to rate usage by */
                        fun packageAmount(packageAmount: String) =
                            packageAmount(JsonField.of(packageAmount))

                        /** A currency amount to rate usage by */
                        @JsonProperty("package_amount")
                        @ExcludeMissing
                        fun packageAmount(packageAmount: JsonField<String>) = apply {
                            this.packageAmount = packageAmount
                        }

                        /**
                         * An integer amount to represent package size. For example, 1000 here would
                         * divide usage by 1000 before multiplying by package_amount in rating
                         */
                        fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                        /**
                         * An integer amount to represent package size. For example, 1000 here would
                         * divide usage by 1000 before multiplying by package_amount in rating
                         */
                        @JsonProperty("package_size")
                        @ExcludeMissing
                        fun packageSize(packageSize: JsonField<Long>) = apply {
                            this.packageSize = packageSize
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): PackageConfig =
                            PackageConfig(
                                packageAmount,
                                packageSize,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionMatrixPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionMatrixPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val matrixConfig: JsonField<MatrixConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("matrix_config") @ExcludeMissing fun _matrixConfig() = matrixConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionMatrixPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        matrixConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionMatrixPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.matrixConfig == other.matrixConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                matrixConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionMatrixPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, matrixConfig=$matrixConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var matrixConfig: JsonField<MatrixConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice) =
                        apply {
                            this.metadata = newSubscriptionMatrixPrice.metadata
                            this.externalPriceId = newSubscriptionMatrixPrice.externalPriceId
                            this.name = newSubscriptionMatrixPrice.name
                            this.billableMetricId = newSubscriptionMatrixPrice.billableMetricId
                            this.itemId = newSubscriptionMatrixPrice.itemId
                            this.billedInAdvance = newSubscriptionMatrixPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionMatrixPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionMatrixPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionMatrixPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionMatrixPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionMatrixPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionMatrixPrice.conversionRate
                            this.modelType = newSubscriptionMatrixPrice.modelType
                            this.matrixConfig = newSubscriptionMatrixPrice.matrixConfig
                            this.currency = newSubscriptionMatrixPrice.currency
                            additionalProperties(newSubscriptionMatrixPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun matrixConfig(matrixConfig: MatrixConfig) =
                        matrixConfig(JsonField.of(matrixConfig))

                    @JsonProperty("matrix_config")
                    @ExcludeMissing
                    fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                        this.matrixConfig = matrixConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionMatrixPrice =
                        NewSubscriptionMatrixPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            matrixConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = MatrixConfig.Builder::class)
                @NoAutoDetect
                class MatrixConfig
                private constructor(
                    private val dimensions: JsonField<List<String?>>,
                    private val defaultUnitAmount: JsonField<String>,
                    private val matrixValues: JsonField<List<MatrixValue>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(): String =
                        defaultUnitAmount.getRequired("default_unit_amount")

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(): List<MatrixValue> =
                        matrixValues.getRequired("matrix_values")

                    /** One or two event property values to evaluate matrix groups by */
                    @JsonProperty("dimensions") @ExcludeMissing fun _dimensions() = dimensions

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    @JsonProperty("default_unit_amount")
                    @ExcludeMissing
                    fun _defaultUnitAmount() = defaultUnitAmount

                    /** Matrix values for specified matrix grouping keys */
                    @JsonProperty("matrix_values")
                    @ExcludeMissing
                    fun _matrixValues() = matrixValues

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): MatrixConfig = apply {
                        if (!validated) {
                            dimensions()
                            defaultUnitAmount()
                            matrixValues().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MatrixConfig &&
                            this.dimensions == other.dimensions &&
                            this.defaultUnitAmount == other.defaultUnitAmount &&
                            this.matrixValues == other.matrixValues &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    dimensions,
                                    defaultUnitAmount,
                                    matrixValues,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "MatrixConfig{dimensions=$dimensions, defaultUnitAmount=$defaultUnitAmount, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var dimensions: JsonField<List<String?>> = JsonMissing.of()
                        private var defaultUnitAmount: JsonField<String> = JsonMissing.of()
                        private var matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixConfig: MatrixConfig) = apply {
                            this.dimensions = matrixConfig.dimensions
                            this.defaultUnitAmount = matrixConfig.defaultUnitAmount
                            this.matrixValues = matrixConfig.matrixValues
                            additionalProperties(matrixConfig.additionalProperties)
                        }

                        /** One or two event property values to evaluate matrix groups by */
                        fun dimensions(dimensions: List<String?>) =
                            dimensions(JsonField.of(dimensions))

                        /** One or two event property values to evaluate matrix groups by */
                        @JsonProperty("dimensions")
                        @ExcludeMissing
                        fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                            this.dimensions = dimensions
                        }

                        /**
                         * Default per unit rate for any usage not bucketed into a specified
                         * matrix_value
                         */
                        fun defaultUnitAmount(defaultUnitAmount: String) =
                            defaultUnitAmount(JsonField.of(defaultUnitAmount))

                        /**
                         * Default per unit rate for any usage not bucketed into a specified
                         * matrix_value
                         */
                        @JsonProperty("default_unit_amount")
                        @ExcludeMissing
                        fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                            this.defaultUnitAmount = defaultUnitAmount
                        }

                        /** Matrix values for specified matrix grouping keys */
                        fun matrixValues(matrixValues: List<MatrixValue>) =
                            matrixValues(JsonField.of(matrixValues))

                        /** Matrix values for specified matrix grouping keys */
                        @JsonProperty("matrix_values")
                        @ExcludeMissing
                        fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                            this.matrixValues = matrixValues
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): MatrixConfig =
                            MatrixConfig(
                                dimensions.map { it.toUnmodifiable() },
                                defaultUnitAmount,
                                matrixValues.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    @JsonDeserialize(builder = MatrixValue.Builder::class)
                    @NoAutoDetect
                    class MatrixValue
                    private constructor(
                        private val unitAmount: JsonField<String>,
                        private val dimensionValues: JsonField<List<String?>>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(): List<String?> =
                            dimensionValues.getRequired("dimension_values")

                        /** Unit price for the specified dimension_values */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        @JsonProperty("dimension_values")
                        @ExcludeMissing
                        fun _dimensionValues() = dimensionValues

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): MatrixValue = apply {
                            if (!validated) {
                                unitAmount()
                                dimensionValues()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MatrixValue &&
                                this.unitAmount == other.unitAmount &&
                                this.dimensionValues == other.dimensionValues &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        unitAmount,
                                        dimensionValues,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "MatrixValue{unitAmount=$unitAmount, dimensionValues=$dimensionValues, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var dimensionValues: JsonField<List<String?>> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(matrixValue: MatrixValue) = apply {
                                this.unitAmount = matrixValue.unitAmount
                                this.dimensionValues = matrixValue.dimensionValues
                                additionalProperties(matrixValue.additionalProperties)
                            }

                            /** Unit price for the specified dimension_values */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Unit price for the specified dimension_values */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            /**
                             * One or two matrix keys to filter usage to this Matrix value by. For
                             * example, ["region", "tier"] could be used to filter cloud usage by a
                             * cloud region and an instance tier.
                             */
                            fun dimensionValues(dimensionValues: List<String?>) =
                                dimensionValues(JsonField.of(dimensionValues))

                            /**
                             * One or two matrix keys to filter usage to this Matrix value by. For
                             * example, ["region", "tier"] could be used to filter cloud usage by a
                             * cloud region and an instance tier.
                             */
                            @JsonProperty("dimension_values")
                            @ExcludeMissing
                            fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                                this.dimensionValues = dimensionValues
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): MatrixValue =
                                MatrixValue(
                                    unitAmount,
                                    dimensionValues.map { it.toUnmodifiable() },
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val MATRIX = ModelType(JsonField.of("matrix"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        MATRIX,
                    }

                    enum class Value {
                        MATRIX,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            MATRIX -> Value.MATRIX
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            MATRIX -> Known.MATRIX
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredConfig: JsonField<TieredConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_config") @ExcludeMissing fun _tieredConfig() = tieredConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredConfig == other.tieredConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredConfig=$tieredConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredConfig: JsonField<TieredConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionTieredPrice: NewSubscriptionTieredPrice) =
                        apply {
                            this.metadata = newSubscriptionTieredPrice.metadata
                            this.externalPriceId = newSubscriptionTieredPrice.externalPriceId
                            this.name = newSubscriptionTieredPrice.name
                            this.billableMetricId = newSubscriptionTieredPrice.billableMetricId
                            this.itemId = newSubscriptionTieredPrice.itemId
                            this.billedInAdvance = newSubscriptionTieredPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionTieredPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionTieredPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionTieredPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionTieredPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionTieredPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionTieredPrice.conversionRate
                            this.modelType = newSubscriptionTieredPrice.modelType
                            this.tieredConfig = newSubscriptionTieredPrice.tieredConfig
                            this.currency = newSubscriptionTieredPrice.currency
                            additionalProperties(newSubscriptionTieredPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredConfig(tieredConfig: TieredConfig) =
                        tieredConfig(JsonField.of(tieredConfig))

                    @JsonProperty("tiered_config")
                    @ExcludeMissing
                    fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                        this.tieredConfig = tieredConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredPrice =
                        NewSubscriptionTieredPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED = ModelType(JsonField.of("tiered"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED,
                    }

                    enum class Value {
                        TIERED,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED -> Value.TIERED
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED -> Known.TIERED
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredConfig.Builder::class)
                @NoAutoDetect
                class TieredConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredConfig: TieredConfig) = apply {
                            this.tiers = tieredConfig.tiers
                            additionalProperties(tieredConfig.additionalProperties)
                        }

                        /**
                         * Tiers for rating based on total usage quantities into the specified tier
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for rating based on total usage quantities into the specified tier
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredConfig =
                            TieredConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val firstUnit: JsonField<Double>,
                        private val lastUnit: JsonField<Double>,
                        private val unitAmount: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Inclusive tier starting value */
                        fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(): Optional<Double> =
                            Optional.ofNullable(lastUnit.getNullable("last_unit"))

                        /** Amount per unit */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /** Inclusive tier starting value */
                        @JsonProperty("first_unit") @ExcludeMissing fun _firstUnit() = firstUnit

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @JsonProperty("last_unit") @ExcludeMissing fun _lastUnit() = lastUnit

                        /** Amount per unit */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                firstUnit()
                                lastUnit()
                                unitAmount()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.firstUnit == other.firstUnit &&
                                this.lastUnit == other.lastUnit &&
                                this.unitAmount == other.unitAmount &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        firstUnit,
                                        lastUnit,
                                        unitAmount,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{firstUnit=$firstUnit, lastUnit=$lastUnit, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var firstUnit: JsonField<Double> = JsonMissing.of()
                            private var lastUnit: JsonField<Double> = JsonMissing.of()
                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.firstUnit = tier.firstUnit
                                this.lastUnit = tier.lastUnit
                                this.unitAmount = tier.unitAmount
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Inclusive tier starting value */
                            fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                            /** Inclusive tier starting value */
                            @JsonProperty("first_unit")
                            @ExcludeMissing
                            fun firstUnit(firstUnit: JsonField<Double>) = apply {
                                this.firstUnit = firstUnit
                            }

                            /**
                             * Exclusive tier ending value. If null, this is treated as the last
                             * tier
                             */
                            fun lastUnit(lastUnit: Double) = lastUnit(JsonField.of(lastUnit))

                            /**
                             * Exclusive tier ending value. If null, this is treated as the last
                             * tier
                             */
                            @JsonProperty("last_unit")
                            @ExcludeMissing
                            fun lastUnit(lastUnit: JsonField<Double>) = apply {
                                this.lastUnit = lastUnit
                            }

                            /** Amount per unit */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Amount per unit */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    firstUnit,
                                    lastUnit,
                                    unitAmount,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredBpsConfig: JsonField<TieredBpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredBpsConfig(): TieredBpsConfig =
                    tieredBpsConfig.getRequired("tiered_bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_bps_config")
                @ExcludeMissing
                fun _tieredBpsConfig() = tieredBpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredBpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredBpsConfig == other.tieredBpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredBpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredBpsConfig=$tieredBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredBpsPrice.metadata
                        this.externalPriceId = newSubscriptionTieredBpsPrice.externalPriceId
                        this.name = newSubscriptionTieredBpsPrice.name
                        this.billableMetricId = newSubscriptionTieredBpsPrice.billableMetricId
                        this.itemId = newSubscriptionTieredBpsPrice.itemId
                        this.billedInAdvance = newSubscriptionTieredBpsPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionTieredBpsPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionTieredBpsPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredBpsPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredBpsPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredBpsPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredBpsPrice.conversionRate
                        this.modelType = newSubscriptionTieredBpsPrice.modelType
                        this.tieredBpsConfig = newSubscriptionTieredBpsPrice.tieredBpsConfig
                        this.currency = newSubscriptionTieredBpsPrice.currency
                        additionalProperties(newSubscriptionTieredBpsPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                        tieredBpsConfig(JsonField.of(tieredBpsConfig))

                    @JsonProperty("tiered_bps_config")
                    @ExcludeMissing
                    fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                        this.tieredBpsConfig = tieredBpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredBpsPrice =
                        NewSubscriptionTieredBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredBpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED_BPS = ModelType(JsonField.of("tiered_bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_BPS,
                    }

                    enum class Value {
                        TIERED_BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_BPS -> Value.TIERED_BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_BPS -> Known.TIERED_BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredBpsConfig.Builder::class)
                @NoAutoDetect
                class TieredBpsConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredBpsConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredBpsConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                            this.tiers = tieredBpsConfig.tiers
                            additionalProperties(tieredBpsConfig.additionalProperties)
                        }

                        /**
                         * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                         * specified tiers
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                         * specified tiers
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredBpsConfig =
                            TieredBpsConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val minimumAmount: JsonField<String>,
                        private val maximumAmount: JsonField<String>,
                        private val bps: JsonField<Double>,
                        private val perUnitMaximum: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Inclusive tier starting value */
                        fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                        /** Exclusive tier ending value */
                        fun maximumAmount(): Optional<String> =
                            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                        /** Per-event basis point rate */
                        fun bps(): Double = bps.getRequired("bps")

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(): Optional<String> =
                            Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                        /** Inclusive tier starting value */
                        @JsonProperty("minimum_amount")
                        @ExcludeMissing
                        fun _minimumAmount() = minimumAmount

                        /** Exclusive tier ending value */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun _maximumAmount() = maximumAmount

                        /** Per-event basis point rate */
                        @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                        /** Per unit maximum to charge */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun _perUnitMaximum() = perUnitMaximum

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                minimumAmount()
                                maximumAmount()
                                bps()
                                perUnitMaximum()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.minimumAmount == other.minimumAmount &&
                                this.maximumAmount == other.maximumAmount &&
                                this.bps == other.bps &&
                                this.perUnitMaximum == other.perUnitMaximum &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        minimumAmount,
                                        maximumAmount,
                                        bps,
                                        perUnitMaximum,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var minimumAmount: JsonField<String> = JsonMissing.of()
                            private var maximumAmount: JsonField<String> = JsonMissing.of()
                            private var bps: JsonField<Double> = JsonMissing.of()
                            private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.minimumAmount = tier.minimumAmount
                                this.maximumAmount = tier.maximumAmount
                                this.bps = tier.bps
                                this.perUnitMaximum = tier.perUnitMaximum
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Inclusive tier starting value */
                            fun minimumAmount(minimumAmount: String) =
                                minimumAmount(JsonField.of(minimumAmount))

                            /** Inclusive tier starting value */
                            @JsonProperty("minimum_amount")
                            @ExcludeMissing
                            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                                this.minimumAmount = minimumAmount
                            }

                            /** Exclusive tier ending value */
                            fun maximumAmount(maximumAmount: String) =
                                maximumAmount(JsonField.of(maximumAmount))

                            /** Exclusive tier ending value */
                            @JsonProperty("maximum_amount")
                            @ExcludeMissing
                            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                                this.maximumAmount = maximumAmount
                            }

                            /** Per-event basis point rate */
                            fun bps(bps: Double) = bps(JsonField.of(bps))

                            /** Per-event basis point rate */
                            @JsonProperty("bps")
                            @ExcludeMissing
                            fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                            /** Per unit maximum to charge */
                            fun perUnitMaximum(perUnitMaximum: String) =
                                perUnitMaximum(JsonField.of(perUnitMaximum))

                            /** Per unit maximum to charge */
                            @JsonProperty("per_unit_maximum")
                            @ExcludeMissing
                            fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                                this.perUnitMaximum = perUnitMaximum
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    minimumAmount,
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bpsConfig: JsonField<BpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bps_config") @ExcludeMissing fun _bpsConfig() = bpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bpsConfig == other.bpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bpsConfig=$bpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bpsConfig: JsonField<BpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBpsPrice: NewSubscriptionBpsPrice) = apply {
                        this.metadata = newSubscriptionBpsPrice.metadata
                        this.externalPriceId = newSubscriptionBpsPrice.externalPriceId
                        this.name = newSubscriptionBpsPrice.name
                        this.billableMetricId = newSubscriptionBpsPrice.billableMetricId
                        this.itemId = newSubscriptionBpsPrice.itemId
                        this.billedInAdvance = newSubscriptionBpsPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionBpsPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionBpsPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBpsPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBpsPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBpsPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBpsPrice.conversionRate
                        this.modelType = newSubscriptionBpsPrice.modelType
                        this.bpsConfig = newSubscriptionBpsPrice.bpsConfig
                        this.currency = newSubscriptionBpsPrice.currency
                        additionalProperties(newSubscriptionBpsPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

                    @JsonProperty("bps_config")
                    @ExcludeMissing
                    fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply {
                        this.bpsConfig = bpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBpsPrice =
                        NewSubscriptionBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BpsConfig.Builder::class)
                @NoAutoDetect
                class BpsConfig
                private constructor(
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Basis point take rate per event */
                    fun bps(): Double = bps.getRequired("bps")

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Basis point take rate per event */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** Optional currency amount maximum to cap spend per event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BpsConfig = apply {
                        if (!validated) {
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BpsConfig &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bpsConfig: BpsConfig) = apply {
                            this.bps = bpsConfig.bps
                            this.perUnitMaximum = bpsConfig.perUnitMaximum
                            additionalProperties(bpsConfig.additionalProperties)
                        }

                        /** Basis point take rate per event */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Basis point take rate per event */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** Optional currency amount maximum to cap spend per event */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** Optional currency amount maximum to cap spend per event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BpsConfig =
                            BpsConfig(
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BPS = ModelType(JsonField.of("bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BPS,
                    }

                    enum class Value {
                        BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BPS -> Value.BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BPS -> Known.BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkBpsPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkBpsPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkBpsConfig: JsonField<BulkBpsConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_bps_config")
                @ExcludeMissing
                fun _bulkBpsConfig() = bulkBpsConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkBpsPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkBpsConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkBpsPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkBpsConfig == other.bulkBpsConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkBpsConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkBpsConfig=$bulkBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice) =
                        apply {
                            this.metadata = newSubscriptionBulkBpsPrice.metadata
                            this.externalPriceId = newSubscriptionBulkBpsPrice.externalPriceId
                            this.name = newSubscriptionBulkBpsPrice.name
                            this.billableMetricId = newSubscriptionBulkBpsPrice.billableMetricId
                            this.itemId = newSubscriptionBulkBpsPrice.itemId
                            this.billedInAdvance = newSubscriptionBulkBpsPrice.billedInAdvance
                            this.fixedPriceQuantity = newSubscriptionBulkBpsPrice.fixedPriceQuantity
                            this.invoiceGroupingKey = newSubscriptionBulkBpsPrice.invoiceGroupingKey
                            this.cadence = newSubscriptionBulkBpsPrice.cadence
                            this.billingCycleConfiguration =
                                newSubscriptionBulkBpsPrice.billingCycleConfiguration
                            this.invoicingCycleConfiguration =
                                newSubscriptionBulkBpsPrice.invoicingCycleConfiguration
                            this.conversionRate = newSubscriptionBulkBpsPrice.conversionRate
                            this.modelType = newSubscriptionBulkBpsPrice.modelType
                            this.bulkBpsConfig = newSubscriptionBulkBpsPrice.bulkBpsConfig
                            this.currency = newSubscriptionBulkBpsPrice.currency
                            additionalProperties(newSubscriptionBulkBpsPrice.additionalProperties)
                        }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                        bulkBpsConfig(JsonField.of(bulkBpsConfig))

                    @JsonProperty("bulk_bps_config")
                    @ExcludeMissing
                    fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                        this.bulkBpsConfig = bulkBpsConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkBpsPrice =
                        NewSubscriptionBulkBpsPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkBpsConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkBpsConfig.Builder::class)
                @NoAutoDetect
                class BulkBpsConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkBpsConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkBpsConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                            this.tiers = bulkBpsConfig.tiers
                            additionalProperties(bulkBpsConfig.additionalProperties)
                        }

                        /**
                         * Tiers for a bulk BPS pricing model where all usage is aggregated to a
                         * single tier based on total volume
                         */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /**
                         * Tiers for a bulk BPS pricing model where all usage is aggregated to a
                         * single tier based on total volume
                         */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkBpsConfig =
                            BulkBpsConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val maximumAmount: JsonField<String>,
                        private val bps: JsonField<Double>,
                        private val perUnitMaximum: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Upper bound for tier */
                        fun maximumAmount(): Optional<String> =
                            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                        /** Basis points to rate on */
                        fun bps(): Double = bps.getRequired("bps")

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(): Optional<String> =
                            Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                        /** Upper bound for tier */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun _maximumAmount() = maximumAmount

                        /** Basis points to rate on */
                        @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                        /** The maximum amount to charge for any one event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun _perUnitMaximum() = perUnitMaximum

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                maximumAmount()
                                bps()
                                perUnitMaximum()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.maximumAmount == other.maximumAmount &&
                                this.bps == other.bps &&
                                this.perUnitMaximum == other.perUnitMaximum &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        maximumAmount,
                                        bps,
                                        perUnitMaximum,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var maximumAmount: JsonField<String> = JsonMissing.of()
                            private var bps: JsonField<Double> = JsonMissing.of()
                            private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.maximumAmount = tier.maximumAmount
                                this.bps = tier.bps
                                this.perUnitMaximum = tier.perUnitMaximum
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Upper bound for tier */
                            fun maximumAmount(maximumAmount: String) =
                                maximumAmount(JsonField.of(maximumAmount))

                            /** Upper bound for tier */
                            @JsonProperty("maximum_amount")
                            @ExcludeMissing
                            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                                this.maximumAmount = maximumAmount
                            }

                            /** Basis points to rate on */
                            fun bps(bps: Double) = bps(JsonField.of(bps))

                            /** Basis points to rate on */
                            @JsonProperty("bps")
                            @ExcludeMissing
                            fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                            /** The maximum amount to charge for any one event */
                            fun perUnitMaximum(perUnitMaximum: String) =
                                perUnitMaximum(JsonField.of(perUnitMaximum))

                            /** The maximum amount to charge for any one event */
                            @JsonProperty("per_unit_maximum")
                            @ExcludeMissing
                            fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                                this.perUnitMaximum = perUnitMaximum
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BULK_BPS = ModelType(JsonField.of("bulk_bps"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK_BPS,
                    }

                    enum class Value {
                        BULK_BPS,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK_BPS -> Value.BULK_BPS
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK_BPS -> Known.BULK_BPS
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkConfig: JsonField<BulkConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_config") @ExcludeMissing fun _bulkConfig() = bulkConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkConfig == other.bulkConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkConfig=$bulkConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkConfig: JsonField<BulkConfig> = JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(newSubscriptionBulkPrice: NewSubscriptionBulkPrice) = apply {
                        this.metadata = newSubscriptionBulkPrice.metadata
                        this.externalPriceId = newSubscriptionBulkPrice.externalPriceId
                        this.name = newSubscriptionBulkPrice.name
                        this.billableMetricId = newSubscriptionBulkPrice.billableMetricId
                        this.itemId = newSubscriptionBulkPrice.itemId
                        this.billedInAdvance = newSubscriptionBulkPrice.billedInAdvance
                        this.fixedPriceQuantity = newSubscriptionBulkPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newSubscriptionBulkPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBulkPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBulkPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBulkPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBulkPrice.conversionRate
                        this.modelType = newSubscriptionBulkPrice.modelType
                        this.bulkConfig = newSubscriptionBulkPrice.bulkConfig
                        this.currency = newSubscriptionBulkPrice.currency
                        additionalProperties(newSubscriptionBulkPrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

                    @JsonProperty("bulk_config")
                    @ExcludeMissing
                    fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                        this.bulkConfig = bulkConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkPrice =
                        NewSubscriptionBulkPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkConfig.Builder::class)
                @NoAutoDetect
                class BulkConfig
                private constructor(
                    private val tiers: JsonField<List<Tier>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(): List<Tier> = tiers.getRequired("tiers")

                    /** Bulk tiers for rating based on total usage volume */
                    @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkConfig = apply {
                        if (!validated) {
                            tiers().forEach { it.validate() }
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkConfig &&
                            this.tiers == other.tiers &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(tiers, additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkConfig: BulkConfig) = apply {
                            this.tiers = bulkConfig.tiers
                            additionalProperties(bulkConfig.additionalProperties)
                        }

                        /** Bulk tiers for rating based on total usage volume */
                        fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                        /** Bulk tiers for rating based on total usage volume */
                        @JsonProperty("tiers")
                        @ExcludeMissing
                        fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkConfig =
                            BulkConfig(
                                tiers.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable()
                            )
                    }

                    @JsonDeserialize(builder = Tier.Builder::class)
                    @NoAutoDetect
                    class Tier
                    private constructor(
                        private val maximumUnits: JsonField<Double>,
                        private val unitAmount: JsonField<String>,
                        private val additionalProperties: Map<String, JsonValue>,
                    ) {

                        private var validated: Boolean = false

                        private var hashCode: Int = 0

                        /** Upper bound for this tier */
                        fun maximumUnits(): Optional<Double> =
                            Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                        /** Amount per unit */
                        fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                        /** Upper bound for this tier */
                        @JsonProperty("maximum_units")
                        @ExcludeMissing
                        fun _maximumUnits() = maximumUnits

                        /** Amount per unit */
                        @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                        fun validate(): Tier = apply {
                            if (!validated) {
                                maximumUnits()
                                unitAmount()
                                validated = true
                            }
                        }

                        fun toBuilder() = Builder().from(this)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Tier &&
                                this.maximumUnits == other.maximumUnits &&
                                this.unitAmount == other.unitAmount &&
                                this.additionalProperties == other.additionalProperties
                        }

                        override fun hashCode(): Int {
                            if (hashCode == 0) {
                                hashCode =
                                    Objects.hash(
                                        maximumUnits,
                                        unitAmount,
                                        additionalProperties,
                                    )
                            }
                            return hashCode
                        }

                        override fun toString() =
                            "Tier{maximumUnits=$maximumUnits, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                        companion object {

                            @JvmStatic fun builder() = Builder()
                        }

                        class Builder {

                            private var maximumUnits: JsonField<Double> = JsonMissing.of()
                            private var unitAmount: JsonField<String> = JsonMissing.of()
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            @JvmSynthetic
                            internal fun from(tier: Tier) = apply {
                                this.maximumUnits = tier.maximumUnits
                                this.unitAmount = tier.unitAmount
                                additionalProperties(tier.additionalProperties)
                            }

                            /** Upper bound for this tier */
                            fun maximumUnits(maximumUnits: Double) =
                                maximumUnits(JsonField.of(maximumUnits))

                            /** Upper bound for this tier */
                            @JsonProperty("maximum_units")
                            @ExcludeMissing
                            fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                                this.maximumUnits = maximumUnits
                            }

                            /** Amount per unit */
                            fun unitAmount(unitAmount: String) =
                                unitAmount(JsonField.of(unitAmount))

                            /** Amount per unit */
                            @JsonProperty("unit_amount")
                            @ExcludeMissing
                            fun unitAmount(unitAmount: JsonField<String>) = apply {
                                this.unitAmount = unitAmount
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    this.additionalProperties.putAll(additionalProperties)
                                }

                            @JsonAnySetter
                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                this.additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun build(): Tier =
                                Tier(
                                    maximumUnits,
                                    unitAmount,
                                    additionalProperties.toUnmodifiable(),
                                )
                        }
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val BULK = ModelType(JsonField.of("bulk"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK,
                    }

                    enum class Value {
                        BULK,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK -> Value.BULK
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK -> Known.BULK
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionThresholdTotalAmountPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionThresholdTotalAmountPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                    thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("threshold_total_amount_config")
                @ExcludeMissing
                fun _thresholdTotalAmountConfig() = thresholdTotalAmountConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionThresholdTotalAmountPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        thresholdTotalAmountConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionThresholdTotalAmountPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.thresholdTotalAmountConfig == other.thresholdTotalAmountConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                thresholdTotalAmountConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionThresholdTotalAmountPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionThresholdTotalAmountPrice:
                            NewSubscriptionThresholdTotalAmountPrice
                    ) = apply {
                        this.metadata = newSubscriptionThresholdTotalAmountPrice.metadata
                        this.externalPriceId =
                            newSubscriptionThresholdTotalAmountPrice.externalPriceId
                        this.name = newSubscriptionThresholdTotalAmountPrice.name
                        this.billableMetricId =
                            newSubscriptionThresholdTotalAmountPrice.billableMetricId
                        this.itemId = newSubscriptionThresholdTotalAmountPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionThresholdTotalAmountPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionThresholdTotalAmountPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionThresholdTotalAmountPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionThresholdTotalAmountPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionThresholdTotalAmountPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionThresholdTotalAmountPrice.invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionThresholdTotalAmountPrice.conversionRate
                        this.modelType = newSubscriptionThresholdTotalAmountPrice.modelType
                        this.thresholdTotalAmountConfig =
                            newSubscriptionThresholdTotalAmountPrice.thresholdTotalAmountConfig
                        this.currency = newSubscriptionThresholdTotalAmountPrice.currency
                        additionalProperties(
                            newSubscriptionThresholdTotalAmountPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun thresholdTotalAmountConfig(
                        thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                    ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

                    @JsonProperty("threshold_total_amount_config")
                    @ExcludeMissing
                    fun thresholdTotalAmountConfig(
                        thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
                    ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionThresholdTotalAmountPrice =
                        NewSubscriptionThresholdTotalAmountPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            thresholdTotalAmountConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val THRESHOLD_TOTAL_AMOUNT =
                            ModelType(JsonField.of("threshold_total_amount"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        THRESHOLD_TOTAL_AMOUNT,
                    }

                    enum class Value {
                        THRESHOLD_TOTAL_AMOUNT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = ThresholdTotalAmountConfig.Builder::class)
                @NoAutoDetect
                class ThresholdTotalAmountConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): ThresholdTotalAmountConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ThresholdTotalAmountConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                            apply {
                                additionalProperties(
                                    thresholdTotalAmountConfig.additionalProperties
                                )
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): ThresholdTotalAmountConfig =
                            ThresholdTotalAmountConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredPackagePrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredPackagePrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredPackageConfig: JsonField<TieredPackageConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredPackageConfig(): TieredPackageConfig =
                    tieredPackageConfig.getRequired("tiered_package_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_package_config")
                @ExcludeMissing
                fun _tieredPackageConfig() = tieredPackageConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredPackagePrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredPackageConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredPackagePrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredPackageConfig == other.tieredPackageConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredPackageConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredPackageConfig=$tieredPackageConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredPackageConfig: JsonField<TieredPackageConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredPackagePrice.metadata
                        this.externalPriceId = newSubscriptionTieredPackagePrice.externalPriceId
                        this.name = newSubscriptionTieredPackagePrice.name
                        this.billableMetricId = newSubscriptionTieredPackagePrice.billableMetricId
                        this.itemId = newSubscriptionTieredPackagePrice.itemId
                        this.billedInAdvance = newSubscriptionTieredPackagePrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTieredPackagePrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTieredPackagePrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredPackagePrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredPackagePrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredPackagePrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredPackagePrice.conversionRate
                        this.modelType = newSubscriptionTieredPackagePrice.modelType
                        this.tieredPackageConfig =
                            newSubscriptionTieredPackagePrice.tieredPackageConfig
                        this.currency = newSubscriptionTieredPackagePrice.currency
                        additionalProperties(newSubscriptionTieredPackagePrice.additionalProperties)
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                        tieredPackageConfig(JsonField.of(tieredPackageConfig))

                    @JsonProperty("tiered_package_config")
                    @ExcludeMissing
                    fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) =
                        apply {
                            this.tieredPackageConfig = tieredPackageConfig
                        }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredPackagePrice =
                        NewSubscriptionTieredPackagePrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredPackageConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val TIERED_PACKAGE = ModelType(JsonField.of("tiered_package"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_PACKAGE,
                    }

                    enum class Value {
                        TIERED_PACKAGE,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_PACKAGE -> Value.TIERED_PACKAGE
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_PACKAGE -> Known.TIERED_PACKAGE
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredPackageConfig.Builder::class)
                @NoAutoDetect
                class TieredPackageConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredPackageConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredPackageConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredPackageConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                            additionalProperties(tieredPackageConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredPackageConfig =
                            TieredPackageConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTieredWithMinimumPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTieredWithMinimumPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
                    tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_with_minimum_config")
                @ExcludeMissing
                fun _tieredWithMinimumConfig() = tieredWithMinimumConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTieredWithMinimumPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredWithMinimumConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTieredWithMinimumPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredWithMinimumConfig == other.tieredWithMinimumConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredWithMinimumConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTieredWithMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithMinimumConfig=$tieredWithMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                    ) = apply {
                        this.metadata = newSubscriptionTieredWithMinimumPrice.metadata
                        this.externalPriceId = newSubscriptionTieredWithMinimumPrice.externalPriceId
                        this.name = newSubscriptionTieredWithMinimumPrice.name
                        this.billableMetricId =
                            newSubscriptionTieredWithMinimumPrice.billableMetricId
                        this.itemId = newSubscriptionTieredWithMinimumPrice.itemId
                        this.billedInAdvance = newSubscriptionTieredWithMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTieredWithMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTieredWithMinimumPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTieredWithMinimumPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTieredWithMinimumPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTieredWithMinimumPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTieredWithMinimumPrice.conversionRate
                        this.modelType = newSubscriptionTieredWithMinimumPrice.modelType
                        this.tieredWithMinimumConfig =
                            newSubscriptionTieredWithMinimumPrice.tieredWithMinimumConfig
                        this.currency = newSubscriptionTieredWithMinimumPrice.currency
                        additionalProperties(
                            newSubscriptionTieredWithMinimumPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                        tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

                    @JsonProperty("tiered_with_minimum_config")
                    @ExcludeMissing
                    fun tieredWithMinimumConfig(
                        tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
                    ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTieredWithMinimumPrice =
                        NewSubscriptionTieredWithMinimumPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredWithMinimumConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val TIERED_WITH_MINIMUM = ModelType(JsonField.of("tiered_with_minimum"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_WITH_MINIMUM,
                    }

                    enum class Value {
                        TIERED_WITH_MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredWithMinimumConfig.Builder::class)
                @NoAutoDetect
                class TieredWithMinimumConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredWithMinimumConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredWithMinimumConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                            apply {
                                additionalProperties(tieredWithMinimumConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredWithMinimumConfig =
                            TieredWithMinimumConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitWithPercentPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitWithPercentPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitWithPercentConfig(): UnitWithPercentConfig =
                    unitWithPercentConfig.getRequired("unit_with_percent_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_with_percent_config")
                @ExcludeMissing
                fun _unitWithPercentConfig() = unitWithPercentConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitWithPercentPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitWithPercentConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitWithPercentPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitWithPercentConfig == other.unitWithPercentConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitWithPercentConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitWithPercentPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithPercentConfig=$unitWithPercentConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitWithPercentConfig: JsonField<UnitWithPercentConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                    ) = apply {
                        this.metadata = newSubscriptionUnitWithPercentPrice.metadata
                        this.externalPriceId = newSubscriptionUnitWithPercentPrice.externalPriceId
                        this.name = newSubscriptionUnitWithPercentPrice.name
                        this.billableMetricId = newSubscriptionUnitWithPercentPrice.billableMetricId
                        this.itemId = newSubscriptionUnitWithPercentPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitWithPercentPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionUnitWithPercentPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionUnitWithPercentPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitWithPercentPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitWithPercentPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitWithPercentPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitWithPercentPrice.conversionRate
                        this.modelType = newSubscriptionUnitWithPercentPrice.modelType
                        this.unitWithPercentConfig =
                            newSubscriptionUnitWithPercentPrice.unitWithPercentConfig
                        this.currency = newSubscriptionUnitWithPercentPrice.currency
                        additionalProperties(
                            newSubscriptionUnitWithPercentPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                        unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

                    @JsonProperty("unit_with_percent_config")
                    @ExcludeMissing
                    fun unitWithPercentConfig(
                        unitWithPercentConfig: JsonField<UnitWithPercentConfig>
                    ) = apply { this.unitWithPercentConfig = unitWithPercentConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitWithPercentPrice =
                        NewSubscriptionUnitWithPercentPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitWithPercentConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val UNIT_WITH_PERCENT = ModelType(JsonField.of("unit_with_percent"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT_WITH_PERCENT,
                    }

                    enum class Value {
                        UNIT_WITH_PERCENT,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitWithPercentConfig.Builder::class)
                @NoAutoDetect
                class UnitWithPercentConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitWithPercentConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitWithPercentConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitWithPercentConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                            additionalProperties(unitWithPercentConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitWithPercentConfig =
                            UnitWithPercentConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionPackageWithAllocationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionPackageWithAllocationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                    packageWithAllocationConfig.getRequired("package_with_allocation_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("package_with_allocation_config")
                @ExcludeMissing
                fun _packageWithAllocationConfig() = packageWithAllocationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionPackageWithAllocationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        packageWithAllocationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionPackageWithAllocationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.packageWithAllocationConfig == other.packageWithAllocationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                packageWithAllocationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionPackageWithAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageWithAllocationConfig=$packageWithAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var packageWithAllocationConfig:
                        JsonField<PackageWithAllocationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionPackageWithAllocationPrice:
                            NewSubscriptionPackageWithAllocationPrice
                    ) = apply {
                        this.metadata = newSubscriptionPackageWithAllocationPrice.metadata
                        this.externalPriceId =
                            newSubscriptionPackageWithAllocationPrice.externalPriceId
                        this.name = newSubscriptionPackageWithAllocationPrice.name
                        this.billableMetricId =
                            newSubscriptionPackageWithAllocationPrice.billableMetricId
                        this.itemId = newSubscriptionPackageWithAllocationPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionPackageWithAllocationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionPackageWithAllocationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionPackageWithAllocationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionPackageWithAllocationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionPackageWithAllocationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionPackageWithAllocationPrice.invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionPackageWithAllocationPrice.conversionRate
                        this.modelType = newSubscriptionPackageWithAllocationPrice.modelType
                        this.packageWithAllocationConfig =
                            newSubscriptionPackageWithAllocationPrice.packageWithAllocationConfig
                        this.currency = newSubscriptionPackageWithAllocationPrice.currency
                        additionalProperties(
                            newSubscriptionPackageWithAllocationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun packageWithAllocationConfig(
                        packageWithAllocationConfig: PackageWithAllocationConfig
                    ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

                    @JsonProperty("package_with_allocation_config")
                    @ExcludeMissing
                    fun packageWithAllocationConfig(
                        packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
                    ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionPackageWithAllocationPrice =
                        NewSubscriptionPackageWithAllocationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            packageWithAllocationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val PACKAGE_WITH_ALLOCATION =
                            ModelType(JsonField.of("package_with_allocation"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        PACKAGE_WITH_ALLOCATION,
                    }

                    enum class Value {
                        PACKAGE_WITH_ALLOCATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = PackageWithAllocationConfig.Builder::class)
                @NoAutoDetect
                class PackageWithAllocationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): PackageWithAllocationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PackageWithAllocationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            packageWithAllocationConfig: PackageWithAllocationConfig
                        ) = apply {
                            additionalProperties(packageWithAllocationConfig.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): PackageWithAllocationConfig =
                            PackageWithAllocationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionTierWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionTierWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun tieredWithProrationConfig(): TieredWithProrationConfig =
                    tieredWithProrationConfig.getRequired("tiered_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("tiered_with_proration_config")
                @ExcludeMissing
                fun _tieredWithProrationConfig() = tieredWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionTierWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        tieredWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionTierWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.tieredWithProrationConfig == other.tieredWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                tieredWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionTierWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithProrationConfig=$tieredWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionTierWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionTierWithProrationPrice.externalPriceId
                        this.name = newSubscriptionTierWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionTierWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionTierWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionTierWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionTierWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionTierWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionTierWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionTierWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionTierWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionTierWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionTierWithProrationPrice.modelType
                        this.tieredWithProrationConfig =
                            newSubscriptionTierWithProrationPrice.tieredWithProrationConfig
                        this.currency = newSubscriptionTierWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionTierWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun tieredWithProrationConfig(
                        tieredWithProrationConfig: TieredWithProrationConfig
                    ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

                    @JsonProperty("tiered_with_proration_config")
                    @ExcludeMissing
                    fun tieredWithProrationConfig(
                        tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
                    ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionTierWithProrationPrice =
                        NewSubscriptionTierWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            tieredWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val TIERED_WITH_PRORATION = ModelType(JsonField.of("tiered_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        TIERED_WITH_PRORATION,
                    }

                    enum class Value {
                        TIERED_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = TieredWithProrationConfig.Builder::class)
                @NoAutoDetect
                class TieredWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): TieredWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is TieredWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "TieredWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                            apply {
                                additionalProperties(tieredWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): TieredWithProrationConfig =
                            TieredWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionUnitWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionUnitWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun unitWithProrationConfig(): UnitWithProrationConfig =
                    unitWithProrationConfig.getRequired("unit_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("unit_with_proration_config")
                @ExcludeMissing
                fun _unitWithProrationConfig() = unitWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionUnitWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        unitWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionUnitWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.unitWithProrationConfig == other.unitWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                unitWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionUnitWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithProrationConfig=$unitWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var unitWithProrationConfig: JsonField<UnitWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionUnitWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionUnitWithProrationPrice.externalPriceId
                        this.name = newSubscriptionUnitWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionUnitWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionUnitWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionUnitWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionUnitWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionUnitWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionUnitWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionUnitWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionUnitWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionUnitWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionUnitWithProrationPrice.modelType
                        this.unitWithProrationConfig =
                            newSubscriptionUnitWithProrationPrice.unitWithProrationConfig
                        this.currency = newSubscriptionUnitWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionUnitWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                        unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

                    @JsonProperty("unit_with_proration_config")
                    @ExcludeMissing
                    fun unitWithProrationConfig(
                        unitWithProrationConfig: JsonField<UnitWithProrationConfig>
                    ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionUnitWithProrationPrice =
                        NewSubscriptionUnitWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            unitWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val UNIT_WITH_PRORATION = ModelType(JsonField.of("unit_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        UNIT_WITH_PRORATION,
                    }

                    enum class Value {
                        UNIT_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = UnitWithProrationConfig.Builder::class)
                @NoAutoDetect
                class UnitWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): UnitWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is UnitWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "UnitWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(unitWithProrationConfig: UnitWithProrationConfig) =
                            apply {
                                additionalProperties(unitWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): UnitWithProrationConfig =
                            UnitWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionGroupedAllocationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionGroupedAllocationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun groupedAllocationConfig(): GroupedAllocationConfig =
                    groupedAllocationConfig.getRequired("grouped_allocation_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("grouped_allocation_config")
                @ExcludeMissing
                fun _groupedAllocationConfig() = groupedAllocationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionGroupedAllocationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        groupedAllocationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionGroupedAllocationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.groupedAllocationConfig == other.groupedAllocationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                groupedAllocationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionGroupedAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedAllocationConfig=$groupedAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var groupedAllocationConfig: JsonField<GroupedAllocationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                    ) = apply {
                        this.metadata = newSubscriptionGroupedAllocationPrice.metadata
                        this.externalPriceId = newSubscriptionGroupedAllocationPrice.externalPriceId
                        this.name = newSubscriptionGroupedAllocationPrice.name
                        this.billableMetricId =
                            newSubscriptionGroupedAllocationPrice.billableMetricId
                        this.itemId = newSubscriptionGroupedAllocationPrice.itemId
                        this.billedInAdvance = newSubscriptionGroupedAllocationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionGroupedAllocationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionGroupedAllocationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionGroupedAllocationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionGroupedAllocationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionGroupedAllocationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionGroupedAllocationPrice.conversionRate
                        this.modelType = newSubscriptionGroupedAllocationPrice.modelType
                        this.groupedAllocationConfig =
                            newSubscriptionGroupedAllocationPrice.groupedAllocationConfig
                        this.currency = newSubscriptionGroupedAllocationPrice.currency
                        additionalProperties(
                            newSubscriptionGroupedAllocationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                        groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

                    @JsonProperty("grouped_allocation_config")
                    @ExcludeMissing
                    fun groupedAllocationConfig(
                        groupedAllocationConfig: JsonField<GroupedAllocationConfig>
                    ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionGroupedAllocationPrice =
                        NewSubscriptionGroupedAllocationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            groupedAllocationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = GroupedAllocationConfig.Builder::class)
                @NoAutoDetect
                class GroupedAllocationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): GroupedAllocationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is GroupedAllocationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "GroupedAllocationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(groupedAllocationConfig: GroupedAllocationConfig) =
                            apply {
                                additionalProperties(groupedAllocationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): GroupedAllocationConfig =
                            GroupedAllocationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val GROUPED_ALLOCATION = ModelType(JsonField.of("grouped_allocation"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        GROUPED_ALLOCATION,
                    }

                    enum class Value {
                        GROUPED_ALLOCATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(
                builder = NewSubscriptionGroupedWithProratedMinimumPrice.Builder::class
            )
            @NoAutoDetect
            class NewSubscriptionGroupedWithProratedMinimumPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val groupedWithProratedMinimumConfig:
                    JsonField<GroupedWithProratedMinimumConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
                    groupedWithProratedMinimumConfig.getRequired(
                        "grouped_with_prorated_minimum_config"
                    )

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("grouped_with_prorated_minimum_config")
                @ExcludeMissing
                fun _groupedWithProratedMinimumConfig() = groupedWithProratedMinimumConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionGroupedWithProratedMinimumPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        groupedWithProratedMinimumConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionGroupedWithProratedMinimumPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.groupedWithProratedMinimumConfig ==
                            other.groupedWithProratedMinimumConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                groupedWithProratedMinimumConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionGroupedWithProratedMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var groupedWithProratedMinimumConfig:
                        JsonField<GroupedWithProratedMinimumConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionGroupedWithProratedMinimumPrice:
                            NewSubscriptionGroupedWithProratedMinimumPrice
                    ) = apply {
                        this.metadata = newSubscriptionGroupedWithProratedMinimumPrice.metadata
                        this.externalPriceId =
                            newSubscriptionGroupedWithProratedMinimumPrice.externalPriceId
                        this.name = newSubscriptionGroupedWithProratedMinimumPrice.name
                        this.billableMetricId =
                            newSubscriptionGroupedWithProratedMinimumPrice.billableMetricId
                        this.itemId = newSubscriptionGroupedWithProratedMinimumPrice.itemId
                        this.billedInAdvance =
                            newSubscriptionGroupedWithProratedMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionGroupedWithProratedMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionGroupedWithProratedMinimumPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionGroupedWithProratedMinimumPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionGroupedWithProratedMinimumPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionGroupedWithProratedMinimumPrice
                                .invoicingCycleConfiguration
                        this.conversionRate =
                            newSubscriptionGroupedWithProratedMinimumPrice.conversionRate
                        this.modelType = newSubscriptionGroupedWithProratedMinimumPrice.modelType
                        this.groupedWithProratedMinimumConfig =
                            newSubscriptionGroupedWithProratedMinimumPrice
                                .groupedWithProratedMinimumConfig
                        this.currency = newSubscriptionGroupedWithProratedMinimumPrice.currency
                        additionalProperties(
                            newSubscriptionGroupedWithProratedMinimumPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun groupedWithProratedMinimumConfig(
                        groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                    ) =
                        groupedWithProratedMinimumConfig(
                            JsonField.of(groupedWithProratedMinimumConfig)
                        )

                    @JsonProperty("grouped_with_prorated_minimum_config")
                    @ExcludeMissing
                    fun groupedWithProratedMinimumConfig(
                        groupedWithProratedMinimumConfig:
                            JsonField<GroupedWithProratedMinimumConfig>
                    ) = apply {
                        this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig
                    }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionGroupedWithProratedMinimumPrice =
                        NewSubscriptionGroupedWithProratedMinimumPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            groupedWithProratedMinimumConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                @JsonDeserialize(builder = GroupedWithProratedMinimumConfig.Builder::class)
                @NoAutoDetect
                class GroupedWithProratedMinimumConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): GroupedWithProratedMinimumConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is GroupedWithProratedMinimumConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                        ) = apply {
                            additionalProperties(
                                groupedWithProratedMinimumConfig.additionalProperties
                            )
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): GroupedWithProratedMinimumConfig =
                            GroupedWithProratedMinimumConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val GROUPED_WITH_PRORATED_MINIMUM =
                            ModelType(JsonField.of("grouped_with_prorated_minimum"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        GROUPED_WITH_PRORATED_MINIMUM,
                    }

                    enum class Value {
                        GROUPED_WITH_PRORATED_MINIMUM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }

            @JsonDeserialize(builder = NewSubscriptionBulkWithProrationPrice.Builder::class)
            @NoAutoDetect
            class NewSubscriptionBulkWithProrationPrice
            private constructor(
                private val metadata: JsonField<Metadata>,
                private val externalPriceId: JsonField<String>,
                private val name: JsonField<String>,
                private val billableMetricId: JsonField<String>,
                private val itemId: JsonField<String>,
                private val billedInAdvance: JsonField<Boolean>,
                private val fixedPriceQuantity: JsonField<Double>,
                private val invoiceGroupingKey: JsonField<String>,
                private val cadence: JsonField<Cadence>,
                private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
                private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
                private val conversionRate: JsonField<Double>,
                private val modelType: JsonField<ModelType>,
                private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
                private val currency: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(): Optional<Metadata> =
                    Optional.ofNullable(metadata.getNullable("metadata"))

                /** An alias for the price. */
                fun externalPriceId(): Optional<String> =
                    Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

                /** The name of the price. */
                fun name(): String = name.getRequired("name")

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(): Optional<String> =
                    Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

                /** The id of the item the plan will be associated with. */
                fun itemId(): String = itemId.getRequired("item_id")

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(): Optional<Boolean> =
                    Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(): Optional<Double> =
                    Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(): Optional<String> =
                    Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

                /** The cadence to bill for this price on. */
                fun cadence(): Cadence = cadence.getRequired("cadence")

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                    Optional.ofNullable(
                        billingCycleConfiguration.getNullable("billing_cycle_configuration")
                    )

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                    Optional.ofNullable(
                        invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                    )

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(): Optional<Double> =
                    Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

                fun modelType(): ModelType = modelType.getRequired("model_type")

                fun bulkWithProrationConfig(): BulkWithProrationConfig =
                    bulkWithProrationConfig.getRequired("bulk_with_proration_config")

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(): Optional<String> =
                    Optional.ofNullable(currency.getNullable("currency"))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun _externalPriceId() = externalPriceId

                /** The name of the price. */
                @JsonProperty("name") @ExcludeMissing fun _name() = name

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun _billableMetricId() = billableMetricId

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun _billedInAdvance() = billedInAdvance

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun _fixedPriceQuantity() = fixedPriceQuantity

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun _invoiceGroupingKey() = invoiceGroupingKey

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun _billingCycleConfiguration() = billingCycleConfiguration

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun _conversionRate() = conversionRate

                @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

                @JsonProperty("bulk_with_proration_config")
                @ExcludeMissing
                fun _bulkWithProrationConfig() = bulkWithProrationConfig

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): NewSubscriptionBulkWithProrationPrice = apply {
                    if (!validated) {
                        metadata().map { it.validate() }
                        externalPriceId()
                        name()
                        billableMetricId()
                        itemId()
                        billedInAdvance()
                        fixedPriceQuantity()
                        invoiceGroupingKey()
                        cadence()
                        billingCycleConfiguration().map { it.validate() }
                        invoicingCycleConfiguration().map { it.validate() }
                        conversionRate()
                        modelType()
                        bulkWithProrationConfig().validate()
                        currency()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NewSubscriptionBulkWithProrationPrice &&
                        this.metadata == other.metadata &&
                        this.externalPriceId == other.externalPriceId &&
                        this.name == other.name &&
                        this.billableMetricId == other.billableMetricId &&
                        this.itemId == other.itemId &&
                        this.billedInAdvance == other.billedInAdvance &&
                        this.fixedPriceQuantity == other.fixedPriceQuantity &&
                        this.invoiceGroupingKey == other.invoiceGroupingKey &&
                        this.cadence == other.cadence &&
                        this.billingCycleConfiguration == other.billingCycleConfiguration &&
                        this.invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                        this.conversionRate == other.conversionRate &&
                        this.modelType == other.modelType &&
                        this.bulkWithProrationConfig == other.bulkWithProrationConfig &&
                        this.currency == other.currency &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                metadata,
                                externalPriceId,
                                name,
                                billableMetricId,
                                itemId,
                                billedInAdvance,
                                fixedPriceQuantity,
                                invoiceGroupingKey,
                                cadence,
                                billingCycleConfiguration,
                                invoicingCycleConfiguration,
                                conversionRate,
                                modelType,
                                bulkWithProrationConfig,
                                currency,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "NewSubscriptionBulkWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkWithProrationConfig=$bulkWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var metadata: JsonField<Metadata> = JsonMissing.of()
                    private var externalPriceId: JsonField<String> = JsonMissing.of()
                    private var name: JsonField<String> = JsonMissing.of()
                    private var billableMetricId: JsonField<String> = JsonMissing.of()
                    private var itemId: JsonField<String> = JsonMissing.of()
                    private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                    private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                    private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                    private var cadence: JsonField<Cadence> = JsonMissing.of()
                    private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                        JsonMissing.of()
                    private var invoicingCycleConfiguration:
                        JsonField<InvoicingCycleConfiguration> =
                        JsonMissing.of()
                    private var conversionRate: JsonField<Double> = JsonMissing.of()
                    private var modelType: JsonField<ModelType> = JsonMissing.of()
                    private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig> =
                        JsonMissing.of()
                    private var currency: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                    ) = apply {
                        this.metadata = newSubscriptionBulkWithProrationPrice.metadata
                        this.externalPriceId = newSubscriptionBulkWithProrationPrice.externalPriceId
                        this.name = newSubscriptionBulkWithProrationPrice.name
                        this.billableMetricId =
                            newSubscriptionBulkWithProrationPrice.billableMetricId
                        this.itemId = newSubscriptionBulkWithProrationPrice.itemId
                        this.billedInAdvance = newSubscriptionBulkWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity =
                            newSubscriptionBulkWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey =
                            newSubscriptionBulkWithProrationPrice.invoiceGroupingKey
                        this.cadence = newSubscriptionBulkWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newSubscriptionBulkWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newSubscriptionBulkWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newSubscriptionBulkWithProrationPrice.conversionRate
                        this.modelType = newSubscriptionBulkWithProrationPrice.modelType
                        this.bulkWithProrationConfig =
                            newSubscriptionBulkWithProrationPrice.bulkWithProrationConfig
                        this.currency = newSubscriptionBulkWithProrationPrice.currency
                        additionalProperties(
                            newSubscriptionBulkWithProrationPrice.additionalProperties
                        )
                    }

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                    /**
                     * User-specified key/value pairs for the resource. Individual keys can be
                     * removed by setting the value to `null`, and the entire metadata mapping can
                     * be cleared by setting `metadata` to `null`.
                     */
                    @JsonProperty("metadata")
                    @ExcludeMissing
                    fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                    /** An alias for the price. */
                    fun externalPriceId(externalPriceId: String) =
                        externalPriceId(JsonField.of(externalPriceId))

                    /** An alias for the price. */
                    @JsonProperty("external_price_id")
                    @ExcludeMissing
                    fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                        this.externalPriceId = externalPriceId
                    }

                    /** The name of the price. */
                    fun name(name: String) = name(JsonField.of(name))

                    /** The name of the price. */
                    @JsonProperty("name")
                    @ExcludeMissing
                    fun name(name: JsonField<String>) = apply { this.name = name }

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    fun billableMetricId(billableMetricId: String) =
                        billableMetricId(JsonField.of(billableMetricId))

                    /**
                     * The id of the billable metric for the price. Only needed if the price is
                     * usage-based.
                     */
                    @JsonProperty("billable_metric_id")
                    @ExcludeMissing
                    fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                        this.billableMetricId = billableMetricId
                    }

                    /** The id of the item the plan will be associated with. */
                    fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                    /** The id of the item the plan will be associated with. */
                    @JsonProperty("item_id")
                    @ExcludeMissing
                    fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    fun billedInAdvance(billedInAdvance: Boolean) =
                        billedInAdvance(JsonField.of(billedInAdvance))

                    /**
                     * If the Price represents a fixed cost, the price will be billed in-advance if
                     * this is true, and in-arrears if this is false.
                     */
                    @JsonProperty("billed_in_advance")
                    @ExcludeMissing
                    fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                        this.billedInAdvance = billedInAdvance
                    }

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                        fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                    /**
                     * If the Price represents a fixed cost, this represents the quantity of units
                     * applied.
                     */
                    @JsonProperty("fixed_price_quantity")
                    @ExcludeMissing
                    fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                        this.fixedPriceQuantity = fixedPriceQuantity
                    }

                    /** The property used to group this price on an invoice */
                    fun invoiceGroupingKey(invoiceGroupingKey: String) =
                        invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                    /** The property used to group this price on an invoice */
                    @JsonProperty("invoice_grouping_key")
                    @ExcludeMissing
                    fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                        this.invoiceGroupingKey = invoiceGroupingKey
                    }

                    /** The cadence to bill for this price on. */
                    fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                    /** The cadence to bill for this price on. */
                    @JsonProperty("cadence")
                    @ExcludeMissing
                    fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: BillingCycleConfiguration
                    ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                    /**
                     * For custom cadence: specifies the duration of the billing period in days or
                     * months.
                     */
                    @JsonProperty("billing_cycle_configuration")
                    @ExcludeMissing
                    fun billingCycleConfiguration(
                        billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                    ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: InvoicingCycleConfiguration
                    ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                    /**
                     * Within each billing cycle, specifies the cadence at which invoices are
                     * produced. If unspecified, a single invoice is produced per billing cycle.
                     */
                    @JsonProperty("invoicing_cycle_configuration")
                    @ExcludeMissing
                    fun invoicingCycleConfiguration(
                        invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                    ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    fun conversionRate(conversionRate: Double) =
                        conversionRate(JsonField.of(conversionRate))

                    /**
                     * The per unit conversion rate of the price currency to the invoicing currency.
                     */
                    @JsonProperty("conversion_rate")
                    @ExcludeMissing
                    fun conversionRate(conversionRate: JsonField<Double>) = apply {
                        this.conversionRate = conversionRate
                    }

                    fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                    @JsonProperty("model_type")
                    @ExcludeMissing
                    fun modelType(modelType: JsonField<ModelType>) = apply {
                        this.modelType = modelType
                    }

                    fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                        bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

                    @JsonProperty("bulk_with_proration_config")
                    @ExcludeMissing
                    fun bulkWithProrationConfig(
                        bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
                    ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    fun currency(currency: String) = currency(JsonField.of(currency))

                    /**
                     * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                     * price is billed.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): NewSubscriptionBulkWithProrationPrice =
                        NewSubscriptionBulkWithProrationPrice(
                            metadata,
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            billingCycleConfiguration,
                            invoicingCycleConfiguration,
                            conversionRate,
                            modelType,
                            bulkWithProrationConfig,
                            currency,
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = BulkWithProrationConfig.Builder::class)
                @NoAutoDetect
                class BulkWithProrationConfig
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BulkWithProrationConfig = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BulkWithProrationConfig &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BulkWithProrationConfig{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) =
                            apply {
                                additionalProperties(bulkWithProrationConfig.additionalProperties)
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BulkWithProrationConfig =
                            BulkWithProrationConfig(additionalProperties.toUnmodifiable())
                    }
                }

                class Cadence
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Cadence && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                        @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                        @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                        @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                        @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                        @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                        @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                    }

                    enum class Known {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                    }

                    enum class Value {
                        ANNUAL,
                        SEMI_ANNUAL,
                        MONTHLY,
                        QUARTERLY,
                        ONE_TIME,
                        CUSTOM,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            ANNUAL -> Value.ANNUAL
                            SEMI_ANNUAL -> Value.SEMI_ANNUAL
                            MONTHLY -> Value.MONTHLY
                            QUARTERLY -> Value.QUARTERLY
                            ONE_TIME -> Value.ONE_TIME
                            CUSTOM -> Value.CUSTOM
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            ANNUAL -> Known.ANNUAL
                            SEMI_ANNUAL -> Known.SEMI_ANNUAL
                            MONTHLY -> Known.MONTHLY
                            QUARTERLY -> Known.QUARTERLY
                            ONE_TIME -> Known.ONE_TIME
                            CUSTOM -> Known.CUSTOM
                            else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                class ModelType
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ModelType && this.value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField
                        val BULK_WITH_PRORATION = ModelType(JsonField.of("bulk_with_proration"))

                        @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                    }

                    enum class Known {
                        BULK_WITH_PRORATION,
                    }

                    enum class Value {
                        BULK_WITH_PRORATION,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                            else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class BillingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): BillingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is BillingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                            apply {
                                this.duration = billingCycleConfiguration.duration
                                this.durationUnit = billingCycleConfiguration.durationUnit
                                additionalProperties(billingCycleConfiguration.additionalProperties)
                            }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): BillingCycleConfiguration =
                            BillingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
                @NoAutoDetect
                class InvoicingCycleConfiguration
                private constructor(
                    private val duration: JsonField<Long>,
                    private val durationUnit: JsonField<DurationUnit>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** The duration of the billing period. */
                    fun duration(): Long = duration.getRequired("duration")

                    /** The unit of billing period duration. */
                    fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                    /** The duration of the billing period. */
                    @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun _durationUnit() = durationUnit

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): InvoicingCycleConfiguration = apply {
                        if (!validated) {
                            duration()
                            durationUnit()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvoicingCycleConfiguration &&
                            this.duration == other.duration &&
                            this.durationUnit == other.durationUnit &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    duration,
                                    durationUnit,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var duration: JsonField<Long> = JsonMissing.of()
                        private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(
                            invoicingCycleConfiguration: InvoicingCycleConfiguration
                        ) = apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                        /** The duration of the billing period. */
                        fun duration(duration: Long) = duration(JsonField.of(duration))

                        /** The duration of the billing period. */
                        @JsonProperty("duration")
                        @ExcludeMissing
                        fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                        /** The unit of billing period duration. */
                        fun durationUnit(durationUnit: DurationUnit) =
                            durationUnit(JsonField.of(durationUnit))

                        /** The unit of billing period duration. */
                        @JsonProperty("duration_unit")
                        @ExcludeMissing
                        fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                            this.durationUnit = durationUnit
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): InvoicingCycleConfiguration =
                            InvoicingCycleConfiguration(
                                duration,
                                durationUnit,
                                additionalProperties.toUnmodifiable(),
                            )
                    }

                    class DurationUnit
                    @JsonCreator
                    private constructor(
                        private val value: JsonField<String>,
                    ) : Enum {

                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DurationUnit && this.value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()

                        companion object {

                            @JvmField val DAY = DurationUnit(JsonField.of("day"))

                            @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                            @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                        }

                        enum class Known {
                            DAY,
                            MONTH,
                        }

                        enum class Value {
                            DAY,
                            MONTH,
                            _UNKNOWN,
                        }

                        fun value(): Value =
                            when (this) {
                                DAY -> Value.DAY
                                MONTH -> Value.MONTH
                                else -> Value._UNKNOWN
                            }

                        fun known(): Known =
                            when (this) {
                                DAY -> Known.DAY
                                MONTH -> Known.MONTH
                                else ->
                                    throw OrbInvalidDataException("Unknown DurationUnit: $value")
                            }

                        fun asString(): String = _value().asStringOrThrow()
                    }
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonDeserialize(builder = Metadata.Builder::class)
                @NoAutoDetect
                class Metadata
                private constructor(
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Metadata = apply {
                        if (!validated) {
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Metadata &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = Objects.hash(additionalProperties)
                        }
                        return hashCode
                    }

                    override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(metadata: Metadata) = apply {
                            additionalProperties(metadata.additionalProperties)
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
                    }
                }
            }
        }
    }
}
