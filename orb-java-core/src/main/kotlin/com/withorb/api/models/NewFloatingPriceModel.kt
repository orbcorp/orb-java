// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

@JsonDeserialize(using = NewFloatingPriceModel.Deserializer::class)
@JsonSerialize(using = NewFloatingPriceModel.Serializer::class)
class NewFloatingPriceModel
private constructor(
    private val unitPrice: NewFloatingUnitPrice? = null,
    private val packagePrice: NewFloatingPackagePrice? = null,
    private val matrixPrice: NewFloatingMatrixPrice? = null,
    private val matrixWithAllocationPrice: NewFloatingMatrixWithAllocationPrice? = null,
    private val tieredPrice: NewFloatingTieredPrice? = null,
    private val tieredBpsPrice: NewFloatingTieredBpsPrice? = null,
    private val bpsPrice: NewFloatingBpsPrice? = null,
    private val bulkBpsPrice: NewFloatingBulkBpsPrice? = null,
    private val bulkPrice: NewFloatingBulkPrice? = null,
    private val thresholdTotalAmountPrice: NewFloatingThresholdTotalAmountPrice? = null,
    private val tieredPackagePrice: NewFloatingTieredPackagePrice? = null,
    private val groupedTieredPrice: NewFloatingGroupedTieredPrice? = null,
    private val maxGroupTieredPackagePrice: NewFloatingMaxGroupTieredPackagePrice? = null,
    private val tieredWithMinimumPrice: NewFloatingTieredWithMinimumPrice? = null,
    private val packageWithAllocationPrice: NewFloatingPackageWithAllocationPrice? = null,
    private val tieredPackageWithMinimumPrice: NewFloatingTieredPackageWithMinimumPrice? = null,
    private val unitWithPercentPrice: NewFloatingUnitWithPercentPrice? = null,
    private val tieredWithProrationPrice: NewFloatingTieredWithProrationPrice? = null,
    private val unitWithProrationPrice: NewFloatingUnitWithProrationPrice? = null,
    private val groupedAllocationPrice: NewFloatingGroupedAllocationPrice? = null,
    private val groupedWithProratedMinimumPrice: NewFloatingGroupedWithProratedMinimumPrice? = null,
    private val groupedWithMeteredMinimumPrice: NewFloatingGroupedWithMeteredMinimumPrice? = null,
    private val matrixWithDisplayNamePrice: NewFloatingMatrixWithDisplayNamePrice? = null,
    private val bulkWithProrationPrice: NewFloatingBulkWithProrationPrice? = null,
    private val groupedTieredPackagePrice: NewFloatingGroupedTieredPackagePrice? = null,
    private val scalableMatrixWithUnitPricingPrice: NewFloatingScalableMatrixWithUnitPricingPrice? =
        null,
    private val scalableMatrixWithTieredPricingPrice:
        NewFloatingScalableMatrixWithTieredPricingPrice? =
        null,
    private val cumulativeGroupedBulkPrice: NewFloatingCumulativeGroupedBulkPrice? = null,
    private val _json: JsonValue? = null,
) {

    fun unitPrice(): Optional<NewFloatingUnitPrice> = Optional.ofNullable(unitPrice)

    fun packagePrice(): Optional<NewFloatingPackagePrice> = Optional.ofNullable(packagePrice)

    fun matrixPrice(): Optional<NewFloatingMatrixPrice> = Optional.ofNullable(matrixPrice)

    fun matrixWithAllocationPrice(): Optional<NewFloatingMatrixWithAllocationPrice> =
        Optional.ofNullable(matrixWithAllocationPrice)

    fun tieredPrice(): Optional<NewFloatingTieredPrice> = Optional.ofNullable(tieredPrice)

    fun tieredBpsPrice(): Optional<NewFloatingTieredBpsPrice> = Optional.ofNullable(tieredBpsPrice)

    fun bpsPrice(): Optional<NewFloatingBpsPrice> = Optional.ofNullable(bpsPrice)

    fun bulkBpsPrice(): Optional<NewFloatingBulkBpsPrice> = Optional.ofNullable(bulkBpsPrice)

    fun bulkPrice(): Optional<NewFloatingBulkPrice> = Optional.ofNullable(bulkPrice)

    fun thresholdTotalAmountPrice(): Optional<NewFloatingThresholdTotalAmountPrice> =
        Optional.ofNullable(thresholdTotalAmountPrice)

    fun tieredPackagePrice(): Optional<NewFloatingTieredPackagePrice> =
        Optional.ofNullable(tieredPackagePrice)

    fun groupedTieredPrice(): Optional<NewFloatingGroupedTieredPrice> =
        Optional.ofNullable(groupedTieredPrice)

    fun maxGroupTieredPackagePrice(): Optional<NewFloatingMaxGroupTieredPackagePrice> =
        Optional.ofNullable(maxGroupTieredPackagePrice)

    fun tieredWithMinimumPrice(): Optional<NewFloatingTieredWithMinimumPrice> =
        Optional.ofNullable(tieredWithMinimumPrice)

    fun packageWithAllocationPrice(): Optional<NewFloatingPackageWithAllocationPrice> =
        Optional.ofNullable(packageWithAllocationPrice)

    fun tieredPackageWithMinimumPrice(): Optional<NewFloatingTieredPackageWithMinimumPrice> =
        Optional.ofNullable(tieredPackageWithMinimumPrice)

    fun unitWithPercentPrice(): Optional<NewFloatingUnitWithPercentPrice> =
        Optional.ofNullable(unitWithPercentPrice)

    fun tieredWithProrationPrice(): Optional<NewFloatingTieredWithProrationPrice> =
        Optional.ofNullable(tieredWithProrationPrice)

    fun unitWithProrationPrice(): Optional<NewFloatingUnitWithProrationPrice> =
        Optional.ofNullable(unitWithProrationPrice)

    fun groupedAllocationPrice(): Optional<NewFloatingGroupedAllocationPrice> =
        Optional.ofNullable(groupedAllocationPrice)

    fun groupedWithProratedMinimumPrice(): Optional<NewFloatingGroupedWithProratedMinimumPrice> =
        Optional.ofNullable(groupedWithProratedMinimumPrice)

    fun groupedWithMeteredMinimumPrice(): Optional<NewFloatingGroupedWithMeteredMinimumPrice> =
        Optional.ofNullable(groupedWithMeteredMinimumPrice)

    fun matrixWithDisplayNamePrice(): Optional<NewFloatingMatrixWithDisplayNamePrice> =
        Optional.ofNullable(matrixWithDisplayNamePrice)

    fun bulkWithProrationPrice(): Optional<NewFloatingBulkWithProrationPrice> =
        Optional.ofNullable(bulkWithProrationPrice)

    fun groupedTieredPackagePrice(): Optional<NewFloatingGroupedTieredPackagePrice> =
        Optional.ofNullable(groupedTieredPackagePrice)

    fun scalableMatrixWithUnitPricingPrice():
        Optional<NewFloatingScalableMatrixWithUnitPricingPrice> =
        Optional.ofNullable(scalableMatrixWithUnitPricingPrice)

    fun scalableMatrixWithTieredPricingPrice():
        Optional<NewFloatingScalableMatrixWithTieredPricingPrice> =
        Optional.ofNullable(scalableMatrixWithTieredPricingPrice)

    fun cumulativeGroupedBulkPrice(): Optional<NewFloatingCumulativeGroupedBulkPrice> =
        Optional.ofNullable(cumulativeGroupedBulkPrice)

    fun isUnitPrice(): Boolean = unitPrice != null

    fun isPackagePrice(): Boolean = packagePrice != null

    fun isMatrixPrice(): Boolean = matrixPrice != null

    fun isMatrixWithAllocationPrice(): Boolean = matrixWithAllocationPrice != null

    fun isTieredPrice(): Boolean = tieredPrice != null

    fun isTieredBpsPrice(): Boolean = tieredBpsPrice != null

    fun isBpsPrice(): Boolean = bpsPrice != null

    fun isBulkBpsPrice(): Boolean = bulkBpsPrice != null

    fun isBulkPrice(): Boolean = bulkPrice != null

    fun isThresholdTotalAmountPrice(): Boolean = thresholdTotalAmountPrice != null

    fun isTieredPackagePrice(): Boolean = tieredPackagePrice != null

    fun isGroupedTieredPrice(): Boolean = groupedTieredPrice != null

    fun isMaxGroupTieredPackagePrice(): Boolean = maxGroupTieredPackagePrice != null

    fun isTieredWithMinimumPrice(): Boolean = tieredWithMinimumPrice != null

    fun isPackageWithAllocationPrice(): Boolean = packageWithAllocationPrice != null

    fun isTieredPackageWithMinimumPrice(): Boolean = tieredPackageWithMinimumPrice != null

    fun isUnitWithPercentPrice(): Boolean = unitWithPercentPrice != null

    fun isTieredWithProrationPrice(): Boolean = tieredWithProrationPrice != null

    fun isUnitWithProrationPrice(): Boolean = unitWithProrationPrice != null

    fun isGroupedAllocationPrice(): Boolean = groupedAllocationPrice != null

    fun isGroupedWithProratedMinimumPrice(): Boolean = groupedWithProratedMinimumPrice != null

    fun isGroupedWithMeteredMinimumPrice(): Boolean = groupedWithMeteredMinimumPrice != null

    fun isMatrixWithDisplayNamePrice(): Boolean = matrixWithDisplayNamePrice != null

    fun isBulkWithProrationPrice(): Boolean = bulkWithProrationPrice != null

    fun isGroupedTieredPackagePrice(): Boolean = groupedTieredPackagePrice != null

    fun isScalableMatrixWithUnitPricingPrice(): Boolean = scalableMatrixWithUnitPricingPrice != null

    fun isScalableMatrixWithTieredPricingPrice(): Boolean =
        scalableMatrixWithTieredPricingPrice != null

    fun isCumulativeGroupedBulkPrice(): Boolean = cumulativeGroupedBulkPrice != null

    fun asUnitPrice(): NewFloatingUnitPrice = unitPrice.getOrThrow("unitPrice")

    fun asPackagePrice(): NewFloatingPackagePrice = packagePrice.getOrThrow("packagePrice")

    fun asMatrixPrice(): NewFloatingMatrixPrice = matrixPrice.getOrThrow("matrixPrice")

    fun asMatrixWithAllocationPrice(): NewFloatingMatrixWithAllocationPrice =
        matrixWithAllocationPrice.getOrThrow("matrixWithAllocationPrice")

    fun asTieredPrice(): NewFloatingTieredPrice = tieredPrice.getOrThrow("tieredPrice")

    fun asTieredBpsPrice(): NewFloatingTieredBpsPrice = tieredBpsPrice.getOrThrow("tieredBpsPrice")

    fun asBpsPrice(): NewFloatingBpsPrice = bpsPrice.getOrThrow("bpsPrice")

    fun asBulkBpsPrice(): NewFloatingBulkBpsPrice = bulkBpsPrice.getOrThrow("bulkBpsPrice")

    fun asBulkPrice(): NewFloatingBulkPrice = bulkPrice.getOrThrow("bulkPrice")

    fun asThresholdTotalAmountPrice(): NewFloatingThresholdTotalAmountPrice =
        thresholdTotalAmountPrice.getOrThrow("thresholdTotalAmountPrice")

    fun asTieredPackagePrice(): NewFloatingTieredPackagePrice =
        tieredPackagePrice.getOrThrow("tieredPackagePrice")

    fun asGroupedTieredPrice(): NewFloatingGroupedTieredPrice =
        groupedTieredPrice.getOrThrow("groupedTieredPrice")

    fun asMaxGroupTieredPackagePrice(): NewFloatingMaxGroupTieredPackagePrice =
        maxGroupTieredPackagePrice.getOrThrow("maxGroupTieredPackagePrice")

    fun asTieredWithMinimumPrice(): NewFloatingTieredWithMinimumPrice =
        tieredWithMinimumPrice.getOrThrow("tieredWithMinimumPrice")

    fun asPackageWithAllocationPrice(): NewFloatingPackageWithAllocationPrice =
        packageWithAllocationPrice.getOrThrow("packageWithAllocationPrice")

    fun asTieredPackageWithMinimumPrice(): NewFloatingTieredPackageWithMinimumPrice =
        tieredPackageWithMinimumPrice.getOrThrow("tieredPackageWithMinimumPrice")

    fun asUnitWithPercentPrice(): NewFloatingUnitWithPercentPrice =
        unitWithPercentPrice.getOrThrow("unitWithPercentPrice")

    fun asTieredWithProrationPrice(): NewFloatingTieredWithProrationPrice =
        tieredWithProrationPrice.getOrThrow("tieredWithProrationPrice")

    fun asUnitWithProrationPrice(): NewFloatingUnitWithProrationPrice =
        unitWithProrationPrice.getOrThrow("unitWithProrationPrice")

    fun asGroupedAllocationPrice(): NewFloatingGroupedAllocationPrice =
        groupedAllocationPrice.getOrThrow("groupedAllocationPrice")

    fun asGroupedWithProratedMinimumPrice(): NewFloatingGroupedWithProratedMinimumPrice =
        groupedWithProratedMinimumPrice.getOrThrow("groupedWithProratedMinimumPrice")

    fun asGroupedWithMeteredMinimumPrice(): NewFloatingGroupedWithMeteredMinimumPrice =
        groupedWithMeteredMinimumPrice.getOrThrow("groupedWithMeteredMinimumPrice")

    fun asMatrixWithDisplayNamePrice(): NewFloatingMatrixWithDisplayNamePrice =
        matrixWithDisplayNamePrice.getOrThrow("matrixWithDisplayNamePrice")

    fun asBulkWithProrationPrice(): NewFloatingBulkWithProrationPrice =
        bulkWithProrationPrice.getOrThrow("bulkWithProrationPrice")

    fun asGroupedTieredPackagePrice(): NewFloatingGroupedTieredPackagePrice =
        groupedTieredPackagePrice.getOrThrow("groupedTieredPackagePrice")

    fun asScalableMatrixWithUnitPricingPrice(): NewFloatingScalableMatrixWithUnitPricingPrice =
        scalableMatrixWithUnitPricingPrice.getOrThrow("scalableMatrixWithUnitPricingPrice")

    fun asScalableMatrixWithTieredPricingPrice(): NewFloatingScalableMatrixWithTieredPricingPrice =
        scalableMatrixWithTieredPricingPrice.getOrThrow("scalableMatrixWithTieredPricingPrice")

    fun asCumulativeGroupedBulkPrice(): NewFloatingCumulativeGroupedBulkPrice =
        cumulativeGroupedBulkPrice.getOrThrow("cumulativeGroupedBulkPrice")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T {
        return when {
            unitPrice != null -> visitor.visitUnitPrice(unitPrice)
            packagePrice != null -> visitor.visitPackagePrice(packagePrice)
            matrixPrice != null -> visitor.visitMatrixPrice(matrixPrice)
            matrixWithAllocationPrice != null ->
                visitor.visitMatrixWithAllocationPrice(matrixWithAllocationPrice)
            tieredPrice != null -> visitor.visitTieredPrice(tieredPrice)
            tieredBpsPrice != null -> visitor.visitTieredBpsPrice(tieredBpsPrice)
            bpsPrice != null -> visitor.visitBpsPrice(bpsPrice)
            bulkBpsPrice != null -> visitor.visitBulkBpsPrice(bulkBpsPrice)
            bulkPrice != null -> visitor.visitBulkPrice(bulkPrice)
            thresholdTotalAmountPrice != null ->
                visitor.visitThresholdTotalAmountPrice(thresholdTotalAmountPrice)
            tieredPackagePrice != null -> visitor.visitTieredPackagePrice(tieredPackagePrice)
            groupedTieredPrice != null -> visitor.visitGroupedTieredPrice(groupedTieredPrice)
            maxGroupTieredPackagePrice != null ->
                visitor.visitMaxGroupTieredPackagePrice(maxGroupTieredPackagePrice)
            tieredWithMinimumPrice != null ->
                visitor.visitTieredWithMinimumPrice(tieredWithMinimumPrice)
            packageWithAllocationPrice != null ->
                visitor.visitPackageWithAllocationPrice(packageWithAllocationPrice)
            tieredPackageWithMinimumPrice != null ->
                visitor.visitTieredPackageWithMinimumPrice(tieredPackageWithMinimumPrice)
            unitWithPercentPrice != null -> visitor.visitUnitWithPercentPrice(unitWithPercentPrice)
            tieredWithProrationPrice != null ->
                visitor.visitTieredWithProrationPrice(tieredWithProrationPrice)
            unitWithProrationPrice != null ->
                visitor.visitUnitWithProrationPrice(unitWithProrationPrice)
            groupedAllocationPrice != null ->
                visitor.visitGroupedAllocationPrice(groupedAllocationPrice)
            groupedWithProratedMinimumPrice != null ->
                visitor.visitGroupedWithProratedMinimumPrice(groupedWithProratedMinimumPrice)
            groupedWithMeteredMinimumPrice != null ->
                visitor.visitGroupedWithMeteredMinimumPrice(groupedWithMeteredMinimumPrice)
            matrixWithDisplayNamePrice != null ->
                visitor.visitMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice)
            bulkWithProrationPrice != null ->
                visitor.visitBulkWithProrationPrice(bulkWithProrationPrice)
            groupedTieredPackagePrice != null ->
                visitor.visitGroupedTieredPackagePrice(groupedTieredPackagePrice)
            scalableMatrixWithUnitPricingPrice != null ->
                visitor.visitScalableMatrixWithUnitPricingPrice(scalableMatrixWithUnitPricingPrice)
            scalableMatrixWithTieredPricingPrice != null ->
                visitor.visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice
                )
            cumulativeGroupedBulkPrice != null ->
                visitor.visitCumulativeGroupedBulkPrice(cumulativeGroupedBulkPrice)
            else -> visitor.unknown(_json)
        }
    }

    private var validated: Boolean = false

    fun validate(): NewFloatingPriceModel = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnitPrice(unitPrice: NewFloatingUnitPrice) {
                    unitPrice.validate()
                }

                override fun visitPackagePrice(packagePrice: NewFloatingPackagePrice) {
                    packagePrice.validate()
                }

                override fun visitMatrixPrice(matrixPrice: NewFloatingMatrixPrice) {
                    matrixPrice.validate()
                }

                override fun visitMatrixWithAllocationPrice(
                    matrixWithAllocationPrice: NewFloatingMatrixWithAllocationPrice
                ) {
                    matrixWithAllocationPrice.validate()
                }

                override fun visitTieredPrice(tieredPrice: NewFloatingTieredPrice) {
                    tieredPrice.validate()
                }

                override fun visitTieredBpsPrice(tieredBpsPrice: NewFloatingTieredBpsPrice) {
                    tieredBpsPrice.validate()
                }

                override fun visitBpsPrice(bpsPrice: NewFloatingBpsPrice) {
                    bpsPrice.validate()
                }

                override fun visitBulkBpsPrice(bulkBpsPrice: NewFloatingBulkBpsPrice) {
                    bulkBpsPrice.validate()
                }

                override fun visitBulkPrice(bulkPrice: NewFloatingBulkPrice) {
                    bulkPrice.validate()
                }

                override fun visitThresholdTotalAmountPrice(
                    thresholdTotalAmountPrice: NewFloatingThresholdTotalAmountPrice
                ) {
                    thresholdTotalAmountPrice.validate()
                }

                override fun visitTieredPackagePrice(
                    tieredPackagePrice: NewFloatingTieredPackagePrice
                ) {
                    tieredPackagePrice.validate()
                }

                override fun visitGroupedTieredPrice(
                    groupedTieredPrice: NewFloatingGroupedTieredPrice
                ) {
                    groupedTieredPrice.validate()
                }

                override fun visitMaxGroupTieredPackagePrice(
                    maxGroupTieredPackagePrice: NewFloatingMaxGroupTieredPackagePrice
                ) {
                    maxGroupTieredPackagePrice.validate()
                }

                override fun visitTieredWithMinimumPrice(
                    tieredWithMinimumPrice: NewFloatingTieredWithMinimumPrice
                ) {
                    tieredWithMinimumPrice.validate()
                }

                override fun visitPackageWithAllocationPrice(
                    packageWithAllocationPrice: NewFloatingPackageWithAllocationPrice
                ) {
                    packageWithAllocationPrice.validate()
                }

                override fun visitTieredPackageWithMinimumPrice(
                    tieredPackageWithMinimumPrice: NewFloatingTieredPackageWithMinimumPrice
                ) {
                    tieredPackageWithMinimumPrice.validate()
                }

                override fun visitUnitWithPercentPrice(
                    unitWithPercentPrice: NewFloatingUnitWithPercentPrice
                ) {
                    unitWithPercentPrice.validate()
                }

                override fun visitTieredWithProrationPrice(
                    tieredWithProrationPrice: NewFloatingTieredWithProrationPrice
                ) {
                    tieredWithProrationPrice.validate()
                }

                override fun visitUnitWithProrationPrice(
                    unitWithProrationPrice: NewFloatingUnitWithProrationPrice
                ) {
                    unitWithProrationPrice.validate()
                }

                override fun visitGroupedAllocationPrice(
                    groupedAllocationPrice: NewFloatingGroupedAllocationPrice
                ) {
                    groupedAllocationPrice.validate()
                }

                override fun visitGroupedWithProratedMinimumPrice(
                    groupedWithProratedMinimumPrice: NewFloatingGroupedWithProratedMinimumPrice
                ) {
                    groupedWithProratedMinimumPrice.validate()
                }

                override fun visitGroupedWithMeteredMinimumPrice(
                    groupedWithMeteredMinimumPrice: NewFloatingGroupedWithMeteredMinimumPrice
                ) {
                    groupedWithMeteredMinimumPrice.validate()
                }

                override fun visitMatrixWithDisplayNamePrice(
                    matrixWithDisplayNamePrice: NewFloatingMatrixWithDisplayNamePrice
                ) {
                    matrixWithDisplayNamePrice.validate()
                }

                override fun visitBulkWithProrationPrice(
                    bulkWithProrationPrice: NewFloatingBulkWithProrationPrice
                ) {
                    bulkWithProrationPrice.validate()
                }

                override fun visitGroupedTieredPackagePrice(
                    groupedTieredPackagePrice: NewFloatingGroupedTieredPackagePrice
                ) {
                    groupedTieredPackagePrice.validate()
                }

                override fun visitScalableMatrixWithUnitPricingPrice(
                    scalableMatrixWithUnitPricingPrice:
                        NewFloatingScalableMatrixWithUnitPricingPrice
                ) {
                    scalableMatrixWithUnitPricingPrice.validate()
                }

                override fun visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice:
                        NewFloatingScalableMatrixWithTieredPricingPrice
                ) {
                    scalableMatrixWithTieredPricingPrice.validate()
                }

                override fun visitCumulativeGroupedBulkPrice(
                    cumulativeGroupedBulkPrice: NewFloatingCumulativeGroupedBulkPrice
                ) {
                    cumulativeGroupedBulkPrice.validate()
                }
            }
        )
        validated = true
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is NewFloatingPriceModel && unitPrice == other.unitPrice && packagePrice == other.packagePrice && matrixPrice == other.matrixPrice && matrixWithAllocationPrice == other.matrixWithAllocationPrice && tieredPrice == other.tieredPrice && tieredBpsPrice == other.tieredBpsPrice && bpsPrice == other.bpsPrice && bulkBpsPrice == other.bulkBpsPrice && bulkPrice == other.bulkPrice && thresholdTotalAmountPrice == other.thresholdTotalAmountPrice && tieredPackagePrice == other.tieredPackagePrice && groupedTieredPrice == other.groupedTieredPrice && maxGroupTieredPackagePrice == other.maxGroupTieredPackagePrice && tieredWithMinimumPrice == other.tieredWithMinimumPrice && packageWithAllocationPrice == other.packageWithAllocationPrice && tieredPackageWithMinimumPrice == other.tieredPackageWithMinimumPrice && unitWithPercentPrice == other.unitWithPercentPrice && tieredWithProrationPrice == other.tieredWithProrationPrice && unitWithProrationPrice == other.unitWithProrationPrice && groupedAllocationPrice == other.groupedAllocationPrice && groupedWithProratedMinimumPrice == other.groupedWithProratedMinimumPrice && groupedWithMeteredMinimumPrice == other.groupedWithMeteredMinimumPrice && matrixWithDisplayNamePrice == other.matrixWithDisplayNamePrice && bulkWithProrationPrice == other.bulkWithProrationPrice && groupedTieredPackagePrice == other.groupedTieredPackagePrice && scalableMatrixWithUnitPricingPrice == other.scalableMatrixWithUnitPricingPrice && scalableMatrixWithTieredPricingPrice == other.scalableMatrixWithTieredPricingPrice && cumulativeGroupedBulkPrice == other.cumulativeGroupedBulkPrice /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unitPrice, packagePrice, matrixPrice, matrixWithAllocationPrice, tieredPrice, tieredBpsPrice, bpsPrice, bulkBpsPrice, bulkPrice, thresholdTotalAmountPrice, tieredPackagePrice, groupedTieredPrice, maxGroupTieredPackagePrice, tieredWithMinimumPrice, packageWithAllocationPrice, tieredPackageWithMinimumPrice, unitWithPercentPrice, tieredWithProrationPrice, unitWithProrationPrice, groupedAllocationPrice, groupedWithProratedMinimumPrice, groupedWithMeteredMinimumPrice, matrixWithDisplayNamePrice, bulkWithProrationPrice, groupedTieredPackagePrice, scalableMatrixWithUnitPricingPrice, scalableMatrixWithTieredPricingPrice, cumulativeGroupedBulkPrice) /* spotless:on */

    override fun toString(): String =
        when {
            unitPrice != null -> "NewFloatingPriceModel{unitPrice=$unitPrice}"
            packagePrice != null -> "NewFloatingPriceModel{packagePrice=$packagePrice}"
            matrixPrice != null -> "NewFloatingPriceModel{matrixPrice=$matrixPrice}"
            matrixWithAllocationPrice != null ->
                "NewFloatingPriceModel{matrixWithAllocationPrice=$matrixWithAllocationPrice}"
            tieredPrice != null -> "NewFloatingPriceModel{tieredPrice=$tieredPrice}"
            tieredBpsPrice != null -> "NewFloatingPriceModel{tieredBpsPrice=$tieredBpsPrice}"
            bpsPrice != null -> "NewFloatingPriceModel{bpsPrice=$bpsPrice}"
            bulkBpsPrice != null -> "NewFloatingPriceModel{bulkBpsPrice=$bulkBpsPrice}"
            bulkPrice != null -> "NewFloatingPriceModel{bulkPrice=$bulkPrice}"
            thresholdTotalAmountPrice != null ->
                "NewFloatingPriceModel{thresholdTotalAmountPrice=$thresholdTotalAmountPrice}"
            tieredPackagePrice != null ->
                "NewFloatingPriceModel{tieredPackagePrice=$tieredPackagePrice}"
            groupedTieredPrice != null ->
                "NewFloatingPriceModel{groupedTieredPrice=$groupedTieredPrice}"
            maxGroupTieredPackagePrice != null ->
                "NewFloatingPriceModel{maxGroupTieredPackagePrice=$maxGroupTieredPackagePrice}"
            tieredWithMinimumPrice != null ->
                "NewFloatingPriceModel{tieredWithMinimumPrice=$tieredWithMinimumPrice}"
            packageWithAllocationPrice != null ->
                "NewFloatingPriceModel{packageWithAllocationPrice=$packageWithAllocationPrice}"
            tieredPackageWithMinimumPrice != null ->
                "NewFloatingPriceModel{tieredPackageWithMinimumPrice=$tieredPackageWithMinimumPrice}"
            unitWithPercentPrice != null ->
                "NewFloatingPriceModel{unitWithPercentPrice=$unitWithPercentPrice}"
            tieredWithProrationPrice != null ->
                "NewFloatingPriceModel{tieredWithProrationPrice=$tieredWithProrationPrice}"
            unitWithProrationPrice != null ->
                "NewFloatingPriceModel{unitWithProrationPrice=$unitWithProrationPrice}"
            groupedAllocationPrice != null ->
                "NewFloatingPriceModel{groupedAllocationPrice=$groupedAllocationPrice}"
            groupedWithProratedMinimumPrice != null ->
                "NewFloatingPriceModel{groupedWithProratedMinimumPrice=$groupedWithProratedMinimumPrice}"
            groupedWithMeteredMinimumPrice != null ->
                "NewFloatingPriceModel{groupedWithMeteredMinimumPrice=$groupedWithMeteredMinimumPrice}"
            matrixWithDisplayNamePrice != null ->
                "NewFloatingPriceModel{matrixWithDisplayNamePrice=$matrixWithDisplayNamePrice}"
            bulkWithProrationPrice != null ->
                "NewFloatingPriceModel{bulkWithProrationPrice=$bulkWithProrationPrice}"
            groupedTieredPackagePrice != null ->
                "NewFloatingPriceModel{groupedTieredPackagePrice=$groupedTieredPackagePrice}"
            scalableMatrixWithUnitPricingPrice != null ->
                "NewFloatingPriceModel{scalableMatrixWithUnitPricingPrice=$scalableMatrixWithUnitPricingPrice}"
            scalableMatrixWithTieredPricingPrice != null ->
                "NewFloatingPriceModel{scalableMatrixWithTieredPricingPrice=$scalableMatrixWithTieredPricingPrice}"
            cumulativeGroupedBulkPrice != null ->
                "NewFloatingPriceModel{cumulativeGroupedBulkPrice=$cumulativeGroupedBulkPrice}"
            _json != null -> "NewFloatingPriceModel{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid NewFloatingPriceModel")
        }

    companion object {

        @JvmStatic
        fun ofUnitPrice(unitPrice: NewFloatingUnitPrice) =
            NewFloatingPriceModel(unitPrice = unitPrice)

        @JvmStatic
        fun ofPackagePrice(packagePrice: NewFloatingPackagePrice) =
            NewFloatingPriceModel(packagePrice = packagePrice)

        @JvmStatic
        fun ofMatrixPrice(matrixPrice: NewFloatingMatrixPrice) =
            NewFloatingPriceModel(matrixPrice = matrixPrice)

        @JvmStatic
        fun ofMatrixWithAllocationPrice(
            matrixWithAllocationPrice: NewFloatingMatrixWithAllocationPrice
        ) = NewFloatingPriceModel(matrixWithAllocationPrice = matrixWithAllocationPrice)

        @JvmStatic
        fun ofTieredPrice(tieredPrice: NewFloatingTieredPrice) =
            NewFloatingPriceModel(tieredPrice = tieredPrice)

        @JvmStatic
        fun ofTieredBpsPrice(tieredBpsPrice: NewFloatingTieredBpsPrice) =
            NewFloatingPriceModel(tieredBpsPrice = tieredBpsPrice)

        @JvmStatic
        fun ofBpsPrice(bpsPrice: NewFloatingBpsPrice) = NewFloatingPriceModel(bpsPrice = bpsPrice)

        @JvmStatic
        fun ofBulkBpsPrice(bulkBpsPrice: NewFloatingBulkBpsPrice) =
            NewFloatingPriceModel(bulkBpsPrice = bulkBpsPrice)

        @JvmStatic
        fun ofBulkPrice(bulkPrice: NewFloatingBulkPrice) =
            NewFloatingPriceModel(bulkPrice = bulkPrice)

        @JvmStatic
        fun ofThresholdTotalAmountPrice(
            thresholdTotalAmountPrice: NewFloatingThresholdTotalAmountPrice
        ) = NewFloatingPriceModel(thresholdTotalAmountPrice = thresholdTotalAmountPrice)

        @JvmStatic
        fun ofTieredPackagePrice(tieredPackagePrice: NewFloatingTieredPackagePrice) =
            NewFloatingPriceModel(tieredPackagePrice = tieredPackagePrice)

        @JvmStatic
        fun ofGroupedTieredPrice(groupedTieredPrice: NewFloatingGroupedTieredPrice) =
            NewFloatingPriceModel(groupedTieredPrice = groupedTieredPrice)

        @JvmStatic
        fun ofMaxGroupTieredPackagePrice(
            maxGroupTieredPackagePrice: NewFloatingMaxGroupTieredPackagePrice
        ) = NewFloatingPriceModel(maxGroupTieredPackagePrice = maxGroupTieredPackagePrice)

        @JvmStatic
        fun ofTieredWithMinimumPrice(tieredWithMinimumPrice: NewFloatingTieredWithMinimumPrice) =
            NewFloatingPriceModel(tieredWithMinimumPrice = tieredWithMinimumPrice)

        @JvmStatic
        fun ofPackageWithAllocationPrice(
            packageWithAllocationPrice: NewFloatingPackageWithAllocationPrice
        ) = NewFloatingPriceModel(packageWithAllocationPrice = packageWithAllocationPrice)

        @JvmStatic
        fun ofTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: NewFloatingTieredPackageWithMinimumPrice
        ) = NewFloatingPriceModel(tieredPackageWithMinimumPrice = tieredPackageWithMinimumPrice)

        @JvmStatic
        fun ofUnitWithPercentPrice(unitWithPercentPrice: NewFloatingUnitWithPercentPrice) =
            NewFloatingPriceModel(unitWithPercentPrice = unitWithPercentPrice)

        @JvmStatic
        fun ofTieredWithProrationPrice(
            tieredWithProrationPrice: NewFloatingTieredWithProrationPrice
        ) = NewFloatingPriceModel(tieredWithProrationPrice = tieredWithProrationPrice)

        @JvmStatic
        fun ofUnitWithProrationPrice(unitWithProrationPrice: NewFloatingUnitWithProrationPrice) =
            NewFloatingPriceModel(unitWithProrationPrice = unitWithProrationPrice)

        @JvmStatic
        fun ofGroupedAllocationPrice(groupedAllocationPrice: NewFloatingGroupedAllocationPrice) =
            NewFloatingPriceModel(groupedAllocationPrice = groupedAllocationPrice)

        @JvmStatic
        fun ofGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: NewFloatingGroupedWithProratedMinimumPrice
        ) = NewFloatingPriceModel(groupedWithProratedMinimumPrice = groupedWithProratedMinimumPrice)

        @JvmStatic
        fun ofGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: NewFloatingGroupedWithMeteredMinimumPrice
        ) = NewFloatingPriceModel(groupedWithMeteredMinimumPrice = groupedWithMeteredMinimumPrice)

        @JvmStatic
        fun ofMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: NewFloatingMatrixWithDisplayNamePrice
        ) = NewFloatingPriceModel(matrixWithDisplayNamePrice = matrixWithDisplayNamePrice)

        @JvmStatic
        fun ofBulkWithProrationPrice(bulkWithProrationPrice: NewFloatingBulkWithProrationPrice) =
            NewFloatingPriceModel(bulkWithProrationPrice = bulkWithProrationPrice)

        @JvmStatic
        fun ofGroupedTieredPackagePrice(
            groupedTieredPackagePrice: NewFloatingGroupedTieredPackagePrice
        ) = NewFloatingPriceModel(groupedTieredPackagePrice = groupedTieredPackagePrice)

        @JvmStatic
        fun ofScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: NewFloatingScalableMatrixWithUnitPricingPrice
        ) =
            NewFloatingPriceModel(
                scalableMatrixWithUnitPricingPrice = scalableMatrixWithUnitPricingPrice
            )

        @JvmStatic
        fun ofScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice: NewFloatingScalableMatrixWithTieredPricingPrice
        ) =
            NewFloatingPriceModel(
                scalableMatrixWithTieredPricingPrice = scalableMatrixWithTieredPricingPrice
            )

        @JvmStatic
        fun ofCumulativeGroupedBulkPrice(
            cumulativeGroupedBulkPrice: NewFloatingCumulativeGroupedBulkPrice
        ) = NewFloatingPriceModel(cumulativeGroupedBulkPrice = cumulativeGroupedBulkPrice)
    }

    /**
     * An interface that defines how to map each variant of [NewFloatingPriceModel] to a value of
     * type [T].
     */
    interface Visitor<out T> {

        fun visitUnitPrice(unitPrice: NewFloatingUnitPrice): T

        fun visitPackagePrice(packagePrice: NewFloatingPackagePrice): T

        fun visitMatrixPrice(matrixPrice: NewFloatingMatrixPrice): T

        fun visitMatrixWithAllocationPrice(
            matrixWithAllocationPrice: NewFloatingMatrixWithAllocationPrice
        ): T

        fun visitTieredPrice(tieredPrice: NewFloatingTieredPrice): T

        fun visitTieredBpsPrice(tieredBpsPrice: NewFloatingTieredBpsPrice): T

        fun visitBpsPrice(bpsPrice: NewFloatingBpsPrice): T

        fun visitBulkBpsPrice(bulkBpsPrice: NewFloatingBulkBpsPrice): T

        fun visitBulkPrice(bulkPrice: NewFloatingBulkPrice): T

        fun visitThresholdTotalAmountPrice(
            thresholdTotalAmountPrice: NewFloatingThresholdTotalAmountPrice
        ): T

        fun visitTieredPackagePrice(tieredPackagePrice: NewFloatingTieredPackagePrice): T

        fun visitGroupedTieredPrice(groupedTieredPrice: NewFloatingGroupedTieredPrice): T

        fun visitMaxGroupTieredPackagePrice(
            maxGroupTieredPackagePrice: NewFloatingMaxGroupTieredPackagePrice
        ): T

        fun visitTieredWithMinimumPrice(
            tieredWithMinimumPrice: NewFloatingTieredWithMinimumPrice
        ): T

        fun visitPackageWithAllocationPrice(
            packageWithAllocationPrice: NewFloatingPackageWithAllocationPrice
        ): T

        fun visitTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: NewFloatingTieredPackageWithMinimumPrice
        ): T

        fun visitUnitWithPercentPrice(unitWithPercentPrice: NewFloatingUnitWithPercentPrice): T

        fun visitTieredWithProrationPrice(
            tieredWithProrationPrice: NewFloatingTieredWithProrationPrice
        ): T

        fun visitUnitWithProrationPrice(
            unitWithProrationPrice: NewFloatingUnitWithProrationPrice
        ): T

        fun visitGroupedAllocationPrice(
            groupedAllocationPrice: NewFloatingGroupedAllocationPrice
        ): T

        fun visitGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: NewFloatingGroupedWithProratedMinimumPrice
        ): T

        fun visitGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: NewFloatingGroupedWithMeteredMinimumPrice
        ): T

        fun visitMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: NewFloatingMatrixWithDisplayNamePrice
        ): T

        fun visitBulkWithProrationPrice(
            bulkWithProrationPrice: NewFloatingBulkWithProrationPrice
        ): T

        fun visitGroupedTieredPackagePrice(
            groupedTieredPackagePrice: NewFloatingGroupedTieredPackagePrice
        ): T

        fun visitScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: NewFloatingScalableMatrixWithUnitPricingPrice
        ): T

        fun visitScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice: NewFloatingScalableMatrixWithTieredPricingPrice
        ): T

        fun visitCumulativeGroupedBulkPrice(
            cumulativeGroupedBulkPrice: NewFloatingCumulativeGroupedBulkPrice
        ): T

        /**
         * Maps an unknown variant of [NewFloatingPriceModel] to a value of type [T].
         *
         * An instance of [NewFloatingPriceModel] can contain an unknown variant if it was
         * deserialized from data that doesn't match any known variant. For example, if the SDK is
         * on an older version than the API, then the API may respond with new variants that the SDK
         * is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown NewFloatingPriceModel: $json")
        }
    }

    internal class Deserializer :
        BaseDeserializer<NewFloatingPriceModel>(NewFloatingPriceModel::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): NewFloatingPriceModel {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingUnitPrice>()) { it.validate() }
                        ?.let {
                            return NewFloatingPriceModel(unitPrice = it, _json = json)
                        }
                }
                "package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(packagePrice = it, _json = json)
                        }
                }
                "matrix" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingMatrixPrice>()) { it.validate() }
                        ?.let {
                            return NewFloatingPriceModel(matrixPrice = it, _json = json)
                        }
                }
                "matrix_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingMatrixWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                matrixWithAllocationPrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingTieredPrice>()) { it.validate() }
                        ?.let {
                            return NewFloatingPriceModel(tieredPrice = it, _json = json)
                        }
                }
                "tiered_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingTieredBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(tieredBpsPrice = it, _json = json)
                        }
                }
                "bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingBpsPrice>()) { it.validate() }
                        ?.let {
                            return NewFloatingPriceModel(bpsPrice = it, _json = json)
                        }
                }
                "bulk_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingBulkBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(bulkBpsPrice = it, _json = json)
                        }
                }
                "bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingBulkPrice>()) { it.validate() }
                        ?.let {
                            return NewFloatingPriceModel(bulkPrice = it, _json = json)
                        }
                }
                "threshold_total_amount" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingThresholdTotalAmountPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                thresholdTotalAmountPrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(tieredPackagePrice = it, _json = json)
                        }
                }
                "grouped_tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingGroupedTieredPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(groupedTieredPrice = it, _json = json)
                        }
                }
                "max_group_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingMaxGroupTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                maxGroupTieredPackagePrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingTieredWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(tieredWithMinimumPrice = it, _json = json)
                        }
                }
                "package_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingPackageWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                packageWithAllocationPrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered_package_with_minimum" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewFloatingTieredPackageWithMinimumPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                tieredPackageWithMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "unit_with_percent" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingUnitWithPercentPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(unitWithPercentPrice = it, _json = json)
                        }
                }
                "tiered_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingTieredWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                tieredWithProrationPrice = it,
                                _json = json,
                            )
                        }
                }
                "unit_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingUnitWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(unitWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingGroupedAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(groupedAllocationPrice = it, _json = json)
                        }
                }
                "grouped_with_prorated_minimum" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewFloatingGroupedWithProratedMinimumPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                groupedWithProratedMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "grouped_with_metered_minimum" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewFloatingGroupedWithMeteredMinimumPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                groupedWithMeteredMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "matrix_with_display_name" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingMatrixWithDisplayNamePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                matrixWithDisplayNamePrice = it,
                                _json = json,
                            )
                        }
                }
                "bulk_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingBulkWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(bulkWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingGroupedTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                groupedTieredPackagePrice = it,
                                _json = json,
                            )
                        }
                }
                "scalable_matrix_with_unit_pricing" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewFloatingScalableMatrixWithUnitPricingPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                scalableMatrixWithUnitPricingPrice = it,
                                _json = json,
                            )
                        }
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewFloatingScalableMatrixWithTieredPricingPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                scalableMatrixWithTieredPricingPrice = it,
                                _json = json,
                            )
                        }
                }
                "cumulative_grouped_bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<NewFloatingCumulativeGroupedBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewFloatingPriceModel(
                                cumulativeGroupedBulkPrice = it,
                                _json = json,
                            )
                        }
                }
            }

            return NewFloatingPriceModel(_json = json)
        }
    }

    internal class Serializer :
        BaseSerializer<NewFloatingPriceModel>(NewFloatingPriceModel::class) {

        override fun serialize(
            value: NewFloatingPriceModel,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unitPrice != null -> generator.writeObject(value.unitPrice)
                value.packagePrice != null -> generator.writeObject(value.packagePrice)
                value.matrixPrice != null -> generator.writeObject(value.matrixPrice)
                value.matrixWithAllocationPrice != null ->
                    generator.writeObject(value.matrixWithAllocationPrice)
                value.tieredPrice != null -> generator.writeObject(value.tieredPrice)
                value.tieredBpsPrice != null -> generator.writeObject(value.tieredBpsPrice)
                value.bpsPrice != null -> generator.writeObject(value.bpsPrice)
                value.bulkBpsPrice != null -> generator.writeObject(value.bulkBpsPrice)
                value.bulkPrice != null -> generator.writeObject(value.bulkPrice)
                value.thresholdTotalAmountPrice != null ->
                    generator.writeObject(value.thresholdTotalAmountPrice)
                value.tieredPackagePrice != null -> generator.writeObject(value.tieredPackagePrice)
                value.groupedTieredPrice != null -> generator.writeObject(value.groupedTieredPrice)
                value.maxGroupTieredPackagePrice != null ->
                    generator.writeObject(value.maxGroupTieredPackagePrice)
                value.tieredWithMinimumPrice != null ->
                    generator.writeObject(value.tieredWithMinimumPrice)
                value.packageWithAllocationPrice != null ->
                    generator.writeObject(value.packageWithAllocationPrice)
                value.tieredPackageWithMinimumPrice != null ->
                    generator.writeObject(value.tieredPackageWithMinimumPrice)
                value.unitWithPercentPrice != null ->
                    generator.writeObject(value.unitWithPercentPrice)
                value.tieredWithProrationPrice != null ->
                    generator.writeObject(value.tieredWithProrationPrice)
                value.unitWithProrationPrice != null ->
                    generator.writeObject(value.unitWithProrationPrice)
                value.groupedAllocationPrice != null ->
                    generator.writeObject(value.groupedAllocationPrice)
                value.groupedWithProratedMinimumPrice != null ->
                    generator.writeObject(value.groupedWithProratedMinimumPrice)
                value.groupedWithMeteredMinimumPrice != null ->
                    generator.writeObject(value.groupedWithMeteredMinimumPrice)
                value.matrixWithDisplayNamePrice != null ->
                    generator.writeObject(value.matrixWithDisplayNamePrice)
                value.bulkWithProrationPrice != null ->
                    generator.writeObject(value.bulkWithProrationPrice)
                value.groupedTieredPackagePrice != null ->
                    generator.writeObject(value.groupedTieredPackagePrice)
                value.scalableMatrixWithUnitPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricingPrice)
                value.scalableMatrixWithTieredPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricingPrice)
                value.cumulativeGroupedBulkPrice != null ->
                    generator.writeObject(value.cumulativeGroupedBulkPrice)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid NewFloatingPriceModel")
            }
        }
    }

    @NoAutoDetect
    class NewFloatingUnitPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_config")
        @ExcludeMissing
        private val unitConfig: JsonField<UnitConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitConfig(): UnitConfigModel = unitConfig.getRequired("unit_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfigModel> = unitConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingUnitPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            unitConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingUnitPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .unitConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingUnitPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitConfig: JsonField<UnitConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingUnitPrice: NewFloatingUnitPrice) = apply {
                cadence = newFloatingUnitPrice.cadence
                currency = newFloatingUnitPrice.currency
                itemId = newFloatingUnitPrice.itemId
                modelType = newFloatingUnitPrice.modelType
                name = newFloatingUnitPrice.name
                unitConfig = newFloatingUnitPrice.unitConfig
                billableMetricId = newFloatingUnitPrice.billableMetricId
                billedInAdvance = newFloatingUnitPrice.billedInAdvance
                billingCycleConfiguration = newFloatingUnitPrice.billingCycleConfiguration
                conversionRate = newFloatingUnitPrice.conversionRate
                externalPriceId = newFloatingUnitPrice.externalPriceId
                fixedPriceQuantity = newFloatingUnitPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingUnitPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingUnitPrice.invoicingCycleConfiguration
                metadata = newFloatingUnitPrice.metadata
                additionalProperties = newFloatingUnitPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitConfig(unitConfig: UnitConfigModel) = unitConfig(JsonField.of(unitConfig))

            fun unitConfig(unitConfig: JsonField<UnitConfigModel>) = apply {
                this.unitConfig = unitConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingUnitPrice =
                NewFloatingUnitPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitConfig", unitConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT = of("unit")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT -> Value.UNIT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT -> Known.UNIT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingUnitPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && unitConfig == other.unitConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, unitConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingUnitPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, unitConfig=$unitConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_config")
        @ExcludeMissing
        private val packageConfig: JsonField<PackageConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun packageConfig(): PackageConfigModel = packageConfig.getRequired("package_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfigModel> = packageConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            packageConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .packageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingPackagePrice: NewFloatingPackagePrice) = apply {
                cadence = newFloatingPackagePrice.cadence
                currency = newFloatingPackagePrice.currency
                itemId = newFloatingPackagePrice.itemId
                modelType = newFloatingPackagePrice.modelType
                name = newFloatingPackagePrice.name
                packageConfig = newFloatingPackagePrice.packageConfig
                billableMetricId = newFloatingPackagePrice.billableMetricId
                billedInAdvance = newFloatingPackagePrice.billedInAdvance
                billingCycleConfiguration = newFloatingPackagePrice.billingCycleConfiguration
                conversionRate = newFloatingPackagePrice.conversionRate
                externalPriceId = newFloatingPackagePrice.externalPriceId
                fixedPriceQuantity = newFloatingPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingPackagePrice.invoicingCycleConfiguration
                metadata = newFloatingPackagePrice.metadata
                additionalProperties = newFloatingPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfigModel) =
                packageConfig(JsonField.of(packageConfig))

            fun packageConfig(packageConfig: JsonField<PackageConfigModel>) = apply {
                this.packageConfig = packageConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingPackagePrice =
                NewFloatingPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE = of("package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE -> Value.PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE -> Known.PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingPackagePrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, packageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingPackagePrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, packageConfig=$packageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingMatrixPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("matrix_config")
        @ExcludeMissing
        private val matrixConfig: JsonField<MatrixConfigModel> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun matrixConfig(): MatrixConfigModel = matrixConfig.getRequired("matrix_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfigModel> = matrixConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingMatrixPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            matrixConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingMatrixPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .matrixConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingMatrixPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var matrixConfig: JsonField<MatrixConfigModel>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingMatrixPrice: NewFloatingMatrixPrice) = apply {
                cadence = newFloatingMatrixPrice.cadence
                currency = newFloatingMatrixPrice.currency
                itemId = newFloatingMatrixPrice.itemId
                matrixConfig = newFloatingMatrixPrice.matrixConfig
                modelType = newFloatingMatrixPrice.modelType
                name = newFloatingMatrixPrice.name
                billableMetricId = newFloatingMatrixPrice.billableMetricId
                billedInAdvance = newFloatingMatrixPrice.billedInAdvance
                billingCycleConfiguration = newFloatingMatrixPrice.billingCycleConfiguration
                conversionRate = newFloatingMatrixPrice.conversionRate
                externalPriceId = newFloatingMatrixPrice.externalPriceId
                fixedPriceQuantity = newFloatingMatrixPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingMatrixPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingMatrixPrice.invoicingCycleConfiguration
                metadata = newFloatingMatrixPrice.metadata
                additionalProperties = newFloatingMatrixPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun matrixConfig(matrixConfig: MatrixConfigModel) =
                matrixConfig(JsonField.of(matrixConfig))

            fun matrixConfig(matrixConfig: JsonField<MatrixConfigModel>) = apply {
                this.matrixConfig = matrixConfig
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingMatrixPrice =
                NewFloatingMatrixPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX = of("matrix")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX -> Value.MATRIX
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX -> Known.MATRIX
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingMatrixPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && matrixConfig == other.matrixConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, matrixConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingMatrixPrice{cadence=$cadence, currency=$currency, itemId=$itemId, matrixConfig=$matrixConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingMatrixWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel> =
            JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun matrixWithAllocationConfig(): MatrixWithAllocationConfigModel =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfigModel> =
            matrixWithAllocationConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingMatrixWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            matrixWithAllocationConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingMatrixWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .matrixWithAllocationConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingMatrixWithAllocationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel>? =
                null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingMatrixWithAllocationPrice: NewFloatingMatrixWithAllocationPrice
            ) = apply {
                cadence = newFloatingMatrixWithAllocationPrice.cadence
                currency = newFloatingMatrixWithAllocationPrice.currency
                itemId = newFloatingMatrixWithAllocationPrice.itemId
                matrixWithAllocationConfig =
                    newFloatingMatrixWithAllocationPrice.matrixWithAllocationConfig
                modelType = newFloatingMatrixWithAllocationPrice.modelType
                name = newFloatingMatrixWithAllocationPrice.name
                billableMetricId = newFloatingMatrixWithAllocationPrice.billableMetricId
                billedInAdvance = newFloatingMatrixWithAllocationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingMatrixWithAllocationPrice.billingCycleConfiguration
                conversionRate = newFloatingMatrixWithAllocationPrice.conversionRate
                externalPriceId = newFloatingMatrixWithAllocationPrice.externalPriceId
                fixedPriceQuantity = newFloatingMatrixWithAllocationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingMatrixWithAllocationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingMatrixWithAllocationPrice.invoicingCycleConfiguration
                metadata = newFloatingMatrixWithAllocationPrice.metadata
                additionalProperties =
                    newFloatingMatrixWithAllocationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: MatrixWithAllocationConfigModel
            ) = matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingMatrixWithAllocationPrice =
                NewFloatingMatrixWithAllocationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_ALLOCATION = of("matrix_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Value.MATRIX_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Known.MATRIX_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingMatrixWithAllocationPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && matrixWithAllocationConfig == other.matrixWithAllocationConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, matrixWithAllocationConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingMatrixWithAllocationPrice{cadence=$cadence, currency=$currency, itemId=$itemId, matrixWithAllocationConfig=$matrixWithAllocationConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_config")
        @ExcludeMissing
        private val tieredConfig: JsonField<TieredConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredConfig(): TieredConfigModel = tieredConfig.getRequired("tiered_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfigModel> = tieredConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingTieredPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredConfig: JsonField<TieredConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingTieredPrice: NewFloatingTieredPrice) = apply {
                cadence = newFloatingTieredPrice.cadence
                currency = newFloatingTieredPrice.currency
                itemId = newFloatingTieredPrice.itemId
                modelType = newFloatingTieredPrice.modelType
                name = newFloatingTieredPrice.name
                tieredConfig = newFloatingTieredPrice.tieredConfig
                billableMetricId = newFloatingTieredPrice.billableMetricId
                billedInAdvance = newFloatingTieredPrice.billedInAdvance
                billingCycleConfiguration = newFloatingTieredPrice.billingCycleConfiguration
                conversionRate = newFloatingTieredPrice.conversionRate
                externalPriceId = newFloatingTieredPrice.externalPriceId
                fixedPriceQuantity = newFloatingTieredPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingTieredPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingTieredPrice.invoicingCycleConfiguration
                metadata = newFloatingTieredPrice.metadata
                additionalProperties = newFloatingTieredPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredConfig(tieredConfig: TieredConfigModel) =
                tieredConfig(JsonField.of(tieredConfig))

            fun tieredConfig(tieredConfig: JsonField<TieredConfigModel>) = apply {
                this.tieredConfig = tieredConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredPrice =
                NewFloatingTieredPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredConfig", tieredConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED = of("tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED -> Value.TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED -> Known.TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredConfig == other.tieredConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredConfig=$tieredConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        private val tieredBpsConfig: JsonField<TieredBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredBpsConfig(): TieredBpsConfigModel =
            tieredBpsConfig.getRequired("tiered_bps_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfigModel> = tieredBpsConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredBpsPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredBpsConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingTieredBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredBpsConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredBpsPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingTieredBpsPrice: NewFloatingTieredBpsPrice) = apply {
                cadence = newFloatingTieredBpsPrice.cadence
                currency = newFloatingTieredBpsPrice.currency
                itemId = newFloatingTieredBpsPrice.itemId
                modelType = newFloatingTieredBpsPrice.modelType
                name = newFloatingTieredBpsPrice.name
                tieredBpsConfig = newFloatingTieredBpsPrice.tieredBpsConfig
                billableMetricId = newFloatingTieredBpsPrice.billableMetricId
                billedInAdvance = newFloatingTieredBpsPrice.billedInAdvance
                billingCycleConfiguration = newFloatingTieredBpsPrice.billingCycleConfiguration
                conversionRate = newFloatingTieredBpsPrice.conversionRate
                externalPriceId = newFloatingTieredBpsPrice.externalPriceId
                fixedPriceQuantity = newFloatingTieredBpsPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingTieredBpsPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingTieredBpsPrice.invoicingCycleConfiguration
                metadata = newFloatingTieredBpsPrice.metadata
                additionalProperties = newFloatingTieredBpsPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfigModel) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfigModel>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredBpsPrice =
                NewFloatingTieredBpsPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_BPS = of("tiered_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_BPS -> Value.TIERED_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_BPS -> Known.TIERED_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredBpsPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredBpsConfig == other.tieredBpsConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredBpsConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredBpsPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredBpsConfig=$tieredBpsConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bps_config")
        @ExcludeMissing
        private val bpsConfig: JsonField<BpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bpsConfig(): BpsConfigModel = bpsConfig.getRequired("bps_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfigModel> = bpsConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingBpsPrice = apply {
            if (validated) {
                return@apply
            }

            bpsConfig().validate()
            cadence()
            currency()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .bpsConfig()
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingBpsPrice]. */
        class Builder internal constructor() {

            private var bpsConfig: JsonField<BpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingBpsPrice: NewFloatingBpsPrice) = apply {
                bpsConfig = newFloatingBpsPrice.bpsConfig
                cadence = newFloatingBpsPrice.cadence
                currency = newFloatingBpsPrice.currency
                itemId = newFloatingBpsPrice.itemId
                modelType = newFloatingBpsPrice.modelType
                name = newFloatingBpsPrice.name
                billableMetricId = newFloatingBpsPrice.billableMetricId
                billedInAdvance = newFloatingBpsPrice.billedInAdvance
                billingCycleConfiguration = newFloatingBpsPrice.billingCycleConfiguration
                conversionRate = newFloatingBpsPrice.conversionRate
                externalPriceId = newFloatingBpsPrice.externalPriceId
                fixedPriceQuantity = newFloatingBpsPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingBpsPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingBpsPrice.invoicingCycleConfiguration
                metadata = newFloatingBpsPrice.metadata
                additionalProperties = newFloatingBpsPrice.additionalProperties.toMutableMap()
            }

            fun bpsConfig(bpsConfig: BpsConfigModel) = bpsConfig(JsonField.of(bpsConfig))

            fun bpsConfig(bpsConfig: JsonField<BpsConfigModel>) = apply {
                this.bpsConfig = bpsConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingBpsPrice =
                NewFloatingBpsPrice(
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BPS = of("bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BPS -> Value.BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BPS -> Known.BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingBpsPrice && bpsConfig == other.bpsConfig && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bpsConfig, cadence, currency, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingBpsPrice{bpsConfig=$bpsConfig, cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingBulkBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        private val bulkBpsConfig: JsonField<BulkBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkBpsConfig(): BulkBpsConfigModel = bulkBpsConfig.getRequired("bulk_bps_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfigModel> = bulkBpsConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingBulkBpsPrice = apply {
            if (validated) {
                return@apply
            }

            bulkBpsConfig().validate()
            cadence()
            currency()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingBulkBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkBpsConfig()
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingBulkBpsPrice]. */
        class Builder internal constructor() {

            private var bulkBpsConfig: JsonField<BulkBpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingBulkBpsPrice: NewFloatingBulkBpsPrice) = apply {
                bulkBpsConfig = newFloatingBulkBpsPrice.bulkBpsConfig
                cadence = newFloatingBulkBpsPrice.cadence
                currency = newFloatingBulkBpsPrice.currency
                itemId = newFloatingBulkBpsPrice.itemId
                modelType = newFloatingBulkBpsPrice.modelType
                name = newFloatingBulkBpsPrice.name
                billableMetricId = newFloatingBulkBpsPrice.billableMetricId
                billedInAdvance = newFloatingBulkBpsPrice.billedInAdvance
                billingCycleConfiguration = newFloatingBulkBpsPrice.billingCycleConfiguration
                conversionRate = newFloatingBulkBpsPrice.conversionRate
                externalPriceId = newFloatingBulkBpsPrice.externalPriceId
                fixedPriceQuantity = newFloatingBulkBpsPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingBulkBpsPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingBulkBpsPrice.invoicingCycleConfiguration
                metadata = newFloatingBulkBpsPrice.metadata
                additionalProperties = newFloatingBulkBpsPrice.additionalProperties.toMutableMap()
            }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfigModel) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfigModel>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingBulkBpsPrice =
                NewFloatingBulkBpsPrice(
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_BPS = of("bulk_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_BPS -> Value.BULK_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_BPS -> Known.BULK_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingBulkBpsPrice && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkBpsConfig, cadence, currency, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingBulkBpsPrice{bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_config")
        @ExcludeMissing
        private val bulkConfig: JsonField<BulkConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkConfig(): BulkConfigModel = bulkConfig.getRequired("bulk_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfigModel> = bulkConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingBulkPrice = apply {
            if (validated) {
                return@apply
            }

            bulkConfig().validate()
            cadence()
            currency()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewFloatingBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkConfig()
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingBulkPrice]. */
        class Builder internal constructor() {

            private var bulkConfig: JsonField<BulkConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingBulkPrice: NewFloatingBulkPrice) = apply {
                bulkConfig = newFloatingBulkPrice.bulkConfig
                cadence = newFloatingBulkPrice.cadence
                currency = newFloatingBulkPrice.currency
                itemId = newFloatingBulkPrice.itemId
                modelType = newFloatingBulkPrice.modelType
                name = newFloatingBulkPrice.name
                billableMetricId = newFloatingBulkPrice.billableMetricId
                billedInAdvance = newFloatingBulkPrice.billedInAdvance
                billingCycleConfiguration = newFloatingBulkPrice.billingCycleConfiguration
                conversionRate = newFloatingBulkPrice.conversionRate
                externalPriceId = newFloatingBulkPrice.externalPriceId
                fixedPriceQuantity = newFloatingBulkPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingBulkPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newFloatingBulkPrice.invoicingCycleConfiguration
                metadata = newFloatingBulkPrice.metadata
                additionalProperties = newFloatingBulkPrice.additionalProperties.toMutableMap()
            }

            fun bulkConfig(bulkConfig: BulkConfigModel) = bulkConfig(JsonField.of(bulkConfig))

            fun bulkConfig(bulkConfig: JsonField<BulkConfigModel>) = apply {
                this.bulkConfig = bulkConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingBulkPrice =
                NewFloatingBulkPrice(
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK = of("bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK -> Value.BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK -> Known.BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingBulkPrice && bulkConfig == other.bulkConfig && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkConfig, cadence, currency, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingBulkPrice{bulkConfig=$bulkConfig, cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingThresholdTotalAmountPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        private val thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun thresholdTotalAmountConfig(): CustomRatingFunctionConfigModel =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<CustomRatingFunctionConfigModel> =
            thresholdTotalAmountConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingThresholdTotalAmountPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            thresholdTotalAmountConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingThresholdTotalAmountPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .thresholdTotalAmountConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingThresholdTotalAmountPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingThresholdTotalAmountPrice: NewFloatingThresholdTotalAmountPrice
            ) = apply {
                cadence = newFloatingThresholdTotalAmountPrice.cadence
                currency = newFloatingThresholdTotalAmountPrice.currency
                itemId = newFloatingThresholdTotalAmountPrice.itemId
                modelType = newFloatingThresholdTotalAmountPrice.modelType
                name = newFloatingThresholdTotalAmountPrice.name
                thresholdTotalAmountConfig =
                    newFloatingThresholdTotalAmountPrice.thresholdTotalAmountConfig
                billableMetricId = newFloatingThresholdTotalAmountPrice.billableMetricId
                billedInAdvance = newFloatingThresholdTotalAmountPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingThresholdTotalAmountPrice.billingCycleConfiguration
                conversionRate = newFloatingThresholdTotalAmountPrice.conversionRate
                externalPriceId = newFloatingThresholdTotalAmountPrice.externalPriceId
                fixedPriceQuantity = newFloatingThresholdTotalAmountPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingThresholdTotalAmountPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingThresholdTotalAmountPrice.invoicingCycleConfiguration
                metadata = newFloatingThresholdTotalAmountPrice.metadata
                additionalProperties =
                    newFloatingThresholdTotalAmountPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: CustomRatingFunctionConfigModel
            ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingThresholdTotalAmountPrice =
                NewFloatingThresholdTotalAmountPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                THRESHOLD_TOTAL_AMOUNT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                THRESHOLD_TOTAL_AMOUNT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingThresholdTotalAmountPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, thresholdTotalAmountConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingThresholdTotalAmountPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        private val tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredPackageConfig(): CustomRatingFunctionConfigModel =
            tieredPackageConfig.getRequired("tiered_package_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> = tieredPackageConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredPackageConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredPackageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingTieredPackagePrice: NewFloatingTieredPackagePrice) =
                apply {
                    cadence = newFloatingTieredPackagePrice.cadence
                    currency = newFloatingTieredPackagePrice.currency
                    itemId = newFloatingTieredPackagePrice.itemId
                    modelType = newFloatingTieredPackagePrice.modelType
                    name = newFloatingTieredPackagePrice.name
                    tieredPackageConfig = newFloatingTieredPackagePrice.tieredPackageConfig
                    billableMetricId = newFloatingTieredPackagePrice.billableMetricId
                    billedInAdvance = newFloatingTieredPackagePrice.billedInAdvance
                    billingCycleConfiguration =
                        newFloatingTieredPackagePrice.billingCycleConfiguration
                    conversionRate = newFloatingTieredPackagePrice.conversionRate
                    externalPriceId = newFloatingTieredPackagePrice.externalPriceId
                    fixedPriceQuantity = newFloatingTieredPackagePrice.fixedPriceQuantity
                    invoiceGroupingKey = newFloatingTieredPackagePrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newFloatingTieredPackagePrice.invoicingCycleConfiguration
                    metadata = newFloatingTieredPackagePrice.metadata
                    additionalProperties =
                        newFloatingTieredPackagePrice.additionalProperties.toMutableMap()
                }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredPackageConfig(tieredPackageConfig: CustomRatingFunctionConfigModel) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            fun tieredPackageConfig(
                tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredPackageConfig = tieredPackageConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredPackagePrice =
                NewFloatingTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE = of("tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE -> Value.TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE -> Known.TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredPackagePrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredPackageConfig == other.tieredPackageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredPackageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredPackagePrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredPackageConfig=$tieredPackageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingGroupedTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        private val groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        fun groupedTieredConfig(): CustomRatingFunctionConfigModel =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<CustomRatingFunctionConfigModel> = groupedTieredConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingGroupedTieredPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            groupedTieredConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingGroupedTieredPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .groupedTieredConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingGroupedTieredPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingGroupedTieredPrice: NewFloatingGroupedTieredPrice) =
                apply {
                    cadence = newFloatingGroupedTieredPrice.cadence
                    currency = newFloatingGroupedTieredPrice.currency
                    groupedTieredConfig = newFloatingGroupedTieredPrice.groupedTieredConfig
                    itemId = newFloatingGroupedTieredPrice.itemId
                    modelType = newFloatingGroupedTieredPrice.modelType
                    name = newFloatingGroupedTieredPrice.name
                    billableMetricId = newFloatingGroupedTieredPrice.billableMetricId
                    billedInAdvance = newFloatingGroupedTieredPrice.billedInAdvance
                    billingCycleConfiguration =
                        newFloatingGroupedTieredPrice.billingCycleConfiguration
                    conversionRate = newFloatingGroupedTieredPrice.conversionRate
                    externalPriceId = newFloatingGroupedTieredPrice.externalPriceId
                    fixedPriceQuantity = newFloatingGroupedTieredPrice.fixedPriceQuantity
                    invoiceGroupingKey = newFloatingGroupedTieredPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newFloatingGroupedTieredPrice.invoicingCycleConfiguration
                    metadata = newFloatingGroupedTieredPrice.metadata
                    additionalProperties =
                        newFloatingGroupedTieredPrice.additionalProperties.toMutableMap()
                }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun groupedTieredConfig(groupedTieredConfig: CustomRatingFunctionConfigModel) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            fun groupedTieredConfig(
                groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedTieredConfig = groupedTieredConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingGroupedTieredPrice =
                NewFloatingGroupedTieredPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED = of("grouped_tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED -> Value.GROUPED_TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED -> Known.GROUPED_TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingGroupedTieredPrice && cadence == other.cadence && currency == other.currency && groupedTieredConfig == other.groupedTieredConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, groupedTieredConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingGroupedTieredPrice{cadence=$cadence, currency=$currency, groupedTieredConfig=$groupedTieredConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingMaxGroupTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        private val maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun maxGroupTieredPackageConfig(): CustomRatingFunctionConfigModel =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            maxGroupTieredPackageConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingMaxGroupTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            maxGroupTieredPackageConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingMaxGroupTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .maxGroupTieredPackageConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingMaxGroupTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingMaxGroupTieredPackagePrice: NewFloatingMaxGroupTieredPackagePrice
            ) = apply {
                cadence = newFloatingMaxGroupTieredPackagePrice.cadence
                currency = newFloatingMaxGroupTieredPackagePrice.currency
                itemId = newFloatingMaxGroupTieredPackagePrice.itemId
                maxGroupTieredPackageConfig =
                    newFloatingMaxGroupTieredPackagePrice.maxGroupTieredPackageConfig
                modelType = newFloatingMaxGroupTieredPackagePrice.modelType
                name = newFloatingMaxGroupTieredPackagePrice.name
                billableMetricId = newFloatingMaxGroupTieredPackagePrice.billableMetricId
                billedInAdvance = newFloatingMaxGroupTieredPackagePrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingMaxGroupTieredPackagePrice.billingCycleConfiguration
                conversionRate = newFloatingMaxGroupTieredPackagePrice.conversionRate
                externalPriceId = newFloatingMaxGroupTieredPackagePrice.externalPriceId
                fixedPriceQuantity = newFloatingMaxGroupTieredPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingMaxGroupTieredPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingMaxGroupTieredPackagePrice.invoicingCycleConfiguration
                metadata = newFloatingMaxGroupTieredPackagePrice.metadata
                additionalProperties =
                    newFloatingMaxGroupTieredPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingMaxGroupTieredPackagePrice =
                NewFloatingMaxGroupTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MAX_GROUP_TIERED_PACKAGE = of("max_group_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MAX_GROUP_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MAX_GROUP_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Value.MAX_GROUP_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Known.MAX_GROUP_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingMaxGroupTieredPackagePrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, maxGroupTieredPackageConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingMaxGroupTieredPackagePrice{cadence=$cadence, currency=$currency, itemId=$itemId, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        private val tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredWithMinimumConfig(): CustomRatingFunctionConfigModel =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithMinimumConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredWithMinimumConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingTieredWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredWithMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingTieredWithMinimumPrice: NewFloatingTieredWithMinimumPrice
            ) = apply {
                cadence = newFloatingTieredWithMinimumPrice.cadence
                currency = newFloatingTieredWithMinimumPrice.currency
                itemId = newFloatingTieredWithMinimumPrice.itemId
                modelType = newFloatingTieredWithMinimumPrice.modelType
                name = newFloatingTieredWithMinimumPrice.name
                tieredWithMinimumConfig = newFloatingTieredWithMinimumPrice.tieredWithMinimumConfig
                billableMetricId = newFloatingTieredWithMinimumPrice.billableMetricId
                billedInAdvance = newFloatingTieredWithMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingTieredWithMinimumPrice.billingCycleConfiguration
                conversionRate = newFloatingTieredWithMinimumPrice.conversionRate
                externalPriceId = newFloatingTieredWithMinimumPrice.externalPriceId
                fixedPriceQuantity = newFloatingTieredWithMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingTieredWithMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingTieredWithMinimumPrice.invoicingCycleConfiguration
                metadata = newFloatingTieredWithMinimumPrice.metadata
                additionalProperties =
                    newFloatingTieredWithMinimumPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: CustomRatingFunctionConfigModel) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredWithMinimumPrice =
                NewFloatingTieredWithMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredWithMinimumPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithMinimumConfig == other.tieredWithMinimumConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredWithMinimumConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredWithMinimumPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredWithMinimumConfig=$tieredWithMinimumConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingPackageWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        private val packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun packageWithAllocationConfig(): CustomRatingFunctionConfigModel =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            packageWithAllocationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingPackageWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            packageWithAllocationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingPackageWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .packageWithAllocationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingPackageWithAllocationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingPackageWithAllocationPrice: NewFloatingPackageWithAllocationPrice
            ) = apply {
                cadence = newFloatingPackageWithAllocationPrice.cadence
                currency = newFloatingPackageWithAllocationPrice.currency
                itemId = newFloatingPackageWithAllocationPrice.itemId
                modelType = newFloatingPackageWithAllocationPrice.modelType
                name = newFloatingPackageWithAllocationPrice.name
                packageWithAllocationConfig =
                    newFloatingPackageWithAllocationPrice.packageWithAllocationConfig
                billableMetricId = newFloatingPackageWithAllocationPrice.billableMetricId
                billedInAdvance = newFloatingPackageWithAllocationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingPackageWithAllocationPrice.billingCycleConfiguration
                conversionRate = newFloatingPackageWithAllocationPrice.conversionRate
                externalPriceId = newFloatingPackageWithAllocationPrice.externalPriceId
                fixedPriceQuantity = newFloatingPackageWithAllocationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingPackageWithAllocationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingPackageWithAllocationPrice.invoicingCycleConfiguration
                metadata = newFloatingPackageWithAllocationPrice.metadata
                additionalProperties =
                    newFloatingPackageWithAllocationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: CustomRatingFunctionConfigModel
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingPackageWithAllocationPrice =
                NewFloatingPackageWithAllocationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingPackageWithAllocationPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, packageWithAllocationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingPackageWithAllocationPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredPackageWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        private val tieredPackageWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredPackageWithMinimumConfig(): CustomRatingFunctionConfigModel =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredPackageWithMinimumConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredPackageWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredPackageWithMinimumConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingTieredPackageWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredPackageWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredPackageWithMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredPackageWithMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingTieredPackageWithMinimumPrice: NewFloatingTieredPackageWithMinimumPrice
            ) = apply {
                cadence = newFloatingTieredPackageWithMinimumPrice.cadence
                currency = newFloatingTieredPackageWithMinimumPrice.currency
                itemId = newFloatingTieredPackageWithMinimumPrice.itemId
                modelType = newFloatingTieredPackageWithMinimumPrice.modelType
                name = newFloatingTieredPackageWithMinimumPrice.name
                tieredPackageWithMinimumConfig =
                    newFloatingTieredPackageWithMinimumPrice.tieredPackageWithMinimumConfig
                billableMetricId = newFloatingTieredPackageWithMinimumPrice.billableMetricId
                billedInAdvance = newFloatingTieredPackageWithMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingTieredPackageWithMinimumPrice.billingCycleConfiguration
                conversionRate = newFloatingTieredPackageWithMinimumPrice.conversionRate
                externalPriceId = newFloatingTieredPackageWithMinimumPrice.externalPriceId
                fixedPriceQuantity = newFloatingTieredPackageWithMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingTieredPackageWithMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingTieredPackageWithMinimumPrice.invoicingCycleConfiguration
                metadata = newFloatingTieredPackageWithMinimumPrice.metadata
                additionalProperties =
                    newFloatingTieredPackageWithMinimumPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: CustomRatingFunctionConfigModel
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredPackageWithMinimumPrice =
                NewFloatingTieredPackageWithMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE_WITH_MINIMUM = of("tiered_package_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Value.TIERED_PACKAGE_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Known.TIERED_PACKAGE_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredPackageWithMinimumPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredPackageWithMinimumConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredPackageWithMinimumPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingUnitWithPercentPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        private val unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitWithPercentConfig(): CustomRatingFunctionConfigModel =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithPercentConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingUnitWithPercentPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            unitWithPercentConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingUnitWithPercentPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .unitWithPercentConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingUnitWithPercentPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newFloatingUnitWithPercentPrice: NewFloatingUnitWithPercentPrice) =
                apply {
                    cadence = newFloatingUnitWithPercentPrice.cadence
                    currency = newFloatingUnitWithPercentPrice.currency
                    itemId = newFloatingUnitWithPercentPrice.itemId
                    modelType = newFloatingUnitWithPercentPrice.modelType
                    name = newFloatingUnitWithPercentPrice.name
                    unitWithPercentConfig = newFloatingUnitWithPercentPrice.unitWithPercentConfig
                    billableMetricId = newFloatingUnitWithPercentPrice.billableMetricId
                    billedInAdvance = newFloatingUnitWithPercentPrice.billedInAdvance
                    billingCycleConfiguration =
                        newFloatingUnitWithPercentPrice.billingCycleConfiguration
                    conversionRate = newFloatingUnitWithPercentPrice.conversionRate
                    externalPriceId = newFloatingUnitWithPercentPrice.externalPriceId
                    fixedPriceQuantity = newFloatingUnitWithPercentPrice.fixedPriceQuantity
                    invoiceGroupingKey = newFloatingUnitWithPercentPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newFloatingUnitWithPercentPrice.invoicingCycleConfiguration
                    metadata = newFloatingUnitWithPercentPrice.metadata
                    additionalProperties =
                        newFloatingUnitWithPercentPrice.additionalProperties.toMutableMap()
                }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitWithPercentConfig(unitWithPercentConfig: CustomRatingFunctionConfigModel) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            fun unitWithPercentConfig(
                unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithPercentConfig = unitWithPercentConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingUnitWithPercentPrice =
                NewFloatingUnitWithPercentPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PERCENT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PERCENT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingUnitWithPercentPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithPercentConfig == other.unitWithPercentConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, unitWithPercentConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingUnitWithPercentPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, unitWithPercentConfig=$unitWithPercentConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingTieredWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        private val tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredWithProrationConfig(): CustomRatingFunctionConfigModel =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithProrationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingTieredWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            tieredWithProrationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingTieredWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingTieredWithProrationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingTieredWithProrationPrice: NewFloatingTieredWithProrationPrice
            ) = apply {
                cadence = newFloatingTieredWithProrationPrice.cadence
                currency = newFloatingTieredWithProrationPrice.currency
                itemId = newFloatingTieredWithProrationPrice.itemId
                modelType = newFloatingTieredWithProrationPrice.modelType
                name = newFloatingTieredWithProrationPrice.name
                tieredWithProrationConfig =
                    newFloatingTieredWithProrationPrice.tieredWithProrationConfig
                billableMetricId = newFloatingTieredWithProrationPrice.billableMetricId
                billedInAdvance = newFloatingTieredWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingTieredWithProrationPrice.billingCycleConfiguration
                conversionRate = newFloatingTieredWithProrationPrice.conversionRate
                externalPriceId = newFloatingTieredWithProrationPrice.externalPriceId
                fixedPriceQuantity = newFloatingTieredWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingTieredWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingTieredWithProrationPrice.invoicingCycleConfiguration
                metadata = newFloatingTieredWithProrationPrice.metadata
                additionalProperties =
                    newFloatingTieredWithProrationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: CustomRatingFunctionConfigModel
            ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingTieredWithProrationPrice =
                NewFloatingTieredWithProrationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingTieredWithProrationPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithProrationConfig == other.tieredWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, tieredWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingTieredWithProrationPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, tieredWithProrationConfig=$tieredWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingUnitWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        private val unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitWithProrationConfig(): CustomRatingFunctionConfigModel =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithProrationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingUnitWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            unitWithProrationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingUnitWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .unitWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingUnitWithProrationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingUnitWithProrationPrice: NewFloatingUnitWithProrationPrice
            ) = apply {
                cadence = newFloatingUnitWithProrationPrice.cadence
                currency = newFloatingUnitWithProrationPrice.currency
                itemId = newFloatingUnitWithProrationPrice.itemId
                modelType = newFloatingUnitWithProrationPrice.modelType
                name = newFloatingUnitWithProrationPrice.name
                unitWithProrationConfig = newFloatingUnitWithProrationPrice.unitWithProrationConfig
                billableMetricId = newFloatingUnitWithProrationPrice.billableMetricId
                billedInAdvance = newFloatingUnitWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingUnitWithProrationPrice.billingCycleConfiguration
                conversionRate = newFloatingUnitWithProrationPrice.conversionRate
                externalPriceId = newFloatingUnitWithProrationPrice.externalPriceId
                fixedPriceQuantity = newFloatingUnitWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingUnitWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingUnitWithProrationPrice.invoicingCycleConfiguration
                metadata = newFloatingUnitWithProrationPrice.metadata
                additionalProperties =
                    newFloatingUnitWithProrationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitWithProrationConfig(unitWithProrationConfig: CustomRatingFunctionConfigModel) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingUnitWithProrationPrice =
                NewFloatingUnitWithProrationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingUnitWithProrationPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithProrationConfig == other.unitWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, unitWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingUnitWithProrationPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, unitWithProrationConfig=$unitWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingGroupedAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        private val groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        fun groupedAllocationConfig(): CustomRatingFunctionConfigModel =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedAllocationConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingGroupedAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            groupedAllocationConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingGroupedAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .groupedAllocationConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingGroupedAllocationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingGroupedAllocationPrice: NewFloatingGroupedAllocationPrice
            ) = apply {
                cadence = newFloatingGroupedAllocationPrice.cadence
                currency = newFloatingGroupedAllocationPrice.currency
                groupedAllocationConfig = newFloatingGroupedAllocationPrice.groupedAllocationConfig
                itemId = newFloatingGroupedAllocationPrice.itemId
                modelType = newFloatingGroupedAllocationPrice.modelType
                name = newFloatingGroupedAllocationPrice.name
                billableMetricId = newFloatingGroupedAllocationPrice.billableMetricId
                billedInAdvance = newFloatingGroupedAllocationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingGroupedAllocationPrice.billingCycleConfiguration
                conversionRate = newFloatingGroupedAllocationPrice.conversionRate
                externalPriceId = newFloatingGroupedAllocationPrice.externalPriceId
                fixedPriceQuantity = newFloatingGroupedAllocationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingGroupedAllocationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingGroupedAllocationPrice.invoicingCycleConfiguration
                metadata = newFloatingGroupedAllocationPrice.metadata
                additionalProperties =
                    newFloatingGroupedAllocationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun groupedAllocationConfig(groupedAllocationConfig: CustomRatingFunctionConfigModel) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingGroupedAllocationPrice =
                NewFloatingGroupedAllocationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingGroupedAllocationPrice && cadence == other.cadence && currency == other.currency && groupedAllocationConfig == other.groupedAllocationConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, groupedAllocationConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingGroupedAllocationPrice{cadence=$cadence, currency=$currency, groupedAllocationConfig=$groupedAllocationConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingGroupedWithProratedMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        private val groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        fun groupedWithProratedMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithProratedMinimumConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingGroupedWithProratedMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            groupedWithProratedMinimumConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingGroupedWithProratedMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .groupedWithProratedMinimumConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingGroupedWithProratedMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingGroupedWithProratedMinimumPrice:
                    NewFloatingGroupedWithProratedMinimumPrice
            ) = apply {
                cadence = newFloatingGroupedWithProratedMinimumPrice.cadence
                currency = newFloatingGroupedWithProratedMinimumPrice.currency
                groupedWithProratedMinimumConfig =
                    newFloatingGroupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                itemId = newFloatingGroupedWithProratedMinimumPrice.itemId
                modelType = newFloatingGroupedWithProratedMinimumPrice.modelType
                name = newFloatingGroupedWithProratedMinimumPrice.name
                billableMetricId = newFloatingGroupedWithProratedMinimumPrice.billableMetricId
                billedInAdvance = newFloatingGroupedWithProratedMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingGroupedWithProratedMinimumPrice.billingCycleConfiguration
                conversionRate = newFloatingGroupedWithProratedMinimumPrice.conversionRate
                externalPriceId = newFloatingGroupedWithProratedMinimumPrice.externalPriceId
                fixedPriceQuantity = newFloatingGroupedWithProratedMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingGroupedWithProratedMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingGroupedWithProratedMinimumPrice.invoicingCycleConfiguration
                metadata = newFloatingGroupedWithProratedMinimumPrice.metadata
                additionalProperties =
                    newFloatingGroupedWithProratedMinimumPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingGroupedWithProratedMinimumPrice =
                NewFloatingGroupedWithProratedMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_PRORATED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_PRORATED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingGroupedWithProratedMinimumPrice && cadence == other.cadence && currency == other.currency && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, groupedWithProratedMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingGroupedWithProratedMinimumPrice{cadence=$cadence, currency=$currency, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingGroupedWithMeteredMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        private val groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        fun groupedWithMeteredMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithMeteredMinimumConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingGroupedWithMeteredMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            groupedWithMeteredMinimumConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingGroupedWithMeteredMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .groupedWithMeteredMinimumConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingGroupedWithMeteredMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingGroupedWithMeteredMinimumPrice: NewFloatingGroupedWithMeteredMinimumPrice
            ) = apply {
                cadence = newFloatingGroupedWithMeteredMinimumPrice.cadence
                currency = newFloatingGroupedWithMeteredMinimumPrice.currency
                groupedWithMeteredMinimumConfig =
                    newFloatingGroupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                itemId = newFloatingGroupedWithMeteredMinimumPrice.itemId
                modelType = newFloatingGroupedWithMeteredMinimumPrice.modelType
                name = newFloatingGroupedWithMeteredMinimumPrice.name
                billableMetricId = newFloatingGroupedWithMeteredMinimumPrice.billableMetricId
                billedInAdvance = newFloatingGroupedWithMeteredMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingGroupedWithMeteredMinimumPrice.billingCycleConfiguration
                conversionRate = newFloatingGroupedWithMeteredMinimumPrice.conversionRate
                externalPriceId = newFloatingGroupedWithMeteredMinimumPrice.externalPriceId
                fixedPriceQuantity = newFloatingGroupedWithMeteredMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingGroupedWithMeteredMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingGroupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                metadata = newFloatingGroupedWithMeteredMinimumPrice.metadata
                additionalProperties =
                    newFloatingGroupedWithMeteredMinimumPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingGroupedWithMeteredMinimumPrice =
                NewFloatingGroupedWithMeteredMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_METERED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_METERED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingGroupedWithMeteredMinimumPrice && cadence == other.cadence && currency == other.currency && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, groupedWithMeteredMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingGroupedWithMeteredMinimumPrice{cadence=$cadence, currency=$currency, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingMatrixWithDisplayNamePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        private val matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun matrixWithDisplayNameConfig(): CustomRatingFunctionConfigModel =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<CustomRatingFunctionConfigModel> =
            matrixWithDisplayNameConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingMatrixWithDisplayNamePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            matrixWithDisplayNameConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingMatrixWithDisplayNamePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .matrixWithDisplayNameConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingMatrixWithDisplayNamePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingMatrixWithDisplayNamePrice: NewFloatingMatrixWithDisplayNamePrice
            ) = apply {
                cadence = newFloatingMatrixWithDisplayNamePrice.cadence
                currency = newFloatingMatrixWithDisplayNamePrice.currency
                itemId = newFloatingMatrixWithDisplayNamePrice.itemId
                matrixWithDisplayNameConfig =
                    newFloatingMatrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                modelType = newFloatingMatrixWithDisplayNamePrice.modelType
                name = newFloatingMatrixWithDisplayNamePrice.name
                billableMetricId = newFloatingMatrixWithDisplayNamePrice.billableMetricId
                billedInAdvance = newFloatingMatrixWithDisplayNamePrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingMatrixWithDisplayNamePrice.billingCycleConfiguration
                conversionRate = newFloatingMatrixWithDisplayNamePrice.conversionRate
                externalPriceId = newFloatingMatrixWithDisplayNamePrice.externalPriceId
                fixedPriceQuantity = newFloatingMatrixWithDisplayNamePrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingMatrixWithDisplayNamePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingMatrixWithDisplayNamePrice.invoicingCycleConfiguration
                metadata = newFloatingMatrixWithDisplayNamePrice.metadata
                additionalProperties =
                    newFloatingMatrixWithDisplayNamePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: CustomRatingFunctionConfigModel
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingMatrixWithDisplayNamePrice =
                NewFloatingMatrixWithDisplayNamePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_DISPLAY_NAME
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_DISPLAY_NAME,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingMatrixWithDisplayNamePrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, matrixWithDisplayNameConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingMatrixWithDisplayNamePrice{cadence=$cadence, currency=$currency, itemId=$itemId, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingBulkWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        private val bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkWithProrationConfig(): CustomRatingFunctionConfigModel =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            bulkWithProrationConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingBulkWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            bulkWithProrationConfig().validate()
            cadence()
            currency()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingBulkWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkWithProrationConfig()
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingBulkWithProrationPrice]. */
        class Builder internal constructor() {

            private var bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingBulkWithProrationPrice: NewFloatingBulkWithProrationPrice
            ) = apply {
                bulkWithProrationConfig = newFloatingBulkWithProrationPrice.bulkWithProrationConfig
                cadence = newFloatingBulkWithProrationPrice.cadence
                currency = newFloatingBulkWithProrationPrice.currency
                itemId = newFloatingBulkWithProrationPrice.itemId
                modelType = newFloatingBulkWithProrationPrice.modelType
                name = newFloatingBulkWithProrationPrice.name
                billableMetricId = newFloatingBulkWithProrationPrice.billableMetricId
                billedInAdvance = newFloatingBulkWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingBulkWithProrationPrice.billingCycleConfiguration
                conversionRate = newFloatingBulkWithProrationPrice.conversionRate
                externalPriceId = newFloatingBulkWithProrationPrice.externalPriceId
                fixedPriceQuantity = newFloatingBulkWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingBulkWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingBulkWithProrationPrice.invoicingCycleConfiguration
                metadata = newFloatingBulkWithProrationPrice.metadata
                additionalProperties =
                    newFloatingBulkWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun bulkWithProrationConfig(bulkWithProrationConfig: CustomRatingFunctionConfigModel) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingBulkWithProrationPrice =
                NewFloatingBulkWithProrationPrice(
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingBulkWithProrationPrice && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkWithProrationConfig, cadence, currency, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingBulkWithProrationPrice{bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingGroupedTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        private val groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        fun groupedTieredPackageConfig(): CustomRatingFunctionConfigModel =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedTieredPackageConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingGroupedTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            groupedTieredPackageConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingGroupedTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .groupedTieredPackageConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingGroupedTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingGroupedTieredPackagePrice: NewFloatingGroupedTieredPackagePrice
            ) = apply {
                cadence = newFloatingGroupedTieredPackagePrice.cadence
                currency = newFloatingGroupedTieredPackagePrice.currency
                groupedTieredPackageConfig =
                    newFloatingGroupedTieredPackagePrice.groupedTieredPackageConfig
                itemId = newFloatingGroupedTieredPackagePrice.itemId
                modelType = newFloatingGroupedTieredPackagePrice.modelType
                name = newFloatingGroupedTieredPackagePrice.name
                billableMetricId = newFloatingGroupedTieredPackagePrice.billableMetricId
                billedInAdvance = newFloatingGroupedTieredPackagePrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingGroupedTieredPackagePrice.billingCycleConfiguration
                conversionRate = newFloatingGroupedTieredPackagePrice.conversionRate
                externalPriceId = newFloatingGroupedTieredPackagePrice.externalPriceId
                fixedPriceQuantity = newFloatingGroupedTieredPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingGroupedTieredPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingGroupedTieredPackagePrice.invoicingCycleConfiguration
                metadata = newFloatingGroupedTieredPackagePrice.metadata
                additionalProperties =
                    newFloatingGroupedTieredPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingGroupedTieredPackagePrice =
                NewFloatingGroupedTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingGroupedTieredPackagePrice && cadence == other.cadence && currency == other.currency && groupedTieredPackageConfig == other.groupedTieredPackageConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, groupedTieredPackageConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingGroupedTieredPackagePrice{cadence=$cadence, currency=$currency, groupedTieredPackageConfig=$groupedTieredPackageConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingScalableMatrixWithUnitPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun scalableMatrixWithUnitPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithUnitPricingConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingScalableMatrixWithUnitPricingPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            scalableMatrixWithUnitPricingConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingScalableMatrixWithUnitPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingScalableMatrixWithUnitPricingPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingScalableMatrixWithUnitPricingPrice:
                    NewFloatingScalableMatrixWithUnitPricingPrice
            ) = apply {
                cadence = newFloatingScalableMatrixWithUnitPricingPrice.cadence
                currency = newFloatingScalableMatrixWithUnitPricingPrice.currency
                itemId = newFloatingScalableMatrixWithUnitPricingPrice.itemId
                modelType = newFloatingScalableMatrixWithUnitPricingPrice.modelType
                name = newFloatingScalableMatrixWithUnitPricingPrice.name
                scalableMatrixWithUnitPricingConfig =
                    newFloatingScalableMatrixWithUnitPricingPrice
                        .scalableMatrixWithUnitPricingConfig
                billableMetricId = newFloatingScalableMatrixWithUnitPricingPrice.billableMetricId
                billedInAdvance = newFloatingScalableMatrixWithUnitPricingPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingScalableMatrixWithUnitPricingPrice.billingCycleConfiguration
                conversionRate = newFloatingScalableMatrixWithUnitPricingPrice.conversionRate
                externalPriceId = newFloatingScalableMatrixWithUnitPricingPrice.externalPriceId
                fixedPriceQuantity =
                    newFloatingScalableMatrixWithUnitPricingPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newFloatingScalableMatrixWithUnitPricingPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingScalableMatrixWithUnitPricingPrice.invoicingCycleConfiguration
                metadata = newFloatingScalableMatrixWithUnitPricingPrice.metadata
                additionalProperties =
                    newFloatingScalableMatrixWithUnitPricingPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingScalableMatrixWithUnitPricingPrice =
                NewFloatingScalableMatrixWithUnitPricingPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_UNIT_PRICING = of("scalable_matrix_with_unit_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_UNIT_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_UNIT_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Value.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Known.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingScalableMatrixWithUnitPricingPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, scalableMatrixWithUnitPricingConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingScalableMatrixWithUnitPricingPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingScalableMatrixWithTieredPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun scalableMatrixWithTieredPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithTieredPricingConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingScalableMatrixWithTieredPricingPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            currency()
            itemId()
            modelType()
            name()
            scalableMatrixWithTieredPricingConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingScalableMatrixWithTieredPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingScalableMatrixWithTieredPricingPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingScalableMatrixWithTieredPricingPrice:
                    NewFloatingScalableMatrixWithTieredPricingPrice
            ) = apply {
                cadence = newFloatingScalableMatrixWithTieredPricingPrice.cadence
                currency = newFloatingScalableMatrixWithTieredPricingPrice.currency
                itemId = newFloatingScalableMatrixWithTieredPricingPrice.itemId
                modelType = newFloatingScalableMatrixWithTieredPricingPrice.modelType
                name = newFloatingScalableMatrixWithTieredPricingPrice.name
                scalableMatrixWithTieredPricingConfig =
                    newFloatingScalableMatrixWithTieredPricingPrice
                        .scalableMatrixWithTieredPricingConfig
                billableMetricId = newFloatingScalableMatrixWithTieredPricingPrice.billableMetricId
                billedInAdvance = newFloatingScalableMatrixWithTieredPricingPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingScalableMatrixWithTieredPricingPrice.billingCycleConfiguration
                conversionRate = newFloatingScalableMatrixWithTieredPricingPrice.conversionRate
                externalPriceId = newFloatingScalableMatrixWithTieredPricingPrice.externalPriceId
                fixedPriceQuantity =
                    newFloatingScalableMatrixWithTieredPricingPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newFloatingScalableMatrixWithTieredPricingPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingScalableMatrixWithTieredPricingPrice.invoicingCycleConfiguration
                metadata = newFloatingScalableMatrixWithTieredPricingPrice.metadata
                additionalProperties =
                    newFloatingScalableMatrixWithTieredPricingPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingScalableMatrixWithTieredPricingPrice =
                NewFloatingScalableMatrixWithTieredPricingPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_TIERED_PRICING = of("scalable_matrix_with_tiered_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_TIERED_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_TIERED_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Value.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Known.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingScalableMatrixWithTieredPricingPrice && cadence == other.cadence && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && scalableMatrixWithTieredPricingConfig == other.scalableMatrixWithTieredPricingConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, currency, itemId, modelType, name, scalableMatrixWithTieredPricingConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingScalableMatrixWithTieredPricingPrice{cadence=$cadence, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewFloatingCumulativeGroupedBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        private val cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun cumulativeGroupedBulkConfig(): CustomRatingFunctionConfigModel =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        /** An ISO 4217 currency string for which this price is billed in. */
        fun currency(): String = currency.getRequired("currency")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CustomRatingFunctionConfigModel> =
            cumulativeGroupedBulkConfig

        /** An ISO 4217 currency string for which this price is billed in. */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewFloatingCumulativeGroupedBulkPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            cumulativeGroupedBulkConfig().validate()
            currency()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewFloatingCumulativeGroupedBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewFloatingCumulativeGroupedBulkPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var currency: JsonField<String>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newFloatingCumulativeGroupedBulkPrice: NewFloatingCumulativeGroupedBulkPrice
            ) = apply {
                cadence = newFloatingCumulativeGroupedBulkPrice.cadence
                cumulativeGroupedBulkConfig =
                    newFloatingCumulativeGroupedBulkPrice.cumulativeGroupedBulkConfig
                currency = newFloatingCumulativeGroupedBulkPrice.currency
                itemId = newFloatingCumulativeGroupedBulkPrice.itemId
                modelType = newFloatingCumulativeGroupedBulkPrice.modelType
                name = newFloatingCumulativeGroupedBulkPrice.name
                billableMetricId = newFloatingCumulativeGroupedBulkPrice.billableMetricId
                billedInAdvance = newFloatingCumulativeGroupedBulkPrice.billedInAdvance
                billingCycleConfiguration =
                    newFloatingCumulativeGroupedBulkPrice.billingCycleConfiguration
                conversionRate = newFloatingCumulativeGroupedBulkPrice.conversionRate
                externalPriceId = newFloatingCumulativeGroupedBulkPrice.externalPriceId
                fixedPriceQuantity = newFloatingCumulativeGroupedBulkPrice.fixedPriceQuantity
                invoiceGroupingKey = newFloatingCumulativeGroupedBulkPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newFloatingCumulativeGroupedBulkPrice.invoicingCycleConfiguration
                metadata = newFloatingCumulativeGroupedBulkPrice.metadata
                additionalProperties =
                    newFloatingCumulativeGroupedBulkPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CustomRatingFunctionConfigModel
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: String) = currency(JsonField.of(currency))

            /** An ISO 4217 currency string for which this price is billed in. */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewFloatingCumulativeGroupedBulkPrice =
                NewFloatingCumulativeGroupedBulkPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("currency", currency),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val CUMULATIVE_GROUPED_BULK = of("cumulative_grouped_bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                CUMULATIVE_GROUPED_BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                CUMULATIVE_GROUPED_BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Value.CUMULATIVE_GROUPED_BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Known.CUMULATIVE_GROUPED_BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewFloatingCumulativeGroupedBulkPrice && cadence == other.cadence && cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig && currency == other.currency && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, cumulativeGroupedBulkConfig, currency, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewFloatingCumulativeGroupedBulkPrice{cadence=$cadence, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, currency=$currency, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
    }
}
