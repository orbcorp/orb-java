// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.http.Headers
import com.withorb.api.core.http.QueryParams
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/** This endpoint allows creation of plans including their prices. */
class PlanCreateParams
constructor(
    private val body: PlanCreateBody,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) {

    /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
    fun currency(): String = body.currency()

    fun name(): String = body.name()

    /**
     * Prices for this plan. If the plan has phases, this includes prices across all phases of the
     * plan.
     */
    fun prices(): List<Price> = body.prices()

    /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
    fun defaultInvoiceMemo(): Optional<String> = body.defaultInvoiceMemo()

    fun externalPlanId(): Optional<String> = body.externalPlanId()

    /**
     * User-specified key/value pairs for the resource. Individual keys can be removed by setting
     * the value to `null`, and the entire metadata mapping can be cleared by setting `metadata` to
     * `null`.
     */
    fun metadata(): Optional<Metadata> = body.metadata()

    /**
     * The net terms determines the difference between the invoice date and the issue date for the
     * invoice. If you intend the invoice to be due on issue, set this to 0.
     */
    fun netTerms(): Optional<Long> = body.netTerms()

    /**
     * The status of the plan to create (either active or draft). If not specified, this defaults to
     * active.
     */
    fun status(): Optional<Status> = body.status()

    fun _additionalHeaders(): Headers = additionalHeaders

    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    @JvmSynthetic internal fun getBody(): PlanCreateBody = body

    @JvmSynthetic internal fun getHeaders(): Headers = additionalHeaders

    @JvmSynthetic internal fun getQueryParams(): QueryParams = additionalQueryParams

    @NoAutoDetect
    class PlanCreateBody
    @JsonCreator
    internal constructor(
        @JsonProperty("currency") private val currency: String,
        @JsonProperty("name") private val name: String,
        @JsonProperty("prices") private val prices: List<Price>,
        @JsonProperty("default_invoice_memo") private val defaultInvoiceMemo: String?,
        @JsonProperty("external_plan_id") private val externalPlanId: String?,
        @JsonProperty("metadata") private val metadata: Metadata?,
        @JsonProperty("net_terms") private val netTerms: Long?,
        @JsonProperty("status") private val status: Status?,
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        @JsonProperty("currency") fun currency(): String = currency

        @JsonProperty("name") fun name(): String = name

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        @JsonProperty("prices") fun prices(): List<Price> = prices

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        @JsonProperty("default_invoice_memo")
        fun defaultInvoiceMemo(): Optional<String> = Optional.ofNullable(defaultInvoiceMemo)

        @JsonProperty("external_plan_id")
        fun externalPlanId(): Optional<String> = Optional.ofNullable(externalPlanId)

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        @JsonProperty("net_terms") fun netTerms(): Optional<Long> = Optional.ofNullable(netTerms)

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        @JsonProperty("status") fun status(): Optional<Status> = Optional.ofNullable(status)

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var currency: String? = null
            private var name: String? = null
            private var prices: MutableList<Price>? = null
            private var defaultInvoiceMemo: String? = null
            private var externalPlanId: String? = null
            private var metadata: Metadata? = null
            private var netTerms: Long? = null
            private var status: Status? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(planCreateBody: PlanCreateBody) = apply {
                currency = planCreateBody.currency
                name = planCreateBody.name
                prices = planCreateBody.prices.toMutableList()
                defaultInvoiceMemo = planCreateBody.defaultInvoiceMemo
                externalPlanId = planCreateBody.externalPlanId
                metadata = planCreateBody.metadata
                netTerms = planCreateBody.netTerms
                status = planCreateBody.status
                additionalProperties = planCreateBody.additionalProperties.toMutableMap()
            }

            /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
            fun currency(currency: String) = apply { this.currency = currency }

            fun name(name: String) = apply { this.name = name }

            /**
             * Prices for this plan. If the plan has phases, this includes prices across all phases
             * of the plan.
             */
            fun prices(prices: List<Price>) = apply { this.prices = prices.toMutableList() }

            /**
             * Prices for this plan. If the plan has phases, this includes prices across all phases
             * of the plan.
             */
            fun addPrice(price: Price) = apply {
                prices = (prices ?: mutableListOf()).apply { add(price) }
            }

            /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
            fun defaultInvoiceMemo(defaultInvoiceMemo: String?) = apply {
                this.defaultInvoiceMemo = defaultInvoiceMemo
            }

            /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
            fun defaultInvoiceMemo(defaultInvoiceMemo: Optional<String>) =
                defaultInvoiceMemo(defaultInvoiceMemo.orElse(null))

            fun externalPlanId(externalPlanId: String?) = apply {
                this.externalPlanId = externalPlanId
            }

            fun externalPlanId(externalPlanId: Optional<String>) =
                externalPlanId(externalPlanId.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0.
             */
            fun netTerms(netTerms: Long?) = apply { this.netTerms = netTerms }

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0.
             */
            fun netTerms(netTerms: Long) = netTerms(netTerms as Long?)

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun netTerms(netTerms: Optional<Long>) = netTerms(netTerms.orElse(null) as Long?)

            /**
             * The status of the plan to create (either active or draft). If not specified, this
             * defaults to active.
             */
            fun status(status: Status?) = apply { this.status = status }

            /**
             * The status of the plan to create (either active or draft). If not specified, this
             * defaults to active.
             */
            fun status(status: Optional<Status>) = status(status.orElse(null))

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PlanCreateBody =
                PlanCreateBody(
                    checkNotNull(currency) { "`currency` is required but was not set" },
                    checkNotNull(name) { "`name` is required but was not set" },
                    checkNotNull(prices) { "`prices` is required but was not set" }.toImmutable(),
                    defaultInvoiceMemo,
                    externalPlanId,
                    metadata,
                    netTerms,
                    status,
                    additionalProperties.toImmutable(),
                )
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PlanCreateBody && currency == other.currency && name == other.name && prices == other.prices && defaultInvoiceMemo == other.defaultInvoiceMemo && externalPlanId == other.externalPlanId && metadata == other.metadata && netTerms == other.netTerms && status == other.status && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(currency, name, prices, defaultInvoiceMemo, externalPlanId, metadata, netTerms, status, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PlanCreateBody{currency=$currency, name=$name, prices=$prices, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, metadata=$metadata, netTerms=$netTerms, status=$status, additionalProperties=$additionalProperties}"
    }

    fun toBuilder() = Builder().from(this)

    companion object {

        @JvmStatic fun builder() = Builder()
    }

    @NoAutoDetect
    class Builder {

        private var body: PlanCreateBody.Builder = PlanCreateBody.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        @JvmSynthetic
        internal fun from(planCreateParams: PlanCreateParams) = apply {
            body = planCreateParams.body.toBuilder()
            additionalHeaders = planCreateParams.additionalHeaders.toBuilder()
            additionalQueryParams = planCreateParams.additionalQueryParams.toBuilder()
        }

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        fun currency(currency: String) = apply { body.currency(currency) }

        fun name(name: String) = apply { body.name(name) }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun prices(prices: List<Price>) = apply { body.prices(prices) }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun addPrice(price: Price) = apply { body.addPrice(price) }

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        fun defaultInvoiceMemo(defaultInvoiceMemo: String?) = apply {
            body.defaultInvoiceMemo(defaultInvoiceMemo)
        }

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        fun defaultInvoiceMemo(defaultInvoiceMemo: Optional<String>) =
            defaultInvoiceMemo(defaultInvoiceMemo.orElse(null))

        fun externalPlanId(externalPlanId: String?) = apply { body.externalPlanId(externalPlanId) }

        fun externalPlanId(externalPlanId: Optional<String>) =
            externalPlanId(externalPlanId.orElse(null))

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(metadata: Metadata?) = apply { body.metadata(metadata) }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        fun netTerms(netTerms: Long?) = apply { body.netTerms(netTerms) }

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        fun netTerms(netTerms: Long) = netTerms(netTerms as Long?)

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
        fun netTerms(netTerms: Optional<Long>) = netTerms(netTerms.orElse(null) as Long?)

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        fun status(status: Status?) = apply { body.status(status) }

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        fun status(status: Optional<Status>) = status(status.orElse(null))

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun build(): PlanCreateParams =
            PlanCreateParams(
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    @JsonDeserialize(using = Price.Deserializer::class)
    @JsonSerialize(using = Price.Serializer::class)
    class Price
    private constructor(
        private val newPlanUnitPrice: NewPlanUnitPrice? = null,
        private val newPlanPackagePrice: NewPlanPackagePrice? = null,
        private val newPlanMatrixPrice: NewPlanMatrixPrice? = null,
        private val newPlanTieredPrice: NewPlanTieredPrice? = null,
        private val newPlanTieredBpsPrice: NewPlanTieredBpsPrice? = null,
        private val newPlanBpsPrice: NewPlanBpsPrice? = null,
        private val newPlanBulkBpsPrice: NewPlanBulkBpsPrice? = null,
        private val newPlanBulkPrice: NewPlanBulkPrice? = null,
        private val newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice? = null,
        private val newPlanTieredPackagePrice: NewPlanTieredPackagePrice? = null,
        private val newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice? = null,
        private val newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice? = null,
        private val newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice? = null,
        private val newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice? = null,
        private val newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice? = null,
        private val newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice? = null,
        private val newPlanGroupedWithProratedMinimumPrice:
            NewPlanGroupedWithProratedMinimumPrice? =
            null,
        private val newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice? =
            null,
        private val newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice? = null,
        private val newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice? = null,
        private val newPlanGroupedTieredPackagePrice: NewPlanGroupedTieredPackagePrice? = null,
        private val _json: JsonValue? = null,
    ) {

        fun newPlanUnitPrice(): Optional<NewPlanUnitPrice> = Optional.ofNullable(newPlanUnitPrice)

        fun newPlanPackagePrice(): Optional<NewPlanPackagePrice> =
            Optional.ofNullable(newPlanPackagePrice)

        fun newPlanMatrixPrice(): Optional<NewPlanMatrixPrice> =
            Optional.ofNullable(newPlanMatrixPrice)

        fun newPlanTieredPrice(): Optional<NewPlanTieredPrice> =
            Optional.ofNullable(newPlanTieredPrice)

        fun newPlanTieredBpsPrice(): Optional<NewPlanTieredBpsPrice> =
            Optional.ofNullable(newPlanTieredBpsPrice)

        fun newPlanBpsPrice(): Optional<NewPlanBpsPrice> = Optional.ofNullable(newPlanBpsPrice)

        fun newPlanBulkBpsPrice(): Optional<NewPlanBulkBpsPrice> =
            Optional.ofNullable(newPlanBulkBpsPrice)

        fun newPlanBulkPrice(): Optional<NewPlanBulkPrice> = Optional.ofNullable(newPlanBulkPrice)

        fun newPlanThresholdTotalAmountPrice(): Optional<NewPlanThresholdTotalAmountPrice> =
            Optional.ofNullable(newPlanThresholdTotalAmountPrice)

        fun newPlanTieredPackagePrice(): Optional<NewPlanTieredPackagePrice> =
            Optional.ofNullable(newPlanTieredPackagePrice)

        fun newPlanTieredWithMinimumPrice(): Optional<NewPlanTieredWithMinimumPrice> =
            Optional.ofNullable(newPlanTieredWithMinimumPrice)

        fun newPlanUnitWithPercentPrice(): Optional<NewPlanUnitWithPercentPrice> =
            Optional.ofNullable(newPlanUnitWithPercentPrice)

        fun newPlanPackageWithAllocationPrice(): Optional<NewPlanPackageWithAllocationPrice> =
            Optional.ofNullable(newPlanPackageWithAllocationPrice)

        fun newPlanTierWithProrationPrice(): Optional<NewPlanTierWithProrationPrice> =
            Optional.ofNullable(newPlanTierWithProrationPrice)

        fun newPlanUnitWithProrationPrice(): Optional<NewPlanUnitWithProrationPrice> =
            Optional.ofNullable(newPlanUnitWithProrationPrice)

        fun newPlanGroupedAllocationPrice(): Optional<NewPlanGroupedAllocationPrice> =
            Optional.ofNullable(newPlanGroupedAllocationPrice)

        fun newPlanGroupedWithProratedMinimumPrice():
            Optional<NewPlanGroupedWithProratedMinimumPrice> =
            Optional.ofNullable(newPlanGroupedWithProratedMinimumPrice)

        fun newPlanGroupedWithMeteredMinimumPrice():
            Optional<NewPlanGroupedWithMeteredMinimumPrice> =
            Optional.ofNullable(newPlanGroupedWithMeteredMinimumPrice)

        fun newPlanMatrixWithDisplayNamePrice(): Optional<NewPlanMatrixWithDisplayNamePrice> =
            Optional.ofNullable(newPlanMatrixWithDisplayNamePrice)

        fun newPlanBulkWithProrationPrice(): Optional<NewPlanBulkWithProrationPrice> =
            Optional.ofNullable(newPlanBulkWithProrationPrice)

        fun newPlanGroupedTieredPackagePrice(): Optional<NewPlanGroupedTieredPackagePrice> =
            Optional.ofNullable(newPlanGroupedTieredPackagePrice)

        fun isNewPlanUnitPrice(): Boolean = newPlanUnitPrice != null

        fun isNewPlanPackagePrice(): Boolean = newPlanPackagePrice != null

        fun isNewPlanMatrixPrice(): Boolean = newPlanMatrixPrice != null

        fun isNewPlanTieredPrice(): Boolean = newPlanTieredPrice != null

        fun isNewPlanTieredBpsPrice(): Boolean = newPlanTieredBpsPrice != null

        fun isNewPlanBpsPrice(): Boolean = newPlanBpsPrice != null

        fun isNewPlanBulkBpsPrice(): Boolean = newPlanBulkBpsPrice != null

        fun isNewPlanBulkPrice(): Boolean = newPlanBulkPrice != null

        fun isNewPlanThresholdTotalAmountPrice(): Boolean = newPlanThresholdTotalAmountPrice != null

        fun isNewPlanTieredPackagePrice(): Boolean = newPlanTieredPackagePrice != null

        fun isNewPlanTieredWithMinimumPrice(): Boolean = newPlanTieredWithMinimumPrice != null

        fun isNewPlanUnitWithPercentPrice(): Boolean = newPlanUnitWithPercentPrice != null

        fun isNewPlanPackageWithAllocationPrice(): Boolean =
            newPlanPackageWithAllocationPrice != null

        fun isNewPlanTierWithProrationPrice(): Boolean = newPlanTierWithProrationPrice != null

        fun isNewPlanUnitWithProrationPrice(): Boolean = newPlanUnitWithProrationPrice != null

        fun isNewPlanGroupedAllocationPrice(): Boolean = newPlanGroupedAllocationPrice != null

        fun isNewPlanGroupedWithProratedMinimumPrice(): Boolean =
            newPlanGroupedWithProratedMinimumPrice != null

        fun isNewPlanGroupedWithMeteredMinimumPrice(): Boolean =
            newPlanGroupedWithMeteredMinimumPrice != null

        fun isNewPlanMatrixWithDisplayNamePrice(): Boolean =
            newPlanMatrixWithDisplayNamePrice != null

        fun isNewPlanBulkWithProrationPrice(): Boolean = newPlanBulkWithProrationPrice != null

        fun isNewPlanGroupedTieredPackagePrice(): Boolean = newPlanGroupedTieredPackagePrice != null

        fun asNewPlanUnitPrice(): NewPlanUnitPrice = newPlanUnitPrice.getOrThrow("newPlanUnitPrice")

        fun asNewPlanPackagePrice(): NewPlanPackagePrice =
            newPlanPackagePrice.getOrThrow("newPlanPackagePrice")

        fun asNewPlanMatrixPrice(): NewPlanMatrixPrice =
            newPlanMatrixPrice.getOrThrow("newPlanMatrixPrice")

        fun asNewPlanTieredPrice(): NewPlanTieredPrice =
            newPlanTieredPrice.getOrThrow("newPlanTieredPrice")

        fun asNewPlanTieredBpsPrice(): NewPlanTieredBpsPrice =
            newPlanTieredBpsPrice.getOrThrow("newPlanTieredBpsPrice")

        fun asNewPlanBpsPrice(): NewPlanBpsPrice = newPlanBpsPrice.getOrThrow("newPlanBpsPrice")

        fun asNewPlanBulkBpsPrice(): NewPlanBulkBpsPrice =
            newPlanBulkBpsPrice.getOrThrow("newPlanBulkBpsPrice")

        fun asNewPlanBulkPrice(): NewPlanBulkPrice = newPlanBulkPrice.getOrThrow("newPlanBulkPrice")

        fun asNewPlanThresholdTotalAmountPrice(): NewPlanThresholdTotalAmountPrice =
            newPlanThresholdTotalAmountPrice.getOrThrow("newPlanThresholdTotalAmountPrice")

        fun asNewPlanTieredPackagePrice(): NewPlanTieredPackagePrice =
            newPlanTieredPackagePrice.getOrThrow("newPlanTieredPackagePrice")

        fun asNewPlanTieredWithMinimumPrice(): NewPlanTieredWithMinimumPrice =
            newPlanTieredWithMinimumPrice.getOrThrow("newPlanTieredWithMinimumPrice")

        fun asNewPlanUnitWithPercentPrice(): NewPlanUnitWithPercentPrice =
            newPlanUnitWithPercentPrice.getOrThrow("newPlanUnitWithPercentPrice")

        fun asNewPlanPackageWithAllocationPrice(): NewPlanPackageWithAllocationPrice =
            newPlanPackageWithAllocationPrice.getOrThrow("newPlanPackageWithAllocationPrice")

        fun asNewPlanTierWithProrationPrice(): NewPlanTierWithProrationPrice =
            newPlanTierWithProrationPrice.getOrThrow("newPlanTierWithProrationPrice")

        fun asNewPlanUnitWithProrationPrice(): NewPlanUnitWithProrationPrice =
            newPlanUnitWithProrationPrice.getOrThrow("newPlanUnitWithProrationPrice")

        fun asNewPlanGroupedAllocationPrice(): NewPlanGroupedAllocationPrice =
            newPlanGroupedAllocationPrice.getOrThrow("newPlanGroupedAllocationPrice")

        fun asNewPlanGroupedWithProratedMinimumPrice(): NewPlanGroupedWithProratedMinimumPrice =
            newPlanGroupedWithProratedMinimumPrice.getOrThrow(
                "newPlanGroupedWithProratedMinimumPrice"
            )

        fun asNewPlanGroupedWithMeteredMinimumPrice(): NewPlanGroupedWithMeteredMinimumPrice =
            newPlanGroupedWithMeteredMinimumPrice.getOrThrow(
                "newPlanGroupedWithMeteredMinimumPrice"
            )

        fun asNewPlanMatrixWithDisplayNamePrice(): NewPlanMatrixWithDisplayNamePrice =
            newPlanMatrixWithDisplayNamePrice.getOrThrow("newPlanMatrixWithDisplayNamePrice")

        fun asNewPlanBulkWithProrationPrice(): NewPlanBulkWithProrationPrice =
            newPlanBulkWithProrationPrice.getOrThrow("newPlanBulkWithProrationPrice")

        fun asNewPlanGroupedTieredPackagePrice(): NewPlanGroupedTieredPackagePrice =
            newPlanGroupedTieredPackagePrice.getOrThrow("newPlanGroupedTieredPackagePrice")

        fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                newPlanUnitPrice != null -> visitor.visitNewPlanUnitPrice(newPlanUnitPrice)
                newPlanPackagePrice != null -> visitor.visitNewPlanPackagePrice(newPlanPackagePrice)
                newPlanMatrixPrice != null -> visitor.visitNewPlanMatrixPrice(newPlanMatrixPrice)
                newPlanTieredPrice != null -> visitor.visitNewPlanTieredPrice(newPlanTieredPrice)
                newPlanTieredBpsPrice != null ->
                    visitor.visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice)
                newPlanBpsPrice != null -> visitor.visitNewPlanBpsPrice(newPlanBpsPrice)
                newPlanBulkBpsPrice != null -> visitor.visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice)
                newPlanBulkPrice != null -> visitor.visitNewPlanBulkPrice(newPlanBulkPrice)
                newPlanThresholdTotalAmountPrice != null ->
                    visitor.visitNewPlanThresholdTotalAmountPrice(newPlanThresholdTotalAmountPrice)
                newPlanTieredPackagePrice != null ->
                    visitor.visitNewPlanTieredPackagePrice(newPlanTieredPackagePrice)
                newPlanTieredWithMinimumPrice != null ->
                    visitor.visitNewPlanTieredWithMinimumPrice(newPlanTieredWithMinimumPrice)
                newPlanUnitWithPercentPrice != null ->
                    visitor.visitNewPlanUnitWithPercentPrice(newPlanUnitWithPercentPrice)
                newPlanPackageWithAllocationPrice != null ->
                    visitor.visitNewPlanPackageWithAllocationPrice(
                        newPlanPackageWithAllocationPrice
                    )
                newPlanTierWithProrationPrice != null ->
                    visitor.visitNewPlanTierWithProrationPrice(newPlanTierWithProrationPrice)
                newPlanUnitWithProrationPrice != null ->
                    visitor.visitNewPlanUnitWithProrationPrice(newPlanUnitWithProrationPrice)
                newPlanGroupedAllocationPrice != null ->
                    visitor.visitNewPlanGroupedAllocationPrice(newPlanGroupedAllocationPrice)
                newPlanGroupedWithProratedMinimumPrice != null ->
                    visitor.visitNewPlanGroupedWithProratedMinimumPrice(
                        newPlanGroupedWithProratedMinimumPrice
                    )
                newPlanGroupedWithMeteredMinimumPrice != null ->
                    visitor.visitNewPlanGroupedWithMeteredMinimumPrice(
                        newPlanGroupedWithMeteredMinimumPrice
                    )
                newPlanMatrixWithDisplayNamePrice != null ->
                    visitor.visitNewPlanMatrixWithDisplayNamePrice(
                        newPlanMatrixWithDisplayNamePrice
                    )
                newPlanBulkWithProrationPrice != null ->
                    visitor.visitNewPlanBulkWithProrationPrice(newPlanBulkWithProrationPrice)
                newPlanGroupedTieredPackagePrice != null ->
                    visitor.visitNewPlanGroupedTieredPackagePrice(newPlanGroupedTieredPackagePrice)
                else -> visitor.unknown(_json)
            }
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Price && newPlanUnitPrice == other.newPlanUnitPrice && newPlanPackagePrice == other.newPlanPackagePrice && newPlanMatrixPrice == other.newPlanMatrixPrice && newPlanTieredPrice == other.newPlanTieredPrice && newPlanTieredBpsPrice == other.newPlanTieredBpsPrice && newPlanBpsPrice == other.newPlanBpsPrice && newPlanBulkBpsPrice == other.newPlanBulkBpsPrice && newPlanBulkPrice == other.newPlanBulkPrice && newPlanThresholdTotalAmountPrice == other.newPlanThresholdTotalAmountPrice && newPlanTieredPackagePrice == other.newPlanTieredPackagePrice && newPlanTieredWithMinimumPrice == other.newPlanTieredWithMinimumPrice && newPlanUnitWithPercentPrice == other.newPlanUnitWithPercentPrice && newPlanPackageWithAllocationPrice == other.newPlanPackageWithAllocationPrice && newPlanTierWithProrationPrice == other.newPlanTierWithProrationPrice && newPlanUnitWithProrationPrice == other.newPlanUnitWithProrationPrice && newPlanGroupedAllocationPrice == other.newPlanGroupedAllocationPrice && newPlanGroupedWithProratedMinimumPrice == other.newPlanGroupedWithProratedMinimumPrice && newPlanGroupedWithMeteredMinimumPrice == other.newPlanGroupedWithMeteredMinimumPrice && newPlanMatrixWithDisplayNamePrice == other.newPlanMatrixWithDisplayNamePrice && newPlanBulkWithProrationPrice == other.newPlanBulkWithProrationPrice && newPlanGroupedTieredPackagePrice == other.newPlanGroupedTieredPackagePrice /* spotless:on */
        }

        override fun hashCode(): Int = /* spotless:off */ Objects.hash(newPlanUnitPrice, newPlanPackagePrice, newPlanMatrixPrice, newPlanTieredPrice, newPlanTieredBpsPrice, newPlanBpsPrice, newPlanBulkBpsPrice, newPlanBulkPrice, newPlanThresholdTotalAmountPrice, newPlanTieredPackagePrice, newPlanTieredWithMinimumPrice, newPlanUnitWithPercentPrice, newPlanPackageWithAllocationPrice, newPlanTierWithProrationPrice, newPlanUnitWithProrationPrice, newPlanGroupedAllocationPrice, newPlanGroupedWithProratedMinimumPrice, newPlanGroupedWithMeteredMinimumPrice, newPlanMatrixWithDisplayNamePrice, newPlanBulkWithProrationPrice, newPlanGroupedTieredPackagePrice) /* spotless:on */

        override fun toString(): String =
            when {
                newPlanUnitPrice != null -> "Price{newPlanUnitPrice=$newPlanUnitPrice}"
                newPlanPackagePrice != null -> "Price{newPlanPackagePrice=$newPlanPackagePrice}"
                newPlanMatrixPrice != null -> "Price{newPlanMatrixPrice=$newPlanMatrixPrice}"
                newPlanTieredPrice != null -> "Price{newPlanTieredPrice=$newPlanTieredPrice}"
                newPlanTieredBpsPrice != null ->
                    "Price{newPlanTieredBpsPrice=$newPlanTieredBpsPrice}"
                newPlanBpsPrice != null -> "Price{newPlanBpsPrice=$newPlanBpsPrice}"
                newPlanBulkBpsPrice != null -> "Price{newPlanBulkBpsPrice=$newPlanBulkBpsPrice}"
                newPlanBulkPrice != null -> "Price{newPlanBulkPrice=$newPlanBulkPrice}"
                newPlanThresholdTotalAmountPrice != null ->
                    "Price{newPlanThresholdTotalAmountPrice=$newPlanThresholdTotalAmountPrice}"
                newPlanTieredPackagePrice != null ->
                    "Price{newPlanTieredPackagePrice=$newPlanTieredPackagePrice}"
                newPlanTieredWithMinimumPrice != null ->
                    "Price{newPlanTieredWithMinimumPrice=$newPlanTieredWithMinimumPrice}"
                newPlanUnitWithPercentPrice != null ->
                    "Price{newPlanUnitWithPercentPrice=$newPlanUnitWithPercentPrice}"
                newPlanPackageWithAllocationPrice != null ->
                    "Price{newPlanPackageWithAllocationPrice=$newPlanPackageWithAllocationPrice}"
                newPlanTierWithProrationPrice != null ->
                    "Price{newPlanTierWithProrationPrice=$newPlanTierWithProrationPrice}"
                newPlanUnitWithProrationPrice != null ->
                    "Price{newPlanUnitWithProrationPrice=$newPlanUnitWithProrationPrice}"
                newPlanGroupedAllocationPrice != null ->
                    "Price{newPlanGroupedAllocationPrice=$newPlanGroupedAllocationPrice}"
                newPlanGroupedWithProratedMinimumPrice != null ->
                    "Price{newPlanGroupedWithProratedMinimumPrice=$newPlanGroupedWithProratedMinimumPrice}"
                newPlanGroupedWithMeteredMinimumPrice != null ->
                    "Price{newPlanGroupedWithMeteredMinimumPrice=$newPlanGroupedWithMeteredMinimumPrice}"
                newPlanMatrixWithDisplayNamePrice != null ->
                    "Price{newPlanMatrixWithDisplayNamePrice=$newPlanMatrixWithDisplayNamePrice}"
                newPlanBulkWithProrationPrice != null ->
                    "Price{newPlanBulkWithProrationPrice=$newPlanBulkWithProrationPrice}"
                newPlanGroupedTieredPackagePrice != null ->
                    "Price{newPlanGroupedTieredPackagePrice=$newPlanGroupedTieredPackagePrice}"
                _json != null -> "Price{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Price")
            }

        companion object {

            @JvmStatic
            fun ofNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice) =
                Price(newPlanUnitPrice = newPlanUnitPrice)

            @JvmStatic
            fun ofNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice) =
                Price(newPlanPackagePrice = newPlanPackagePrice)

            @JvmStatic
            fun ofNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice) =
                Price(newPlanMatrixPrice = newPlanMatrixPrice)

            @JvmStatic
            fun ofNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice) =
                Price(newPlanTieredPrice = newPlanTieredPrice)

            @JvmStatic
            fun ofNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) =
                Price(newPlanTieredBpsPrice = newPlanTieredBpsPrice)

            @JvmStatic
            fun ofNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice) =
                Price(newPlanBpsPrice = newPlanBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) =
                Price(newPlanBulkBpsPrice = newPlanBulkBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice) =
                Price(newPlanBulkPrice = newPlanBulkPrice)

            @JvmStatic
            fun ofNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ) = Price(newPlanThresholdTotalAmountPrice = newPlanThresholdTotalAmountPrice)

            @JvmStatic
            fun ofNewPlanTieredPackagePrice(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) =
                Price(newPlanTieredPackagePrice = newPlanTieredPackagePrice)

            @JvmStatic
            fun ofNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ) = Price(newPlanTieredWithMinimumPrice = newPlanTieredWithMinimumPrice)

            @JvmStatic
            fun ofNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ) = Price(newPlanUnitWithPercentPrice = newPlanUnitWithPercentPrice)

            @JvmStatic
            fun ofNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ) = Price(newPlanPackageWithAllocationPrice = newPlanPackageWithAllocationPrice)

            @JvmStatic
            fun ofNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ) = Price(newPlanTierWithProrationPrice = newPlanTierWithProrationPrice)

            @JvmStatic
            fun ofNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ) = Price(newPlanUnitWithProrationPrice = newPlanUnitWithProrationPrice)

            @JvmStatic
            fun ofNewPlanGroupedAllocationPrice(
                newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice
            ) = Price(newPlanGroupedAllocationPrice = newPlanGroupedAllocationPrice)

            @JvmStatic
            fun ofNewPlanGroupedWithProratedMinimumPrice(
                newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
            ) =
                Price(
                    newPlanGroupedWithProratedMinimumPrice = newPlanGroupedWithProratedMinimumPrice
                )

            @JvmStatic
            fun ofNewPlanGroupedWithMeteredMinimumPrice(
                newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
            ) = Price(newPlanGroupedWithMeteredMinimumPrice = newPlanGroupedWithMeteredMinimumPrice)

            @JvmStatic
            fun ofNewPlanMatrixWithDisplayNamePrice(
                newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
            ) = Price(newPlanMatrixWithDisplayNamePrice = newPlanMatrixWithDisplayNamePrice)

            @JvmStatic
            fun ofNewPlanBulkWithProrationPrice(
                newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice
            ) = Price(newPlanBulkWithProrationPrice = newPlanBulkWithProrationPrice)

            @JvmStatic
            fun ofNewPlanGroupedTieredPackagePrice(
                newPlanGroupedTieredPackagePrice: NewPlanGroupedTieredPackagePrice
            ) = Price(newPlanGroupedTieredPackagePrice = newPlanGroupedTieredPackagePrice)
        }

        interface Visitor<out T> {

            fun visitNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice): T

            fun visitNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice): T

            fun visitNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice): T

            fun visitNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice): T

            fun visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice): T

            fun visitNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice): T

            fun visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice): T

            fun visitNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice): T

            fun visitNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ): T

            fun visitNewPlanTieredPackagePrice(
                newPlanTieredPackagePrice: NewPlanTieredPackagePrice
            ): T

            fun visitNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ): T

            fun visitNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ): T

            fun visitNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ): T

            fun visitNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ): T

            fun visitNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ): T

            fun visitNewPlanGroupedAllocationPrice(
                newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice
            ): T

            fun visitNewPlanGroupedWithProratedMinimumPrice(
                newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
            ): T

            fun visitNewPlanGroupedWithMeteredMinimumPrice(
                newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
            ): T

            fun visitNewPlanMatrixWithDisplayNamePrice(
                newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
            ): T

            fun visitNewPlanBulkWithProrationPrice(
                newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice
            ): T

            fun visitNewPlanGroupedTieredPackagePrice(
                newPlanGroupedTieredPackagePrice: NewPlanGroupedTieredPackagePrice
            ): T

            fun unknown(json: JsonValue?): T {
                throw OrbInvalidDataException("Unknown Price: $json")
            }
        }

        class Deserializer : BaseDeserializer<Price>(Price::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Price {
                val json = JsonValue.fromJsonNode(node)
                val modelType =
                    json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

                when (modelType) {
                    "unit" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitPrice>())?.let {
                            return Price(newPlanUnitPrice = it, _json = json)
                        }
                    }
                    "package" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanPackagePrice>())?.let {
                            return Price(newPlanPackagePrice = it, _json = json)
                        }
                    }
                    "matrix" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanMatrixPrice>())?.let {
                            return Price(newPlanMatrixPrice = it, _json = json)
                        }
                    }
                    "tiered" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredPrice>())?.let {
                            return Price(newPlanTieredPrice = it, _json = json)
                        }
                    }
                    "tiered_bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredBpsPrice>())?.let {
                            return Price(newPlanTieredBpsPrice = it, _json = json)
                        }
                    }
                    "bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBpsPrice>())?.let {
                            return Price(newPlanBpsPrice = it, _json = json)
                        }
                    }
                    "bulk_bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkBpsPrice>())?.let {
                            return Price(newPlanBulkBpsPrice = it, _json = json)
                        }
                    }
                    "bulk" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkPrice>())?.let {
                            return Price(newPlanBulkPrice = it, _json = json)
                        }
                    }
                    "threshold_total_amount" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanThresholdTotalAmountPrice>())
                            ?.let {
                                return Price(newPlanThresholdTotalAmountPrice = it, _json = json)
                            }
                    }
                    "tiered_package" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredPackagePrice>())?.let {
                            return Price(newPlanTieredPackagePrice = it, _json = json)
                        }
                    }
                    "tiered_with_minimum" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredWithMinimumPrice>())?.let {
                            return Price(newPlanTieredWithMinimumPrice = it, _json = json)
                        }
                    }
                    "unit_with_percent" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithPercentPrice>())?.let {
                            return Price(newPlanUnitWithPercentPrice = it, _json = json)
                        }
                    }
                    "package_with_allocation" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanPackageWithAllocationPrice>())
                            ?.let {
                                return Price(newPlanPackageWithAllocationPrice = it, _json = json)
                            }
                    }
                    "tiered_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTierWithProrationPrice>())?.let {
                            return Price(newPlanTierWithProrationPrice = it, _json = json)
                        }
                    }
                    "unit_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithProrationPrice>())?.let {
                            return Price(newPlanUnitWithProrationPrice = it, _json = json)
                        }
                    }
                    "grouped_allocation" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanGroupedAllocationPrice>())?.let {
                            return Price(newPlanGroupedAllocationPrice = it, _json = json)
                        }
                    }
                    "grouped_with_prorated_minimum" -> {
                        tryDeserialize(
                                node,
                                jacksonTypeRef<NewPlanGroupedWithProratedMinimumPrice>()
                            )
                            ?.let {
                                return Price(
                                    newPlanGroupedWithProratedMinimumPrice = it,
                                    _json = json
                                )
                            }
                    }
                    "grouped_with_metered_minimum" -> {
                        tryDeserialize(
                                node,
                                jacksonTypeRef<NewPlanGroupedWithMeteredMinimumPrice>()
                            )
                            ?.let {
                                return Price(
                                    newPlanGroupedWithMeteredMinimumPrice = it,
                                    _json = json
                                )
                            }
                    }
                    "matrix_with_display_name" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanMatrixWithDisplayNamePrice>())
                            ?.let {
                                return Price(newPlanMatrixWithDisplayNamePrice = it, _json = json)
                            }
                    }
                    "bulk_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkWithProrationPrice>())?.let {
                            return Price(newPlanBulkWithProrationPrice = it, _json = json)
                        }
                    }
                    "grouped_tiered_package" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanGroupedTieredPackagePrice>())
                            ?.let {
                                return Price(newPlanGroupedTieredPackagePrice = it, _json = json)
                            }
                    }
                }

                return Price(_json = json)
            }
        }

        class Serializer : BaseSerializer<Price>(Price::class) {

            override fun serialize(
                value: Price,
                generator: JsonGenerator,
                provider: SerializerProvider
            ) {
                when {
                    value.newPlanUnitPrice != null -> generator.writeObject(value.newPlanUnitPrice)
                    value.newPlanPackagePrice != null ->
                        generator.writeObject(value.newPlanPackagePrice)
                    value.newPlanMatrixPrice != null ->
                        generator.writeObject(value.newPlanMatrixPrice)
                    value.newPlanTieredPrice != null ->
                        generator.writeObject(value.newPlanTieredPrice)
                    value.newPlanTieredBpsPrice != null ->
                        generator.writeObject(value.newPlanTieredBpsPrice)
                    value.newPlanBpsPrice != null -> generator.writeObject(value.newPlanBpsPrice)
                    value.newPlanBulkBpsPrice != null ->
                        generator.writeObject(value.newPlanBulkBpsPrice)
                    value.newPlanBulkPrice != null -> generator.writeObject(value.newPlanBulkPrice)
                    value.newPlanThresholdTotalAmountPrice != null ->
                        generator.writeObject(value.newPlanThresholdTotalAmountPrice)
                    value.newPlanTieredPackagePrice != null ->
                        generator.writeObject(value.newPlanTieredPackagePrice)
                    value.newPlanTieredWithMinimumPrice != null ->
                        generator.writeObject(value.newPlanTieredWithMinimumPrice)
                    value.newPlanUnitWithPercentPrice != null ->
                        generator.writeObject(value.newPlanUnitWithPercentPrice)
                    value.newPlanPackageWithAllocationPrice != null ->
                        generator.writeObject(value.newPlanPackageWithAllocationPrice)
                    value.newPlanTierWithProrationPrice != null ->
                        generator.writeObject(value.newPlanTierWithProrationPrice)
                    value.newPlanUnitWithProrationPrice != null ->
                        generator.writeObject(value.newPlanUnitWithProrationPrice)
                    value.newPlanGroupedAllocationPrice != null ->
                        generator.writeObject(value.newPlanGroupedAllocationPrice)
                    value.newPlanGroupedWithProratedMinimumPrice != null ->
                        generator.writeObject(value.newPlanGroupedWithProratedMinimumPrice)
                    value.newPlanGroupedWithMeteredMinimumPrice != null ->
                        generator.writeObject(value.newPlanGroupedWithMeteredMinimumPrice)
                    value.newPlanMatrixWithDisplayNamePrice != null ->
                        generator.writeObject(value.newPlanMatrixWithDisplayNamePrice)
                    value.newPlanBulkWithProrationPrice != null ->
                        generator.writeObject(value.newPlanBulkWithProrationPrice)
                    value.newPlanGroupedTieredPackagePrice != null ->
                        generator.writeObject(value.newPlanGroupedTieredPackagePrice)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Price")
                }
            }
        }

        @NoAutoDetect
        class NewPlanUnitPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("unit_config") private val unitConfig: UnitConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("unit_config") fun unitConfig(): UnitConfig = unitConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var unitConfig: UnitConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitPrice: NewPlanUnitPrice) = apply {
                    cadence = newPlanUnitPrice.cadence
                    itemId = newPlanUnitPrice.itemId
                    modelType = newPlanUnitPrice.modelType
                    name = newPlanUnitPrice.name
                    unitConfig = newPlanUnitPrice.unitConfig
                    billableMetricId = newPlanUnitPrice.billableMetricId
                    billedInAdvance = newPlanUnitPrice.billedInAdvance
                    billingCycleConfiguration = newPlanUnitPrice.billingCycleConfiguration
                    conversionRate = newPlanUnitPrice.conversionRate
                    currency = newPlanUnitPrice.currency
                    externalPriceId = newPlanUnitPrice.externalPriceId
                    fixedPriceQuantity = newPlanUnitPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanUnitPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanUnitPrice.invoicingCycleConfiguration
                    metadata = newPlanUnitPrice.metadata
                    additionalProperties = newPlanUnitPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun unitConfig(unitConfig: UnitConfig) = apply { this.unitConfig = unitConfig }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanUnitPrice =
                    NewPlanUnitPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(unitConfig) { "`unitConfig` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val UNIT = of("unit")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT,
                }

                enum class Value {
                    UNIT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT -> Value.UNIT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT -> Known.UNIT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class UnitConfig
            @JsonCreator
            private constructor(
                @JsonProperty("unit_amount") private val unitAmount: String,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Rate per unit of usage */
                @JsonProperty("unit_amount") fun unitAmount(): String = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var unitAmount: String? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitConfig: UnitConfig) = apply {
                        unitAmount = unitConfig.unitAmount
                        additionalProperties = unitConfig.additionalProperties.toMutableMap()
                    }

                    /** Rate per unit of usage */
                    fun unitAmount(unitAmount: String) = apply { this.unitAmount = unitAmount }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): UnitConfig =
                        UnitConfig(
                            checkNotNull(unitAmount) { "`unitAmount` is required but was not set" },
                            additionalProperties.toImmutable()
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitConfig && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(unitAmount, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitConfig == other.unitConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanUnitPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitConfig=$unitConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanPackagePrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("package_config") private val packageConfig: PackageConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("package_config") fun packageConfig(): PackageConfig = packageConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var packageConfig: PackageConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanPackagePrice: NewPlanPackagePrice) = apply {
                    cadence = newPlanPackagePrice.cadence
                    itemId = newPlanPackagePrice.itemId
                    modelType = newPlanPackagePrice.modelType
                    name = newPlanPackagePrice.name
                    packageConfig = newPlanPackagePrice.packageConfig
                    billableMetricId = newPlanPackagePrice.billableMetricId
                    billedInAdvance = newPlanPackagePrice.billedInAdvance
                    billingCycleConfiguration = newPlanPackagePrice.billingCycleConfiguration
                    conversionRate = newPlanPackagePrice.conversionRate
                    currency = newPlanPackagePrice.currency
                    externalPriceId = newPlanPackagePrice.externalPriceId
                    fixedPriceQuantity = newPlanPackagePrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanPackagePrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanPackagePrice.invoicingCycleConfiguration
                    metadata = newPlanPackagePrice.metadata
                    additionalProperties = newPlanPackagePrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun packageConfig(packageConfig: PackageConfig) = apply {
                    this.packageConfig = packageConfig
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanPackagePrice =
                    NewPlanPackagePrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(packageConfig) {
                            "`packageConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val PACKAGE = of("package")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE,
                }

                enum class Value {
                    PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE -> Value.PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE -> Known.PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class PackageConfig
            @JsonCreator
            private constructor(
                @JsonProperty("package_amount") private val packageAmount: String,
                @JsonProperty("package_size") private val packageSize: Long,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** A currency amount to rate usage by */
                @JsonProperty("package_amount") fun packageAmount(): String = packageAmount

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                @JsonProperty("package_size") fun packageSize(): Long = packageSize

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var packageAmount: String? = null
                    private var packageSize: Long? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageConfig: PackageConfig) = apply {
                        packageAmount = packageConfig.packageAmount
                        packageSize = packageConfig.packageSize
                        additionalProperties = packageConfig.additionalProperties.toMutableMap()
                    }

                    /** A currency amount to rate usage by */
                    fun packageAmount(packageAmount: String) = apply {
                        this.packageAmount = packageAmount
                    }

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(packageSize: Long) = apply { this.packageSize = packageSize }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): PackageConfig =
                        PackageConfig(
                            checkNotNull(packageAmount) {
                                "`packageAmount` is required but was not set"
                            },
                            checkNotNull(packageSize) {
                                "`packageSize` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is PackageConfig && packageAmount == other.packageAmount && packageSize == other.packageSize && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(packageAmount, packageSize, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanPackagePrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, packageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanPackagePrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, packageConfig=$packageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanMatrixPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("matrix_config") private val matrixConfig: MatrixConfig,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("matrix_config") fun matrixConfig(): MatrixConfig = matrixConfig

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var matrixConfig: MatrixConfig? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanMatrixPrice: NewPlanMatrixPrice) = apply {
                    cadence = newPlanMatrixPrice.cadence
                    itemId = newPlanMatrixPrice.itemId
                    matrixConfig = newPlanMatrixPrice.matrixConfig
                    modelType = newPlanMatrixPrice.modelType
                    name = newPlanMatrixPrice.name
                    billableMetricId = newPlanMatrixPrice.billableMetricId
                    billedInAdvance = newPlanMatrixPrice.billedInAdvance
                    billingCycleConfiguration = newPlanMatrixPrice.billingCycleConfiguration
                    conversionRate = newPlanMatrixPrice.conversionRate
                    currency = newPlanMatrixPrice.currency
                    externalPriceId = newPlanMatrixPrice.externalPriceId
                    fixedPriceQuantity = newPlanMatrixPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanMatrixPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanMatrixPrice.invoicingCycleConfiguration
                    metadata = newPlanMatrixPrice.metadata
                    additionalProperties = newPlanMatrixPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun matrixConfig(matrixConfig: MatrixConfig) = apply {
                    this.matrixConfig = matrixConfig
                }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanMatrixPrice =
                    NewPlanMatrixPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(matrixConfig) { "`matrixConfig` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class MatrixConfig
            @JsonCreator
            private constructor(
                @JsonProperty("default_unit_amount") private val defaultUnitAmount: String,
                @JsonProperty("dimensions") private val dimensions: List<String?>,
                @JsonProperty("matrix_values") private val matrixValues: List<MatrixValue>,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                @JsonProperty("default_unit_amount")
                fun defaultUnitAmount(): String = defaultUnitAmount

                /** One or two event property values to evaluate matrix groups by */
                @JsonProperty("dimensions") fun dimensions(): List<String?> = dimensions

                /** Matrix values for specified matrix grouping keys */
                @JsonProperty("matrix_values") fun matrixValues(): List<MatrixValue> = matrixValues

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var defaultUnitAmount: String? = null
                    private var dimensions: MutableList<String?>? = null
                    private var matrixValues: MutableList<MatrixValue>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixConfig: MatrixConfig) = apply {
                        defaultUnitAmount = matrixConfig.defaultUnitAmount
                        dimensions = matrixConfig.dimensions.toMutableList()
                        matrixValues = matrixConfig.matrixValues.toMutableList()
                        additionalProperties = matrixConfig.additionalProperties.toMutableMap()
                    }

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(defaultUnitAmount: String) = apply {
                        this.defaultUnitAmount = defaultUnitAmount
                    }

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(dimensions: List<String?>) = apply {
                        this.dimensions = dimensions.toMutableList()
                    }

                    /** One or two event property values to evaluate matrix groups by */
                    fun addDimension(dimension: String) = apply {
                        dimensions = (dimensions ?: mutableListOf()).apply { add(dimension) }
                    }

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(matrixValues: List<MatrixValue>) = apply {
                        this.matrixValues = matrixValues.toMutableList()
                    }

                    /** Matrix values for specified matrix grouping keys */
                    fun addMatrixValue(matrixValue: MatrixValue) = apply {
                        matrixValues = (matrixValues ?: mutableListOf()).apply { add(matrixValue) }
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixConfig =
                        MatrixConfig(
                            checkNotNull(defaultUnitAmount) {
                                "`defaultUnitAmount` is required but was not set"
                            },
                            checkNotNull(dimensions) { "`dimensions` is required but was not set" }
                                .toImmutable(),
                            checkNotNull(matrixValues) {
                                    "`matrixValues` is required but was not set"
                                }
                                .toImmutable(),
                            additionalProperties.toImmutable(),
                        )
                }

                @NoAutoDetect
                class MatrixValue
                @JsonCreator
                private constructor(
                    @JsonProperty("dimension_values") private val dimensionValues: List<String?>,
                    @JsonProperty("unit_amount") private val unitAmount: String,
                    @JsonAnySetter
                    private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
                ) {

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    @JsonProperty("dimension_values")
                    fun dimensionValues(): List<String?> = dimensionValues

                    /** Unit price for the specified dimension_values */
                    @JsonProperty("unit_amount") fun unitAmount(): String = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var dimensionValues: MutableList<String?>? = null
                        private var unitAmount: String? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixValue: MatrixValue) = apply {
                            dimensionValues = matrixValue.dimensionValues.toMutableList()
                            unitAmount = matrixValue.unitAmount
                            additionalProperties = matrixValue.additionalProperties.toMutableMap()
                        }

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(dimensionValues: List<String?>) = apply {
                            this.dimensionValues = dimensionValues.toMutableList()
                        }

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun addDimensionValue(dimensionValue: String) = apply {
                            dimensionValues =
                                (dimensionValues ?: mutableListOf()).apply { add(dimensionValue) }
                        }

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(unitAmount: String) = apply { this.unitAmount = unitAmount }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        fun build(): MatrixValue =
                            MatrixValue(
                                checkNotNull(dimensionValues) {
                                        "`dimensionValues` is required but was not set"
                                    }
                                    .toImmutable(),
                                checkNotNull(unitAmount) {
                                    "`unitAmount` is required but was not set"
                                },
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is MatrixValue && dimensionValues == other.dimensionValues && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    /* spotless:off */
                    private val hashCode: Int by lazy { Objects.hash(dimensionValues, unitAmount, additionalProperties) }
                    /* spotless:on */

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "MatrixValue{dimensionValues=$dimensionValues, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixConfig && defaultUnitAmount == other.defaultUnitAmount && dimensions == other.dimensions && matrixValues == other.matrixValues && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(defaultUnitAmount, dimensions, matrixValues, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixConfig{defaultUnitAmount=$defaultUnitAmount, dimensions=$dimensions, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val MATRIX = of("matrix")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX,
                }

                enum class Value {
                    MATRIX,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX -> Value.MATRIX
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX -> Known.MATRIX
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanMatrixPrice && cadence == other.cadence && itemId == other.itemId && matrixConfig == other.matrixConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, matrixConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanMatrixPrice{cadence=$cadence, itemId=$itemId, matrixConfig=$matrixConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanTieredPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("tiered_config") private val tieredConfig: TieredConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("tiered_config") fun tieredConfig(): TieredConfig = tieredConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var tieredConfig: TieredConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPrice: NewPlanTieredPrice) = apply {
                    cadence = newPlanTieredPrice.cadence
                    itemId = newPlanTieredPrice.itemId
                    modelType = newPlanTieredPrice.modelType
                    name = newPlanTieredPrice.name
                    tieredConfig = newPlanTieredPrice.tieredConfig
                    billableMetricId = newPlanTieredPrice.billableMetricId
                    billedInAdvance = newPlanTieredPrice.billedInAdvance
                    billingCycleConfiguration = newPlanTieredPrice.billingCycleConfiguration
                    conversionRate = newPlanTieredPrice.conversionRate
                    currency = newPlanTieredPrice.currency
                    externalPriceId = newPlanTieredPrice.externalPriceId
                    fixedPriceQuantity = newPlanTieredPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanTieredPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanTieredPrice.invoicingCycleConfiguration
                    metadata = newPlanTieredPrice.metadata
                    additionalProperties = newPlanTieredPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun tieredConfig(tieredConfig: TieredConfig) = apply {
                    this.tieredConfig = tieredConfig
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanTieredPrice =
                    NewPlanTieredPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(tieredConfig) { "`tieredConfig` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val TIERED = of("tiered")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED,
                }

                enum class Value {
                    TIERED,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED -> Value.TIERED
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED -> Known.TIERED
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class TieredConfig
            @JsonCreator
            private constructor(
                @JsonProperty("tiers") private val tiers: List<Tier>,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Tiers for rating based on total usage quantities into the specified tier */
                @JsonProperty("tiers") fun tiers(): List<Tier> = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: MutableList<Tier>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredConfig: TieredConfig) = apply {
                        tiers = tieredConfig.tiers.toMutableList()
                        additionalProperties = tieredConfig.additionalProperties.toMutableMap()
                    }

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(tiers: List<Tier>) = apply { this.tiers = tiers.toMutableList() }

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun addTier(tier: Tier) = apply {
                        tiers = (tiers ?: mutableListOf()).apply { add(tier) }
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): TieredConfig =
                        TieredConfig(
                            checkNotNull(tiers) { "`tiers` is required but was not set" }
                                .toImmutable(),
                            additionalProperties.toImmutable()
                        )
                }

                @NoAutoDetect
                class Tier
                @JsonCreator
                private constructor(
                    @JsonProperty("first_unit") private val firstUnit: Double,
                    @JsonProperty("unit_amount") private val unitAmount: String,
                    @JsonProperty("last_unit") private val lastUnit: Double?,
                    @JsonAnySetter
                    private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
                ) {

                    /** Inclusive tier starting value */
                    @JsonProperty("first_unit") fun firstUnit(): Double = firstUnit

                    /** Amount per unit */
                    @JsonProperty("unit_amount") fun unitAmount(): String = unitAmount

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    @JsonProperty("last_unit")
                    fun lastUnit(): Optional<Double> = Optional.ofNullable(lastUnit)

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var firstUnit: Double? = null
                        private var unitAmount: String? = null
                        private var lastUnit: Double? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            firstUnit = tier.firstUnit
                            unitAmount = tier.unitAmount
                            lastUnit = tier.lastUnit
                            additionalProperties = tier.additionalProperties.toMutableMap()
                        }

                        /** Inclusive tier starting value */
                        fun firstUnit(firstUnit: Double) = apply { this.firstUnit = firstUnit }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = apply { this.unitAmount = unitAmount }

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(lastUnit: Double?) = apply { this.lastUnit = lastUnit }

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(lastUnit: Double) = lastUnit(lastUnit as Double?)

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @Suppress(
                            "USELESS_CAST"
                        ) // See https://youtrack.jetbrains.com/issue/KT-74228
                        fun lastUnit(lastUnit: Optional<Double>) =
                            lastUnit(lastUnit.orElse(null) as Double?)

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        fun build(): Tier =
                            Tier(
                                checkNotNull(firstUnit) {
                                    "`firstUnit` is required but was not set"
                                },
                                checkNotNull(unitAmount) {
                                    "`unitAmount` is required but was not set"
                                },
                                lastUnit,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && firstUnit == other.firstUnit && unitAmount == other.unitAmount && lastUnit == other.lastUnit && additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    /* spotless:off */
                    private val hashCode: Int by lazy { Objects.hash(firstUnit, unitAmount, lastUnit, additionalProperties) }
                    /* spotless:on */

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Tier{firstUnit=$firstUnit, unitAmount=$unitAmount, lastUnit=$lastUnit, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredConfig == other.tieredConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanTieredPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredConfig=$tieredConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanTieredBpsPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("tiered_bps_config") private val tieredBpsConfig: TieredBpsConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("tiered_bps_config")
            fun tieredBpsConfig(): TieredBpsConfig = tieredBpsConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var tieredBpsConfig: TieredBpsConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) = apply {
                    cadence = newPlanTieredBpsPrice.cadence
                    itemId = newPlanTieredBpsPrice.itemId
                    modelType = newPlanTieredBpsPrice.modelType
                    name = newPlanTieredBpsPrice.name
                    tieredBpsConfig = newPlanTieredBpsPrice.tieredBpsConfig
                    billableMetricId = newPlanTieredBpsPrice.billableMetricId
                    billedInAdvance = newPlanTieredBpsPrice.billedInAdvance
                    billingCycleConfiguration = newPlanTieredBpsPrice.billingCycleConfiguration
                    conversionRate = newPlanTieredBpsPrice.conversionRate
                    currency = newPlanTieredBpsPrice.currency
                    externalPriceId = newPlanTieredBpsPrice.externalPriceId
                    fixedPriceQuantity = newPlanTieredBpsPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanTieredBpsPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanTieredBpsPrice.invoicingCycleConfiguration
                    metadata = newPlanTieredBpsPrice.metadata
                    additionalProperties = newPlanTieredBpsPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) = apply {
                    this.tieredBpsConfig = tieredBpsConfig
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanTieredBpsPrice =
                    NewPlanTieredBpsPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(tieredBpsConfig) {
                            "`tieredBpsConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val TIERED_BPS = of("tiered_bps")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_BPS,
                }

                enum class Value {
                    TIERED_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_BPS -> Value.TIERED_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_BPS -> Known.TIERED_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class TieredBpsConfig
            @JsonCreator
            private constructor(
                @JsonProperty("tiers") private val tiers: List<Tier>,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                @JsonProperty("tiers") fun tiers(): List<Tier> = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: MutableList<Tier>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                        tiers = tieredBpsConfig.tiers.toMutableList()
                        additionalProperties = tieredBpsConfig.additionalProperties.toMutableMap()
                    }

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(tiers: List<Tier>) = apply { this.tiers = tiers.toMutableList() }

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun addTier(tier: Tier) = apply {
                        tiers = (tiers ?: mutableListOf()).apply { add(tier) }
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): TieredBpsConfig =
                        TieredBpsConfig(
                            checkNotNull(tiers) { "`tiers` is required but was not set" }
                                .toImmutable(),
                            additionalProperties.toImmutable()
                        )
                }

                @NoAutoDetect
                class Tier
                @JsonCreator
                private constructor(
                    @JsonProperty("bps") private val bps: Double,
                    @JsonProperty("minimum_amount") private val minimumAmount: String,
                    @JsonProperty("maximum_amount") private val maximumAmount: String?,
                    @JsonProperty("per_unit_maximum") private val perUnitMaximum: String?,
                    @JsonAnySetter
                    private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
                ) {

                    /** Per-event basis point rate */
                    @JsonProperty("bps") fun bps(): Double = bps

                    /** Inclusive tier starting value */
                    @JsonProperty("minimum_amount") fun minimumAmount(): String = minimumAmount

                    /** Exclusive tier ending value */
                    @JsonProperty("maximum_amount")
                    fun maximumAmount(): Optional<String> = Optional.ofNullable(maximumAmount)

                    /** Per unit maximum to charge */
                    @JsonProperty("per_unit_maximum")
                    fun perUnitMaximum(): Optional<String> = Optional.ofNullable(perUnitMaximum)

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var bps: Double? = null
                        private var minimumAmount: String? = null
                        private var maximumAmount: String? = null
                        private var perUnitMaximum: String? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            bps = tier.bps
                            minimumAmount = tier.minimumAmount
                            maximumAmount = tier.maximumAmount
                            perUnitMaximum = tier.perUnitMaximum
                            additionalProperties = tier.additionalProperties.toMutableMap()
                        }

                        /** Per-event basis point rate */
                        fun bps(bps: Double) = apply { this.bps = bps }

                        /** Inclusive tier starting value */
                        fun minimumAmount(minimumAmount: String) = apply {
                            this.minimumAmount = minimumAmount
                        }

                        /** Exclusive tier ending value */
                        fun maximumAmount(maximumAmount: String?) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Exclusive tier ending value */
                        fun maximumAmount(maximumAmount: Optional<String>) =
                            maximumAmount(maximumAmount.orElse(null))

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(perUnitMaximum: String?) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                            perUnitMaximum(perUnitMaximum.orElse(null))

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        fun build(): Tier =
                            Tier(
                                checkNotNull(bps) { "`bps` is required but was not set" },
                                checkNotNull(minimumAmount) {
                                    "`minimumAmount` is required but was not set"
                                },
                                maximumAmount,
                                perUnitMaximum,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && bps == other.bps && minimumAmount == other.minimumAmount && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    /* spotless:off */
                    private val hashCode: Int by lazy { Objects.hash(bps, minimumAmount, maximumAmount, perUnitMaximum, additionalProperties) }
                    /* spotless:on */

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Tier{bps=$bps, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredBpsPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredBpsConfig == other.tieredBpsConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredBpsConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanTieredBpsPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredBpsConfig=$tieredBpsConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanBpsPrice
        @JsonCreator
        private constructor(
            @JsonProperty("bps_config") private val bpsConfig: BpsConfig,
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonProperty("bps_config") fun bpsConfig(): BpsConfig = bpsConfig

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var bpsConfig: BpsConfig? = null
                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBpsPrice: NewPlanBpsPrice) = apply {
                    bpsConfig = newPlanBpsPrice.bpsConfig
                    cadence = newPlanBpsPrice.cadence
                    itemId = newPlanBpsPrice.itemId
                    modelType = newPlanBpsPrice.modelType
                    name = newPlanBpsPrice.name
                    billableMetricId = newPlanBpsPrice.billableMetricId
                    billedInAdvance = newPlanBpsPrice.billedInAdvance
                    billingCycleConfiguration = newPlanBpsPrice.billingCycleConfiguration
                    conversionRate = newPlanBpsPrice.conversionRate
                    currency = newPlanBpsPrice.currency
                    externalPriceId = newPlanBpsPrice.externalPriceId
                    fixedPriceQuantity = newPlanBpsPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanBpsPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanBpsPrice.invoicingCycleConfiguration
                    metadata = newPlanBpsPrice.metadata
                    additionalProperties = newPlanBpsPrice.additionalProperties.toMutableMap()
                }

                fun bpsConfig(bpsConfig: BpsConfig) = apply { this.bpsConfig = bpsConfig }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanBpsPrice =
                    NewPlanBpsPrice(
                        checkNotNull(bpsConfig) { "`bpsConfig` is required but was not set" },
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class BpsConfig
            @JsonCreator
            private constructor(
                @JsonProperty("bps") private val bps: Double,
                @JsonProperty("per_unit_maximum") private val perUnitMaximum: String?,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Basis point take rate per event */
                @JsonProperty("bps") fun bps(): Double = bps

                /** Optional currency amount maximum to cap spend per event */
                @JsonProperty("per_unit_maximum")
                fun perUnitMaximum(): Optional<String> = Optional.ofNullable(perUnitMaximum)

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: Double? = null
                    private var perUnitMaximum: String? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bpsConfig: BpsConfig) = apply {
                        bps = bpsConfig.bps
                        perUnitMaximum = bpsConfig.perUnitMaximum
                        additionalProperties = bpsConfig.additionalProperties.toMutableMap()
                    }

                    /** Basis point take rate per event */
                    fun bps(bps: Double) = apply { this.bps = bps }

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(perUnitMaximum: String?) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                        perUnitMaximum(perUnitMaximum.orElse(null))

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BpsConfig =
                        BpsConfig(
                            checkNotNull(bps) { "`bps` is required but was not set" },
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BpsConfig && bps == other.bps && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(bps, perUnitMaximum, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val BPS = of("bps")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BPS,
                }

                enum class Value {
                    BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BPS -> Value.BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BPS -> Known.BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBpsPrice && bpsConfig == other.bpsConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bpsConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanBpsPrice{bpsConfig=$bpsConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanBulkBpsPrice
        @JsonCreator
        private constructor(
            @JsonProperty("bulk_bps_config") private val bulkBpsConfig: BulkBpsConfig,
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonProperty("bulk_bps_config") fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var bulkBpsConfig: BulkBpsConfig? = null
                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) = apply {
                    bulkBpsConfig = newPlanBulkBpsPrice.bulkBpsConfig
                    cadence = newPlanBulkBpsPrice.cadence
                    itemId = newPlanBulkBpsPrice.itemId
                    modelType = newPlanBulkBpsPrice.modelType
                    name = newPlanBulkBpsPrice.name
                    billableMetricId = newPlanBulkBpsPrice.billableMetricId
                    billedInAdvance = newPlanBulkBpsPrice.billedInAdvance
                    billingCycleConfiguration = newPlanBulkBpsPrice.billingCycleConfiguration
                    conversionRate = newPlanBulkBpsPrice.conversionRate
                    currency = newPlanBulkBpsPrice.currency
                    externalPriceId = newPlanBulkBpsPrice.externalPriceId
                    fixedPriceQuantity = newPlanBulkBpsPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanBulkBpsPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanBulkBpsPrice.invoicingCycleConfiguration
                    metadata = newPlanBulkBpsPrice.metadata
                    additionalProperties = newPlanBulkBpsPrice.additionalProperties.toMutableMap()
                }

                fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) = apply {
                    this.bulkBpsConfig = bulkBpsConfig
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanBulkBpsPrice =
                    NewPlanBulkBpsPrice(
                        checkNotNull(bulkBpsConfig) {
                            "`bulkBpsConfig` is required but was not set"
                        },
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class BulkBpsConfig
            @JsonCreator
            private constructor(
                @JsonProperty("tiers") private val tiers: List<Tier>,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                @JsonProperty("tiers") fun tiers(): List<Tier> = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: MutableList<Tier>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                        tiers = bulkBpsConfig.tiers.toMutableList()
                        additionalProperties = bulkBpsConfig.additionalProperties.toMutableMap()
                    }

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(tiers: List<Tier>) = apply { this.tiers = tiers.toMutableList() }

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun addTier(tier: Tier) = apply {
                        tiers = (tiers ?: mutableListOf()).apply { add(tier) }
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BulkBpsConfig =
                        BulkBpsConfig(
                            checkNotNull(tiers) { "`tiers` is required but was not set" }
                                .toImmutable(),
                            additionalProperties.toImmutable()
                        )
                }

                @NoAutoDetect
                class Tier
                @JsonCreator
                private constructor(
                    @JsonProperty("bps") private val bps: Double,
                    @JsonProperty("maximum_amount") private val maximumAmount: String?,
                    @JsonProperty("per_unit_maximum") private val perUnitMaximum: String?,
                    @JsonAnySetter
                    private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
                ) {

                    /** Basis points to rate on */
                    @JsonProperty("bps") fun bps(): Double = bps

                    /** Upper bound for tier */
                    @JsonProperty("maximum_amount")
                    fun maximumAmount(): Optional<String> = Optional.ofNullable(maximumAmount)

                    /** The maximum amount to charge for any one event */
                    @JsonProperty("per_unit_maximum")
                    fun perUnitMaximum(): Optional<String> = Optional.ofNullable(perUnitMaximum)

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var bps: Double? = null
                        private var maximumAmount: String? = null
                        private var perUnitMaximum: String? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            bps = tier.bps
                            maximumAmount = tier.maximumAmount
                            perUnitMaximum = tier.perUnitMaximum
                            additionalProperties = tier.additionalProperties.toMutableMap()
                        }

                        /** Basis points to rate on */
                        fun bps(bps: Double) = apply { this.bps = bps }

                        /** Upper bound for tier */
                        fun maximumAmount(maximumAmount: String?) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Upper bound for tier */
                        fun maximumAmount(maximumAmount: Optional<String>) =
                            maximumAmount(maximumAmount.orElse(null))

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(perUnitMaximum: String?) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                            perUnitMaximum(perUnitMaximum.orElse(null))

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        fun build(): Tier =
                            Tier(
                                checkNotNull(bps) { "`bps` is required but was not set" },
                                maximumAmount,
                                perUnitMaximum,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && bps == other.bps && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    /* spotless:off */
                    private val hashCode: Int by lazy { Objects.hash(bps, maximumAmount, perUnitMaximum, additionalProperties) }
                    /* spotless:on */

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Tier{bps=$bps, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val BULK_BPS = of("bulk_bps")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_BPS,
                }

                enum class Value {
                    BULK_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_BPS -> Value.BULK_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_BPS -> Known.BULK_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkBpsPrice && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bulkBpsConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanBulkBpsPrice{bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanBulkPrice
        @JsonCreator
        private constructor(
            @JsonProperty("bulk_config") private val bulkConfig: BulkConfig,
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonProperty("bulk_config") fun bulkConfig(): BulkConfig = bulkConfig

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var bulkConfig: BulkConfig? = null
                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkPrice: NewPlanBulkPrice) = apply {
                    bulkConfig = newPlanBulkPrice.bulkConfig
                    cadence = newPlanBulkPrice.cadence
                    itemId = newPlanBulkPrice.itemId
                    modelType = newPlanBulkPrice.modelType
                    name = newPlanBulkPrice.name
                    billableMetricId = newPlanBulkPrice.billableMetricId
                    billedInAdvance = newPlanBulkPrice.billedInAdvance
                    billingCycleConfiguration = newPlanBulkPrice.billingCycleConfiguration
                    conversionRate = newPlanBulkPrice.conversionRate
                    currency = newPlanBulkPrice.currency
                    externalPriceId = newPlanBulkPrice.externalPriceId
                    fixedPriceQuantity = newPlanBulkPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanBulkPrice.invoiceGroupingKey
                    invoicingCycleConfiguration = newPlanBulkPrice.invoicingCycleConfiguration
                    metadata = newPlanBulkPrice.metadata
                    additionalProperties = newPlanBulkPrice.additionalProperties.toMutableMap()
                }

                fun bulkConfig(bulkConfig: BulkConfig) = apply { this.bulkConfig = bulkConfig }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanBulkPrice =
                    NewPlanBulkPrice(
                        checkNotNull(bulkConfig) { "`bulkConfig` is required but was not set" },
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class BulkConfig
            @JsonCreator
            private constructor(
                @JsonProperty("tiers") private val tiers: List<Tier>,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Bulk tiers for rating based on total usage volume */
                @JsonProperty("tiers") fun tiers(): List<Tier> = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: MutableList<Tier>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkConfig: BulkConfig) = apply {
                        tiers = bulkConfig.tiers.toMutableList()
                        additionalProperties = bulkConfig.additionalProperties.toMutableMap()
                    }

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(tiers: List<Tier>) = apply { this.tiers = tiers.toMutableList() }

                    /** Bulk tiers for rating based on total usage volume */
                    fun addTier(tier: Tier) = apply {
                        tiers = (tiers ?: mutableListOf()).apply { add(tier) }
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BulkConfig =
                        BulkConfig(
                            checkNotNull(tiers) { "`tiers` is required but was not set" }
                                .toImmutable(),
                            additionalProperties.toImmutable()
                        )
                }

                @NoAutoDetect
                class Tier
                @JsonCreator
                private constructor(
                    @JsonProperty("unit_amount") private val unitAmount: String,
                    @JsonProperty("maximum_units") private val maximumUnits: Double?,
                    @JsonAnySetter
                    private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
                ) {

                    /** Amount per unit */
                    @JsonProperty("unit_amount") fun unitAmount(): String = unitAmount

                    /** Upper bound for this tier */
                    @JsonProperty("maximum_units")
                    fun maximumUnits(): Optional<Double> = Optional.ofNullable(maximumUnits)

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: String? = null
                        private var maximumUnits: Double? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            unitAmount = tier.unitAmount
                            maximumUnits = tier.maximumUnits
                            additionalProperties = tier.additionalProperties.toMutableMap()
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = apply { this.unitAmount = unitAmount }

                        /** Upper bound for this tier */
                        fun maximumUnits(maximumUnits: Double?) = apply {
                            this.maximumUnits = maximumUnits
                        }

                        /** Upper bound for this tier */
                        fun maximumUnits(maximumUnits: Double) =
                            maximumUnits(maximumUnits as Double?)

                        /** Upper bound for this tier */
                        @Suppress(
                            "USELESS_CAST"
                        ) // See https://youtrack.jetbrains.com/issue/KT-74228
                        fun maximumUnits(maximumUnits: Optional<Double>) =
                            maximumUnits(maximumUnits.orElse(null) as Double?)

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        fun build(): Tier =
                            Tier(
                                checkNotNull(unitAmount) {
                                    "`unitAmount` is required but was not set"
                                },
                                maximumUnits,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && unitAmount == other.unitAmount && maximumUnits == other.maximumUnits && additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    /* spotless:off */
                    private val hashCode: Int by lazy { Objects.hash(unitAmount, maximumUnits, additionalProperties) }
                    /* spotless:on */

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Tier{unitAmount=$unitAmount, maximumUnits=$maximumUnits, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val BULK = of("bulk")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK,
                }

                enum class Value {
                    BULK,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK -> Value.BULK
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK -> Known.BULK
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkPrice && bulkConfig == other.bulkConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bulkConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanBulkPrice{bulkConfig=$bulkConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanThresholdTotalAmountPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("threshold_total_amount_config")
            private val thresholdTotalAmountConfig: ThresholdTotalAmountConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("threshold_total_amount_config")
            fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                thresholdTotalAmountConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var thresholdTotalAmountConfig: ThresholdTotalAmountConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
                ) = apply {
                    cadence = newPlanThresholdTotalAmountPrice.cadence
                    itemId = newPlanThresholdTotalAmountPrice.itemId
                    modelType = newPlanThresholdTotalAmountPrice.modelType
                    name = newPlanThresholdTotalAmountPrice.name
                    thresholdTotalAmountConfig =
                        newPlanThresholdTotalAmountPrice.thresholdTotalAmountConfig
                    billableMetricId = newPlanThresholdTotalAmountPrice.billableMetricId
                    billedInAdvance = newPlanThresholdTotalAmountPrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanThresholdTotalAmountPrice.billingCycleConfiguration
                    conversionRate = newPlanThresholdTotalAmountPrice.conversionRate
                    currency = newPlanThresholdTotalAmountPrice.currency
                    externalPriceId = newPlanThresholdTotalAmountPrice.externalPriceId
                    fixedPriceQuantity = newPlanThresholdTotalAmountPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanThresholdTotalAmountPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanThresholdTotalAmountPrice.invoicingCycleConfiguration
                    metadata = newPlanThresholdTotalAmountPrice.metadata
                    additionalProperties =
                        newPlanThresholdTotalAmountPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanThresholdTotalAmountPrice =
                    NewPlanThresholdTotalAmountPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(thresholdTotalAmountConfig) {
                            "`thresholdTotalAmountConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    THRESHOLD_TOTAL_AMOUNT,
                }

                enum class Value {
                    THRESHOLD_TOTAL_AMOUNT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class ThresholdTotalAmountConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                        apply {
                            additionalProperties =
                                thresholdTotalAmountConfig.additionalProperties.toMutableMap()
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): ThresholdTotalAmountConfig =
                        ThresholdTotalAmountConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ThresholdTotalAmountConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanThresholdTotalAmountPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, thresholdTotalAmountConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanThresholdTotalAmountPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanTieredPackagePrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("tiered_package_config")
            private val tieredPackageConfig: TieredPackageConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("tiered_package_config")
            fun tieredPackageConfig(): TieredPackageConfig = tieredPackageConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var tieredPackageConfig: TieredPackageConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) = apply {
                    cadence = newPlanTieredPackagePrice.cadence
                    itemId = newPlanTieredPackagePrice.itemId
                    modelType = newPlanTieredPackagePrice.modelType
                    name = newPlanTieredPackagePrice.name
                    tieredPackageConfig = newPlanTieredPackagePrice.tieredPackageConfig
                    billableMetricId = newPlanTieredPackagePrice.billableMetricId
                    billedInAdvance = newPlanTieredPackagePrice.billedInAdvance
                    billingCycleConfiguration = newPlanTieredPackagePrice.billingCycleConfiguration
                    conversionRate = newPlanTieredPackagePrice.conversionRate
                    currency = newPlanTieredPackagePrice.currency
                    externalPriceId = newPlanTieredPackagePrice.externalPriceId
                    fixedPriceQuantity = newPlanTieredPackagePrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanTieredPackagePrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanTieredPackagePrice.invoicingCycleConfiguration
                    metadata = newPlanTieredPackagePrice.metadata
                    additionalProperties =
                        newPlanTieredPackagePrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) = apply {
                    this.tieredPackageConfig = tieredPackageConfig
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanTieredPackagePrice =
                    NewPlanTieredPackagePrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(tieredPackageConfig) {
                            "`tieredPackageConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val TIERED_PACKAGE = of("tiered_package")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_PACKAGE,
                }

                enum class Value {
                    TIERED_PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_PACKAGE -> Value.TIERED_PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_PACKAGE -> Known.TIERED_PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class TieredPackageConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                        additionalProperties =
                            tieredPackageConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): TieredPackageConfig =
                        TieredPackageConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "TieredPackageConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredPackagePrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredPackageConfig == other.tieredPackageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredPackageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanTieredPackagePrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredPackageConfig=$tieredPackageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanTieredWithMinimumPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("tiered_with_minimum_config")
            private val tieredWithMinimumConfig: TieredWithMinimumConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("tiered_with_minimum_config")
            fun tieredWithMinimumConfig(): TieredWithMinimumConfig = tieredWithMinimumConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var tieredWithMinimumConfig: TieredWithMinimumConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice) =
                    apply {
                        cadence = newPlanTieredWithMinimumPrice.cadence
                        itemId = newPlanTieredWithMinimumPrice.itemId
                        modelType = newPlanTieredWithMinimumPrice.modelType
                        name = newPlanTieredWithMinimumPrice.name
                        tieredWithMinimumConfig =
                            newPlanTieredWithMinimumPrice.tieredWithMinimumConfig
                        billableMetricId = newPlanTieredWithMinimumPrice.billableMetricId
                        billedInAdvance = newPlanTieredWithMinimumPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanTieredWithMinimumPrice.billingCycleConfiguration
                        conversionRate = newPlanTieredWithMinimumPrice.conversionRate
                        currency = newPlanTieredWithMinimumPrice.currency
                        externalPriceId = newPlanTieredWithMinimumPrice.externalPriceId
                        fixedPriceQuantity = newPlanTieredWithMinimumPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanTieredWithMinimumPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanTieredWithMinimumPrice.invoicingCycleConfiguration
                        metadata = newPlanTieredWithMinimumPrice.metadata
                        additionalProperties =
                            newPlanTieredWithMinimumPrice.additionalProperties.toMutableMap()
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                    apply {
                        this.tieredWithMinimumConfig = tieredWithMinimumConfig
                    }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanTieredWithMinimumPrice =
                    NewPlanTieredWithMinimumPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(tieredWithMinimumConfig) {
                            "`tieredWithMinimumConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_MINIMUM,
                }

                enum class Value {
                    TIERED_WITH_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class TieredWithMinimumConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                        additionalProperties =
                            tieredWithMinimumConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): TieredWithMinimumConfig =
                        TieredWithMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredWithMinimumPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithMinimumConfig == other.tieredWithMinimumConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredWithMinimumConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanTieredWithMinimumPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredWithMinimumConfig=$tieredWithMinimumConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanUnitWithPercentPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("unit_with_percent_config")
            private val unitWithPercentConfig: UnitWithPercentConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("unit_with_percent_config")
            fun unitWithPercentConfig(): UnitWithPercentConfig = unitWithPercentConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var unitWithPercentConfig: UnitWithPercentConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice) =
                    apply {
                        cadence = newPlanUnitWithPercentPrice.cadence
                        itemId = newPlanUnitWithPercentPrice.itemId
                        modelType = newPlanUnitWithPercentPrice.modelType
                        name = newPlanUnitWithPercentPrice.name
                        unitWithPercentConfig = newPlanUnitWithPercentPrice.unitWithPercentConfig
                        billableMetricId = newPlanUnitWithPercentPrice.billableMetricId
                        billedInAdvance = newPlanUnitWithPercentPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanUnitWithPercentPrice.billingCycleConfiguration
                        conversionRate = newPlanUnitWithPercentPrice.conversionRate
                        currency = newPlanUnitWithPercentPrice.currency
                        externalPriceId = newPlanUnitWithPercentPrice.externalPriceId
                        fixedPriceQuantity = newPlanUnitWithPercentPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanUnitWithPercentPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanUnitWithPercentPrice.invoicingCycleConfiguration
                        metadata = newPlanUnitWithPercentPrice.metadata
                        additionalProperties =
                            newPlanUnitWithPercentPrice.additionalProperties.toMutableMap()
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                    this.unitWithPercentConfig = unitWithPercentConfig
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanUnitWithPercentPrice =
                    NewPlanUnitWithPercentPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(unitWithPercentConfig) {
                            "`unitWithPercentConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PERCENT,
                }

                enum class Value {
                    UNIT_WITH_PERCENT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class UnitWithPercentConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                        additionalProperties =
                            unitWithPercentConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): UnitWithPercentConfig =
                        UnitWithPercentConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitWithPercentConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UnitWithPercentConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitWithPercentPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithPercentConfig == other.unitWithPercentConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitWithPercentConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanUnitWithPercentPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitWithPercentConfig=$unitWithPercentConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanPackageWithAllocationPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("package_with_allocation_config")
            private val packageWithAllocationConfig: PackageWithAllocationConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("package_with_allocation_config")
            fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                packageWithAllocationConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var packageWithAllocationConfig: PackageWithAllocationConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
                ) = apply {
                    cadence = newPlanPackageWithAllocationPrice.cadence
                    itemId = newPlanPackageWithAllocationPrice.itemId
                    modelType = newPlanPackageWithAllocationPrice.modelType
                    name = newPlanPackageWithAllocationPrice.name
                    packageWithAllocationConfig =
                        newPlanPackageWithAllocationPrice.packageWithAllocationConfig
                    billableMetricId = newPlanPackageWithAllocationPrice.billableMetricId
                    billedInAdvance = newPlanPackageWithAllocationPrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanPackageWithAllocationPrice.billingCycleConfiguration
                    conversionRate = newPlanPackageWithAllocationPrice.conversionRate
                    currency = newPlanPackageWithAllocationPrice.currency
                    externalPriceId = newPlanPackageWithAllocationPrice.externalPriceId
                    fixedPriceQuantity = newPlanPackageWithAllocationPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanPackageWithAllocationPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanPackageWithAllocationPrice.invoicingCycleConfiguration
                    metadata = newPlanPackageWithAllocationPrice.metadata
                    additionalProperties =
                        newPlanPackageWithAllocationPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: PackageWithAllocationConfig
                ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanPackageWithAllocationPrice =
                    NewPlanPackageWithAllocationPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(packageWithAllocationConfig) {
                            "`packageWithAllocationConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE_WITH_ALLOCATION,
                }

                enum class Value {
                    PACKAGE_WITH_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class PackageWithAllocationConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                        apply {
                            additionalProperties =
                                packageWithAllocationConfig.additionalProperties.toMutableMap()
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): PackageWithAllocationConfig =
                        PackageWithAllocationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is PackageWithAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanPackageWithAllocationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, packageWithAllocationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanPackageWithAllocationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanTierWithProrationPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("tiered_with_proration_config")
            private val tieredWithProrationConfig: TieredWithProrationConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("tiered_with_proration_config")
            fun tieredWithProrationConfig(): TieredWithProrationConfig = tieredWithProrationConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var tieredWithProrationConfig: TieredWithProrationConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice) =
                    apply {
                        cadence = newPlanTierWithProrationPrice.cadence
                        itemId = newPlanTierWithProrationPrice.itemId
                        modelType = newPlanTierWithProrationPrice.modelType
                        name = newPlanTierWithProrationPrice.name
                        tieredWithProrationConfig =
                            newPlanTierWithProrationPrice.tieredWithProrationConfig
                        billableMetricId = newPlanTierWithProrationPrice.billableMetricId
                        billedInAdvance = newPlanTierWithProrationPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanTierWithProrationPrice.billingCycleConfiguration
                        conversionRate = newPlanTierWithProrationPrice.conversionRate
                        currency = newPlanTierWithProrationPrice.currency
                        externalPriceId = newPlanTierWithProrationPrice.externalPriceId
                        fixedPriceQuantity = newPlanTierWithProrationPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanTierWithProrationPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanTierWithProrationPrice.invoicingCycleConfiguration
                        metadata = newPlanTierWithProrationPrice.metadata
                        additionalProperties =
                            newPlanTierWithProrationPrice.additionalProperties.toMutableMap()
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: TieredWithProrationConfig
                ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanTierWithProrationPrice =
                    NewPlanTierWithProrationPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(tieredWithProrationConfig) {
                            "`tieredWithProrationConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_PRORATION,
                }

                enum class Value {
                    TIERED_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class TieredWithProrationConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                        apply {
                            additionalProperties =
                                tieredWithProrationConfig.additionalProperties.toMutableMap()
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): TieredWithProrationConfig =
                        TieredWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "TieredWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTierWithProrationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithProrationConfig == other.tieredWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanTierWithProrationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredWithProrationConfig=$tieredWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanUnitWithProrationPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("unit_with_proration_config")
            private val unitWithProrationConfig: UnitWithProrationConfig,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            @JsonProperty("unit_with_proration_config")
            fun unitWithProrationConfig(): UnitWithProrationConfig = unitWithProrationConfig

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var unitWithProrationConfig: UnitWithProrationConfig? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice) =
                    apply {
                        cadence = newPlanUnitWithProrationPrice.cadence
                        itemId = newPlanUnitWithProrationPrice.itemId
                        modelType = newPlanUnitWithProrationPrice.modelType
                        name = newPlanUnitWithProrationPrice.name
                        unitWithProrationConfig =
                            newPlanUnitWithProrationPrice.unitWithProrationConfig
                        billableMetricId = newPlanUnitWithProrationPrice.billableMetricId
                        billedInAdvance = newPlanUnitWithProrationPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanUnitWithProrationPrice.billingCycleConfiguration
                        conversionRate = newPlanUnitWithProrationPrice.conversionRate
                        currency = newPlanUnitWithProrationPrice.currency
                        externalPriceId = newPlanUnitWithProrationPrice.externalPriceId
                        fixedPriceQuantity = newPlanUnitWithProrationPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanUnitWithProrationPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanUnitWithProrationPrice.invoicingCycleConfiguration
                        metadata = newPlanUnitWithProrationPrice.metadata
                        additionalProperties =
                            newPlanUnitWithProrationPrice.additionalProperties.toMutableMap()
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                    apply {
                        this.unitWithProrationConfig = unitWithProrationConfig
                    }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanUnitWithProrationPrice =
                    NewPlanUnitWithProrationPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        checkNotNull(unitWithProrationConfig) {
                            "`unitWithProrationConfig` is required but was not set"
                        },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PRORATION,
                }

                enum class Value {
                    UNIT_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class UnitWithProrationConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                        additionalProperties =
                            unitWithProrationConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): UnitWithProrationConfig =
                        UnitWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UnitWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitWithProrationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithProrationConfig == other.unitWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanUnitWithProrationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitWithProrationConfig=$unitWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanGroupedAllocationPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("grouped_allocation_config")
            private val groupedAllocationConfig: GroupedAllocationConfig,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            @JsonProperty("grouped_allocation_config")
            fun groupedAllocationConfig(): GroupedAllocationConfig = groupedAllocationConfig

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var groupedAllocationConfig: GroupedAllocationConfig? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice) =
                    apply {
                        cadence = newPlanGroupedAllocationPrice.cadence
                        groupedAllocationConfig =
                            newPlanGroupedAllocationPrice.groupedAllocationConfig
                        itemId = newPlanGroupedAllocationPrice.itemId
                        modelType = newPlanGroupedAllocationPrice.modelType
                        name = newPlanGroupedAllocationPrice.name
                        billableMetricId = newPlanGroupedAllocationPrice.billableMetricId
                        billedInAdvance = newPlanGroupedAllocationPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanGroupedAllocationPrice.billingCycleConfiguration
                        conversionRate = newPlanGroupedAllocationPrice.conversionRate
                        currency = newPlanGroupedAllocationPrice.currency
                        externalPriceId = newPlanGroupedAllocationPrice.externalPriceId
                        fixedPriceQuantity = newPlanGroupedAllocationPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanGroupedAllocationPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanGroupedAllocationPrice.invoicingCycleConfiguration
                        metadata = newPlanGroupedAllocationPrice.metadata
                        additionalProperties =
                            newPlanGroupedAllocationPrice.additionalProperties.toMutableMap()
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                    apply {
                        this.groupedAllocationConfig = groupedAllocationConfig
                    }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanGroupedAllocationPrice =
                    NewPlanGroupedAllocationPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(groupedAllocationConfig) {
                            "`groupedAllocationConfig` is required but was not set"
                        },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class GroupedAllocationConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                        additionalProperties =
                            groupedAllocationConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): GroupedAllocationConfig =
                        GroupedAllocationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "GroupedAllocationConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_ALLOCATION,
                }

                enum class Value {
                    GROUPED_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedAllocationPrice && cadence == other.cadence && groupedAllocationConfig == other.groupedAllocationConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, groupedAllocationConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanGroupedAllocationPrice{cadence=$cadence, groupedAllocationConfig=$groupedAllocationConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanGroupedWithProratedMinimumPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("grouped_with_prorated_minimum_config")
            private val groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            @JsonProperty("grouped_with_prorated_minimum_config")
            fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
                groupedWithProratedMinimumConfig

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig? =
                    null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
                ) = apply {
                    cadence = newPlanGroupedWithProratedMinimumPrice.cadence
                    groupedWithProratedMinimumConfig =
                        newPlanGroupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    itemId = newPlanGroupedWithProratedMinimumPrice.itemId
                    modelType = newPlanGroupedWithProratedMinimumPrice.modelType
                    name = newPlanGroupedWithProratedMinimumPrice.name
                    billableMetricId = newPlanGroupedWithProratedMinimumPrice.billableMetricId
                    billedInAdvance = newPlanGroupedWithProratedMinimumPrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanGroupedWithProratedMinimumPrice.billingCycleConfiguration
                    conversionRate = newPlanGroupedWithProratedMinimumPrice.conversionRate
                    currency = newPlanGroupedWithProratedMinimumPrice.currency
                    externalPriceId = newPlanGroupedWithProratedMinimumPrice.externalPriceId
                    fixedPriceQuantity = newPlanGroupedWithProratedMinimumPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanGroupedWithProratedMinimumPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanGroupedWithProratedMinimumPrice.invoicingCycleConfiguration
                    metadata = newPlanGroupedWithProratedMinimumPrice.metadata
                    additionalProperties =
                        newPlanGroupedWithProratedMinimumPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                fun groupedWithProratedMinimumConfig(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = apply {
                    this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanGroupedWithProratedMinimumPrice =
                    NewPlanGroupedWithProratedMinimumPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(groupedWithProratedMinimumConfig) {
                            "`groupedWithProratedMinimumConfig` is required but was not set"
                        },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class GroupedWithProratedMinimumConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                    ) = apply {
                        additionalProperties =
                            groupedWithProratedMinimumConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): GroupedWithProratedMinimumConfig =
                        GroupedWithProratedMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedWithProratedMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField
                    val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_PRORATED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_PRORATED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedWithProratedMinimumPrice && cadence == other.cadence && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, groupedWithProratedMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanGroupedWithProratedMinimumPrice{cadence=$cadence, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanGroupedWithMeteredMinimumPrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("grouped_with_metered_minimum_config")
            private val groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            @JsonProperty("grouped_with_metered_minimum_config")
            fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
                groupedWithMeteredMinimumConfig

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
                ) = apply {
                    cadence = newPlanGroupedWithMeteredMinimumPrice.cadence
                    groupedWithMeteredMinimumConfig =
                        newPlanGroupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    itemId = newPlanGroupedWithMeteredMinimumPrice.itemId
                    modelType = newPlanGroupedWithMeteredMinimumPrice.modelType
                    name = newPlanGroupedWithMeteredMinimumPrice.name
                    billableMetricId = newPlanGroupedWithMeteredMinimumPrice.billableMetricId
                    billedInAdvance = newPlanGroupedWithMeteredMinimumPrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanGroupedWithMeteredMinimumPrice.billingCycleConfiguration
                    conversionRate = newPlanGroupedWithMeteredMinimumPrice.conversionRate
                    currency = newPlanGroupedWithMeteredMinimumPrice.currency
                    externalPriceId = newPlanGroupedWithMeteredMinimumPrice.externalPriceId
                    fixedPriceQuantity = newPlanGroupedWithMeteredMinimumPrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanGroupedWithMeteredMinimumPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanGroupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                    metadata = newPlanGroupedWithMeteredMinimumPrice.metadata
                    additionalProperties =
                        newPlanGroupedWithMeteredMinimumPrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                fun groupedWithMeteredMinimumConfig(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanGroupedWithMeteredMinimumPrice =
                    NewPlanGroupedWithMeteredMinimumPrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(groupedWithMeteredMinimumConfig) {
                            "`groupedWithMeteredMinimumConfig` is required but was not set"
                        },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class GroupedWithMeteredMinimumConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                    ) = apply {
                        additionalProperties =
                            groupedWithMeteredMinimumConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): GroupedWithMeteredMinimumConfig =
                        GroupedWithMeteredMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedWithMeteredMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_METERED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_METERED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedWithMeteredMinimumPrice && cadence == other.cadence && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, groupedWithMeteredMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanGroupedWithMeteredMinimumPrice{cadence=$cadence, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanMatrixWithDisplayNamePrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("matrix_with_display_name_config")
            private val matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("matrix_with_display_name_config")
            fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
                matrixWithDisplayNameConfig

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
                ) = apply {
                    cadence = newPlanMatrixWithDisplayNamePrice.cadence
                    itemId = newPlanMatrixWithDisplayNamePrice.itemId
                    matrixWithDisplayNameConfig =
                        newPlanMatrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                    modelType = newPlanMatrixWithDisplayNamePrice.modelType
                    name = newPlanMatrixWithDisplayNamePrice.name
                    billableMetricId = newPlanMatrixWithDisplayNamePrice.billableMetricId
                    billedInAdvance = newPlanMatrixWithDisplayNamePrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanMatrixWithDisplayNamePrice.billingCycleConfiguration
                    conversionRate = newPlanMatrixWithDisplayNamePrice.conversionRate
                    currency = newPlanMatrixWithDisplayNamePrice.currency
                    externalPriceId = newPlanMatrixWithDisplayNamePrice.externalPriceId
                    fixedPriceQuantity = newPlanMatrixWithDisplayNamePrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanMatrixWithDisplayNamePrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanMatrixWithDisplayNamePrice.invoicingCycleConfiguration
                    metadata = newPlanMatrixWithDisplayNamePrice.metadata
                    additionalProperties =
                        newPlanMatrixWithDisplayNamePrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun matrixWithDisplayNameConfig(
                    matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
                ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanMatrixWithDisplayNamePrice =
                    NewPlanMatrixWithDisplayNamePrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(matrixWithDisplayNameConfig) {
                            "`matrixWithDisplayNameConfig` is required but was not set"
                        },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class MatrixWithDisplayNameConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                        apply {
                            additionalProperties =
                                matrixWithDisplayNameConfig.additionalProperties.toMutableMap()
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixWithDisplayNameConfig =
                        MatrixWithDisplayNameConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixWithDisplayNameConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixWithDisplayNameConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX_WITH_DISPLAY_NAME,
                }

                enum class Value {
                    MATRIX_WITH_DISPLAY_NAME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanMatrixWithDisplayNamePrice && cadence == other.cadence && itemId == other.itemId && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, itemId, matrixWithDisplayNameConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanMatrixWithDisplayNamePrice{cadence=$cadence, itemId=$itemId, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanBulkWithProrationPrice
        @JsonCreator
        private constructor(
            @JsonProperty("bulk_with_proration_config")
            private val bulkWithProrationConfig: BulkWithProrationConfig,
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonProperty("bulk_with_proration_config")
            fun bulkWithProrationConfig(): BulkWithProrationConfig = bulkWithProrationConfig

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var bulkWithProrationConfig: BulkWithProrationConfig? = null
                private var cadence: Cadence? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice) =
                    apply {
                        bulkWithProrationConfig =
                            newPlanBulkWithProrationPrice.bulkWithProrationConfig
                        cadence = newPlanBulkWithProrationPrice.cadence
                        itemId = newPlanBulkWithProrationPrice.itemId
                        modelType = newPlanBulkWithProrationPrice.modelType
                        name = newPlanBulkWithProrationPrice.name
                        billableMetricId = newPlanBulkWithProrationPrice.billableMetricId
                        billedInAdvance = newPlanBulkWithProrationPrice.billedInAdvance
                        billingCycleConfiguration =
                            newPlanBulkWithProrationPrice.billingCycleConfiguration
                        conversionRate = newPlanBulkWithProrationPrice.conversionRate
                        currency = newPlanBulkWithProrationPrice.currency
                        externalPriceId = newPlanBulkWithProrationPrice.externalPriceId
                        fixedPriceQuantity = newPlanBulkWithProrationPrice.fixedPriceQuantity
                        invoiceGroupingKey = newPlanBulkWithProrationPrice.invoiceGroupingKey
                        invoicingCycleConfiguration =
                            newPlanBulkWithProrationPrice.invoicingCycleConfiguration
                        metadata = newPlanBulkWithProrationPrice.metadata
                        additionalProperties =
                            newPlanBulkWithProrationPrice.additionalProperties.toMutableMap()
                    }

                fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                    apply {
                        this.bulkWithProrationConfig = bulkWithProrationConfig
                    }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanBulkWithProrationPrice =
                    NewPlanBulkWithProrationPrice(
                        checkNotNull(bulkWithProrationConfig) {
                            "`bulkWithProrationConfig` is required but was not set"
                        },
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class BulkWithProrationConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                        additionalProperties =
                            bulkWithProrationConfig.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BulkWithProrationConfig =
                        BulkWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BulkWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_WITH_PRORATION,
                }

                enum class Value {
                    BULK_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkWithProrationPrice && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bulkWithProrationConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanBulkWithProrationPrice{bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class NewPlanGroupedTieredPackagePrice
        @JsonCreator
        private constructor(
            @JsonProperty("cadence") private val cadence: Cadence,
            @JsonProperty("grouped_tiered_package_config")
            private val groupedTieredPackageConfig: GroupedTieredPackageConfig,
            @JsonProperty("item_id") private val itemId: String,
            @JsonProperty("model_type") private val modelType: ModelType,
            @JsonProperty("name") private val name: String,
            @JsonProperty("billable_metric_id") private val billableMetricId: String?,
            @JsonProperty("billed_in_advance") private val billedInAdvance: Boolean?,
            @JsonProperty("billing_cycle_configuration")
            private val billingCycleConfiguration: BillingCycleConfiguration?,
            @JsonProperty("conversion_rate") private val conversionRate: Double?,
            @JsonProperty("currency") private val currency: String?,
            @JsonProperty("external_price_id") private val externalPriceId: String?,
            @JsonProperty("fixed_price_quantity") private val fixedPriceQuantity: Double?,
            @JsonProperty("invoice_grouping_key") private val invoiceGroupingKey: String?,
            @JsonProperty("invoicing_cycle_configuration")
            private val invoicingCycleConfiguration: InvoicingCycleConfiguration?,
            @JsonProperty("metadata") private val metadata: Metadata?,
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") fun cadence(): Cadence = cadence

            @JsonProperty("grouped_tiered_package_config")
            fun groupedTieredPackageConfig(): GroupedTieredPackageConfig =
                groupedTieredPackageConfig

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") fun itemId(): String = itemId

            @JsonProperty("model_type") fun modelType(): ModelType = modelType

            /** The name of the price. */
            @JsonProperty("name") fun name(): String = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            fun billableMetricId(): Optional<String> = Optional.ofNullable(billableMetricId)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            fun billedInAdvance(): Optional<Boolean> = Optional.ofNullable(billedInAdvance)

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(billingCycleConfiguration)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate")
            fun conversionRate(): Optional<Double> = Optional.ofNullable(conversionRate)

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency")
            fun currency(): Optional<String> = Optional.ofNullable(currency)

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            fun externalPriceId(): Optional<String> = Optional.ofNullable(externalPriceId)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            fun fixedPriceQuantity(): Optional<Double> = Optional.ofNullable(fixedPriceQuantity)

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            fun invoiceGroupingKey(): Optional<String> = Optional.ofNullable(invoiceGroupingKey)

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(invoicingCycleConfiguration)

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var cadence: Cadence? = null
                private var groupedTieredPackageConfig: GroupedTieredPackageConfig? = null
                private var itemId: String? = null
                private var modelType: ModelType? = null
                private var name: String? = null
                private var billableMetricId: String? = null
                private var billedInAdvance: Boolean? = null
                private var billingCycleConfiguration: BillingCycleConfiguration? = null
                private var conversionRate: Double? = null
                private var currency: String? = null
                private var externalPriceId: String? = null
                private var fixedPriceQuantity: Double? = null
                private var invoiceGroupingKey: String? = null
                private var invoicingCycleConfiguration: InvoicingCycleConfiguration? = null
                private var metadata: Metadata? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanGroupedTieredPackagePrice: NewPlanGroupedTieredPackagePrice
                ) = apply {
                    cadence = newPlanGroupedTieredPackagePrice.cadence
                    groupedTieredPackageConfig =
                        newPlanGroupedTieredPackagePrice.groupedTieredPackageConfig
                    itemId = newPlanGroupedTieredPackagePrice.itemId
                    modelType = newPlanGroupedTieredPackagePrice.modelType
                    name = newPlanGroupedTieredPackagePrice.name
                    billableMetricId = newPlanGroupedTieredPackagePrice.billableMetricId
                    billedInAdvance = newPlanGroupedTieredPackagePrice.billedInAdvance
                    billingCycleConfiguration =
                        newPlanGroupedTieredPackagePrice.billingCycleConfiguration
                    conversionRate = newPlanGroupedTieredPackagePrice.conversionRate
                    currency = newPlanGroupedTieredPackagePrice.currency
                    externalPriceId = newPlanGroupedTieredPackagePrice.externalPriceId
                    fixedPriceQuantity = newPlanGroupedTieredPackagePrice.fixedPriceQuantity
                    invoiceGroupingKey = newPlanGroupedTieredPackagePrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newPlanGroupedTieredPackagePrice.invoicingCycleConfiguration
                    metadata = newPlanGroupedTieredPackagePrice.metadata
                    additionalProperties =
                        newPlanGroupedTieredPackagePrice.additionalProperties.toMutableMap()
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = apply { this.cadence = cadence }

                fun groupedTieredPackageConfig(
                    groupedTieredPackageConfig: GroupedTieredPackageConfig
                ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = apply { this.itemId = itemId }

                fun modelType(modelType: ModelType) = apply { this.modelType = modelType }

                /** The name of the price. */
                fun name(name: String) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String?) = apply {
                    this.billableMetricId = billableMetricId
                }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: Optional<String>) =
                    billableMetricId(billableMetricId.orElse(null))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean?) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(billedInAdvance as Boolean?)

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                    billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration?
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: Optional<BillingCycleConfiguration>
                ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double?) = apply {
                    this.conversionRate = conversionRate
                }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(conversionRate as Double?)

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun conversionRate(conversionRate: Optional<Double>) =
                    conversionRate(conversionRate.orElse(null) as Double?)

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String?) = apply { this.currency = currency }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: Optional<String>) = currency(currency.orElse(null))

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String?) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: Optional<String>) =
                    externalPriceId(externalPriceId.orElse(null))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double?) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(fixedPriceQuantity as Double?)

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                    fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String?) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                    invoiceGroupingKey(invoiceGroupingKey.orElse(null))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration?
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
                ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata?) = apply { this.metadata = metadata }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): NewPlanGroupedTieredPackagePrice =
                    NewPlanGroupedTieredPackagePrice(
                        checkNotNull(cadence) { "`cadence` is required but was not set" },
                        checkNotNull(groupedTieredPackageConfig) {
                            "`groupedTieredPackageConfig` is required but was not set"
                        },
                        checkNotNull(itemId) { "`itemId` is required but was not set" },
                        checkNotNull(modelType) { "`modelType` is required but was not set" },
                        checkNotNull(name) { "`name` is required but was not set" },
                        billableMetricId,
                        billedInAdvance,
                        billingCycleConfiguration,
                        conversionRate,
                        currency,
                        externalPriceId,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        invoicingCycleConfiguration,
                        metadata,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val ANNUAL = of("annual")

                    @JvmField val SEMI_ANNUAL = of("semi_annual")

                    @JvmField val MONTHLY = of("monthly")

                    @JvmField val QUARTERLY = of("quarterly")

                    @JvmField val ONE_TIME = of("one_time")

                    @JvmField val CUSTOM = of("custom")

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            @NoAutoDetect
            class GroupedTieredPackageConfig
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(groupedTieredPackageConfig: GroupedTieredPackageConfig) =
                        apply {
                            additionalProperties =
                                groupedTieredPackageConfig.additionalProperties.toMutableMap()
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): GroupedTieredPackageConfig =
                        GroupedTieredPackageConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "GroupedTieredPackageConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_TIERED_PACKAGE,
                }

                enum class Value {
                    GROUPED_TIERED_PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @NoAutoDetect
            class BillingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            duration = billingCycleConfiguration.duration
                            durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties =
                                billingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @NoAutoDetect
            class InvoicingCycleConfiguration
            @JsonCreator
            private constructor(
                @JsonProperty("duration") private val duration: Long,
                @JsonProperty("duration_unit") private val durationUnit: DurationUnit,
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** The duration of the billing period. */
                @JsonProperty("duration") fun duration(): Long = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") fun durationUnit(): DurationUnit = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: Long? = null
                    private var durationUnit: DurationUnit? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            duration = invoicingCycleConfiguration.duration
                            durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties =
                                invoicingCycleConfiguration.additionalProperties.toMutableMap()
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            checkNotNull(duration) { "`duration` is required but was not set" },
                            checkNotNull(durationUnit) {
                                "`durationUnit` is required but was not set"
                            },
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        @JvmField val DAY = of("day")

                        @JvmField val MONTH = of("month")

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @NoAutoDetect
            class Metadata
            @JsonCreator
            private constructor(
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties = metadata.additionalProperties.toMutableMap()
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedTieredPackagePrice && cadence == other.cadence && groupedTieredPackageConfig == other.groupedTieredPackageConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(cadence, groupedTieredPackageConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NewPlanGroupedTieredPackagePrice{cadence=$cadence, groupedTieredPackageConfig=$groupedTieredPackageConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, additionalProperties=$additionalProperties}"
        }
    }

    /**
     * User-specified key/value pairs for the resource. Individual keys can be removed by setting
     * the value to `null`, and the entire metadata mapping can be cleared by setting `metadata` to
     * `null`.
     */
    @NoAutoDetect
    class Metadata
    @JsonCreator
    private constructor(
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(metadata: Metadata) = apply {
                additionalProperties = metadata.additionalProperties.toMutableMap()
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): Metadata = Metadata(additionalProperties.toImmutable())
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
    }

    class Status
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            @JvmField val ACTIVE = of("active")

            @JvmField val DRAFT = of("draft")

            @JvmStatic fun of(value: String) = Status(JsonField.of(value))
        }

        enum class Known {
            ACTIVE,
            DRAFT,
        }

        enum class Value {
            ACTIVE,
            DRAFT,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                ACTIVE -> Value.ACTIVE
                DRAFT -> Value.DRAFT
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                ACTIVE -> Known.ACTIVE
                DRAFT -> Known.DRAFT
                else -> throw OrbInvalidDataException("Unknown Status: $value")
            }

        fun asString(): String = _value().asStringOrThrow()

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Status && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is PlanCreateParams && body == other.body && additionalHeaders == other.additionalHeaders && additionalQueryParams == other.additionalQueryParams /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(body, additionalHeaders, additionalQueryParams) /* spotless:on */

    override fun toString() =
        "PlanCreateParams{body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
