// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.toUnmodifiable
import com.withorb.api.errors.OrbInvalidDataException
import com.withorb.api.models.*
import java.util.Objects
import java.util.Optional

class PlanCreateParams
constructor(
    private val currency: String,
    private val name: String,
    private val prices: List<Price>,
    private val defaultInvoiceMemo: String?,
    private val externalPlanId: String?,
    private val metadata: Metadata?,
    private val netTerms: Long?,
    private val status: Status?,
    private val additionalQueryParams: Map<String, List<String>>,
    private val additionalHeaders: Map<String, List<String>>,
    private val additionalBodyProperties: Map<String, JsonValue>,
) {

    fun currency(): String = currency

    fun name(): String = name

    fun prices(): List<Price> = prices

    fun defaultInvoiceMemo(): Optional<String> = Optional.ofNullable(defaultInvoiceMemo)

    fun externalPlanId(): Optional<String> = Optional.ofNullable(externalPlanId)

    fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

    fun netTerms(): Optional<Long> = Optional.ofNullable(netTerms)

    fun status(): Optional<Status> = Optional.ofNullable(status)

    @JvmSynthetic
    internal fun getBody(): PlanCreateBody {
        return PlanCreateBody(
            currency,
            name,
            prices,
            defaultInvoiceMemo,
            externalPlanId,
            metadata,
            netTerms,
            status,
            additionalBodyProperties,
        )
    }

    @JvmSynthetic internal fun getQueryParams(): Map<String, List<String>> = additionalQueryParams

    @JvmSynthetic internal fun getHeaders(): Map<String, List<String>> = additionalHeaders

    @JsonDeserialize(builder = PlanCreateBody.Builder::class)
    @NoAutoDetect
    class PlanCreateBody
    internal constructor(
        private val currency: String?,
        private val name: String?,
        private val prices: List<Price>?,
        private val defaultInvoiceMemo: String?,
        private val externalPlanId: String?,
        private val metadata: Metadata?,
        private val netTerms: Long?,
        private val status: Status?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        @JsonProperty("currency") fun currency(): String? = currency

        @JsonProperty("name") fun name(): String? = name

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        @JsonProperty("prices") fun prices(): List<Price>? = prices

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        @JsonProperty("default_invoice_memo") fun defaultInvoiceMemo(): String? = defaultInvoiceMemo

        @JsonProperty("external_plan_id") fun externalPlanId(): String? = externalPlanId

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") fun metadata(): Metadata? = metadata

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        @JsonProperty("net_terms") fun netTerms(): Long? = netTerms

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        @JsonProperty("status") fun status(): Status? = status

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is PlanCreateBody &&
                this.currency == other.currency &&
                this.name == other.name &&
                this.prices == other.prices &&
                this.defaultInvoiceMemo == other.defaultInvoiceMemo &&
                this.externalPlanId == other.externalPlanId &&
                this.metadata == other.metadata &&
                this.netTerms == other.netTerms &&
                this.status == other.status &&
                this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode =
                    Objects.hash(
                        currency,
                        name,
                        prices,
                        defaultInvoiceMemo,
                        externalPlanId,
                        metadata,
                        netTerms,
                        status,
                        additionalProperties,
                    )
            }
            return hashCode
        }

        override fun toString() =
            "PlanCreateBody{currency=$currency, name=$name, prices=$prices, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, metadata=$metadata, netTerms=$netTerms, status=$status, additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var currency: String? = null
            private var name: String? = null
            private var prices: List<Price>? = null
            private var defaultInvoiceMemo: String? = null
            private var externalPlanId: String? = null
            private var metadata: Metadata? = null
            private var netTerms: Long? = null
            private var status: Status? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(planCreateBody: PlanCreateBody) = apply {
                this.currency = planCreateBody.currency
                this.name = planCreateBody.name
                this.prices = planCreateBody.prices
                this.defaultInvoiceMemo = planCreateBody.defaultInvoiceMemo
                this.externalPlanId = planCreateBody.externalPlanId
                this.metadata = planCreateBody.metadata
                this.netTerms = planCreateBody.netTerms
                this.status = planCreateBody.status
                additionalProperties(planCreateBody.additionalProperties)
            }

            /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
            @JsonProperty("currency")
            fun currency(currency: String) = apply { this.currency = currency }

            @JsonProperty("name") fun name(name: String) = apply { this.name = name }

            /**
             * Prices for this plan. If the plan has phases, this includes prices across all phases
             * of the plan.
             */
            @JsonProperty("prices") fun prices(prices: List<Price>) = apply { this.prices = prices }

            /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
            @JsonProperty("default_invoice_memo")
            fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
                this.defaultInvoiceMemo = defaultInvoiceMemo
            }

            @JsonProperty("external_plan_id")
            fun externalPlanId(externalPlanId: String) = apply {
                this.externalPlanId = externalPlanId
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(metadata: Metadata) = apply { this.metadata = metadata }

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0.
             */
            @JsonProperty("net_terms")
            fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

            /**
             * The status of the plan to create (either active or draft). If not specified, this
             * defaults to active.
             */
            @JsonProperty("status") fun status(status: Status) = apply { this.status = status }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): PlanCreateBody =
                PlanCreateBody(
                    checkNotNull(currency) { "`currency` is required but was not set" },
                    checkNotNull(name) { "`name` is required but was not set" },
                    checkNotNull(prices) { "`prices` is required but was not set" }
                        .toUnmodifiable(),
                    defaultInvoiceMemo,
                    externalPlanId,
                    metadata,
                    netTerms,
                    status,
                    additionalProperties.toUnmodifiable(),
                )
        }
    }

    fun _additionalQueryParams(): Map<String, List<String>> = additionalQueryParams

    fun _additionalHeaders(): Map<String, List<String>> = additionalHeaders

    fun _additionalBodyProperties(): Map<String, JsonValue> = additionalBodyProperties

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is PlanCreateParams &&
            this.currency == other.currency &&
            this.name == other.name &&
            this.prices == other.prices &&
            this.defaultInvoiceMemo == other.defaultInvoiceMemo &&
            this.externalPlanId == other.externalPlanId &&
            this.metadata == other.metadata &&
            this.netTerms == other.netTerms &&
            this.status == other.status &&
            this.additionalQueryParams == other.additionalQueryParams &&
            this.additionalHeaders == other.additionalHeaders &&
            this.additionalBodyProperties == other.additionalBodyProperties
    }

    override fun hashCode(): Int {
        return Objects.hash(
            currency,
            name,
            prices,
            defaultInvoiceMemo,
            externalPlanId,
            metadata,
            netTerms,
            status,
            additionalQueryParams,
            additionalHeaders,
            additionalBodyProperties,
        )
    }

    override fun toString() =
        "PlanCreateParams{currency=$currency, name=$name, prices=$prices, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, metadata=$metadata, netTerms=$netTerms, status=$status, additionalQueryParams=$additionalQueryParams, additionalHeaders=$additionalHeaders, additionalBodyProperties=$additionalBodyProperties}"

    fun toBuilder() = Builder().from(this)

    companion object {

        @JvmStatic fun builder() = Builder()
    }

    @NoAutoDetect
    class Builder {

        private var currency: String? = null
        private var name: String? = null
        private var prices: MutableList<Price> = mutableListOf()
        private var defaultInvoiceMemo: String? = null
        private var externalPlanId: String? = null
        private var metadata: Metadata? = null
        private var netTerms: Long? = null
        private var status: Status? = null
        private var additionalQueryParams: MutableMap<String, MutableList<String>> = mutableMapOf()
        private var additionalHeaders: MutableMap<String, MutableList<String>> = mutableMapOf()
        private var additionalBodyProperties: MutableMap<String, JsonValue> = mutableMapOf()

        @JvmSynthetic
        internal fun from(planCreateParams: PlanCreateParams) = apply {
            this.currency = planCreateParams.currency
            this.name = planCreateParams.name
            this.prices(planCreateParams.prices)
            this.defaultInvoiceMemo = planCreateParams.defaultInvoiceMemo
            this.externalPlanId = planCreateParams.externalPlanId
            this.metadata = planCreateParams.metadata
            this.netTerms = planCreateParams.netTerms
            this.status = planCreateParams.status
            additionalQueryParams(planCreateParams.additionalQueryParams)
            additionalHeaders(planCreateParams.additionalHeaders)
            additionalBodyProperties(planCreateParams.additionalBodyProperties)
        }

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        fun currency(currency: String) = apply { this.currency = currency }

        fun name(name: String) = apply { this.name = name }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun prices(prices: List<Price>) = apply {
            this.prices.clear()
            this.prices.addAll(prices)
        }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun addPrice(price: Price) = apply { this.prices.add(price) }

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
            this.defaultInvoiceMemo = defaultInvoiceMemo
        }

        fun externalPlanId(externalPlanId: String) = apply { this.externalPlanId = externalPlanId }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(metadata: Metadata) = apply { this.metadata = metadata }

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        fun status(status: Status) = apply { this.status = status }

        fun additionalQueryParams(additionalQueryParams: Map<String, List<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllQueryParams(additionalQueryParams)
        }

        fun putQueryParam(name: String, value: String) = apply {
            this.additionalQueryParams.getOrPut(name) { mutableListOf() }.add(value)
        }

        fun putQueryParams(name: String, values: Iterable<String>) = apply {
            this.additionalQueryParams.getOrPut(name) { mutableListOf() }.addAll(values)
        }

        fun putAllQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            additionalQueryParams.forEach(this::putQueryParams)
        }

        fun removeQueryParam(name: String) = apply {
            this.additionalQueryParams.put(name, mutableListOf())
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllHeaders(additionalHeaders)
        }

        fun putHeader(name: String, value: String) = apply {
            this.additionalHeaders.getOrPut(name) { mutableListOf() }.add(value)
        }

        fun putHeaders(name: String, values: Iterable<String>) = apply {
            this.additionalHeaders.getOrPut(name) { mutableListOf() }.addAll(values)
        }

        fun putAllHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(this::putHeaders)
        }

        fun removeHeader(name: String) = apply { this.additionalHeaders.put(name, mutableListOf()) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            this.additionalBodyProperties.clear()
            this.additionalBodyProperties.putAll(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            this.additionalBodyProperties.put(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                this.additionalBodyProperties.putAll(additionalBodyProperties)
            }

        fun build(): PlanCreateParams =
            PlanCreateParams(
                checkNotNull(currency) { "`currency` is required but was not set" },
                checkNotNull(name) { "`name` is required but was not set" },
                checkNotNull(prices) { "`prices` is required but was not set" }.toUnmodifiable(),
                defaultInvoiceMemo,
                externalPlanId,
                metadata,
                netTerms,
                status,
                additionalQueryParams.mapValues { it.value.toUnmodifiable() }.toUnmodifiable(),
                additionalHeaders.mapValues { it.value.toUnmodifiable() }.toUnmodifiable(),
                additionalBodyProperties.toUnmodifiable(),
            )
    }

    @JsonDeserialize(using = Price.Deserializer::class)
    @JsonSerialize(using = Price.Serializer::class)
    class Price
    private constructor(
        private val newPlanUnitPrice: NewPlanUnitPrice? = null,
        private val newPlanPackagePrice: NewPlanPackagePrice? = null,
        private val newPlanMatrixPrice: NewPlanMatrixPrice? = null,
        private val newPlanTieredPrice: NewPlanTieredPrice? = null,
        private val newPlanTieredBpsPrice: NewPlanTieredBpsPrice? = null,
        private val newPlanBpsPrice: NewPlanBpsPrice? = null,
        private val newPlanBulkBpsPrice: NewPlanBulkBpsPrice? = null,
        private val newPlanBulkPrice: NewPlanBulkPrice? = null,
        private val newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice? = null,
        private val newPlanTieredPackagePrice: NewPlanTieredPackagePrice? = null,
        private val newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice? = null,
        private val newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice? = null,
        private val newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice? = null,
        private val newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice? = null,
        private val newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice? = null,
        private val _json: JsonValue? = null,
    ) {

        private var validated: Boolean = false

        fun newPlanUnitPrice(): Optional<NewPlanUnitPrice> = Optional.ofNullable(newPlanUnitPrice)

        fun newPlanPackagePrice(): Optional<NewPlanPackagePrice> =
            Optional.ofNullable(newPlanPackagePrice)

        fun newPlanMatrixPrice(): Optional<NewPlanMatrixPrice> =
            Optional.ofNullable(newPlanMatrixPrice)

        fun newPlanTieredPrice(): Optional<NewPlanTieredPrice> =
            Optional.ofNullable(newPlanTieredPrice)

        fun newPlanTieredBpsPrice(): Optional<NewPlanTieredBpsPrice> =
            Optional.ofNullable(newPlanTieredBpsPrice)

        fun newPlanBpsPrice(): Optional<NewPlanBpsPrice> = Optional.ofNullable(newPlanBpsPrice)

        fun newPlanBulkBpsPrice(): Optional<NewPlanBulkBpsPrice> =
            Optional.ofNullable(newPlanBulkBpsPrice)

        fun newPlanBulkPrice(): Optional<NewPlanBulkPrice> = Optional.ofNullable(newPlanBulkPrice)

        fun newPlanThresholdTotalAmountPrice(): Optional<NewPlanThresholdTotalAmountPrice> =
            Optional.ofNullable(newPlanThresholdTotalAmountPrice)

        fun newPlanTieredPackagePrice(): Optional<NewPlanTieredPackagePrice> =
            Optional.ofNullable(newPlanTieredPackagePrice)

        fun newPlanTieredWithMinimumPrice(): Optional<NewPlanTieredWithMinimumPrice> =
            Optional.ofNullable(newPlanTieredWithMinimumPrice)

        fun newPlanUnitWithPercentPrice(): Optional<NewPlanUnitWithPercentPrice> =
            Optional.ofNullable(newPlanUnitWithPercentPrice)

        fun newPlanPackageWithAllocationPrice(): Optional<NewPlanPackageWithAllocationPrice> =
            Optional.ofNullable(newPlanPackageWithAllocationPrice)

        fun newPlanTierWithProrationPrice(): Optional<NewPlanTierWithProrationPrice> =
            Optional.ofNullable(newPlanTierWithProrationPrice)

        fun newPlanUnitWithProrationPrice(): Optional<NewPlanUnitWithProrationPrice> =
            Optional.ofNullable(newPlanUnitWithProrationPrice)

        fun isNewPlanUnitPrice(): Boolean = newPlanUnitPrice != null

        fun isNewPlanPackagePrice(): Boolean = newPlanPackagePrice != null

        fun isNewPlanMatrixPrice(): Boolean = newPlanMatrixPrice != null

        fun isNewPlanTieredPrice(): Boolean = newPlanTieredPrice != null

        fun isNewPlanTieredBpsPrice(): Boolean = newPlanTieredBpsPrice != null

        fun isNewPlanBpsPrice(): Boolean = newPlanBpsPrice != null

        fun isNewPlanBulkBpsPrice(): Boolean = newPlanBulkBpsPrice != null

        fun isNewPlanBulkPrice(): Boolean = newPlanBulkPrice != null

        fun isNewPlanThresholdTotalAmountPrice(): Boolean = newPlanThresholdTotalAmountPrice != null

        fun isNewPlanTieredPackagePrice(): Boolean = newPlanTieredPackagePrice != null

        fun isNewPlanTieredWithMinimumPrice(): Boolean = newPlanTieredWithMinimumPrice != null

        fun isNewPlanUnitWithPercentPrice(): Boolean = newPlanUnitWithPercentPrice != null

        fun isNewPlanPackageWithAllocationPrice(): Boolean =
            newPlanPackageWithAllocationPrice != null

        fun isNewPlanTierWithProrationPrice(): Boolean = newPlanTierWithProrationPrice != null

        fun isNewPlanUnitWithProrationPrice(): Boolean = newPlanUnitWithProrationPrice != null

        fun asNewPlanUnitPrice(): NewPlanUnitPrice = newPlanUnitPrice.getOrThrow("newPlanUnitPrice")

        fun asNewPlanPackagePrice(): NewPlanPackagePrice =
            newPlanPackagePrice.getOrThrow("newPlanPackagePrice")

        fun asNewPlanMatrixPrice(): NewPlanMatrixPrice =
            newPlanMatrixPrice.getOrThrow("newPlanMatrixPrice")

        fun asNewPlanTieredPrice(): NewPlanTieredPrice =
            newPlanTieredPrice.getOrThrow("newPlanTieredPrice")

        fun asNewPlanTieredBpsPrice(): NewPlanTieredBpsPrice =
            newPlanTieredBpsPrice.getOrThrow("newPlanTieredBpsPrice")

        fun asNewPlanBpsPrice(): NewPlanBpsPrice = newPlanBpsPrice.getOrThrow("newPlanBpsPrice")

        fun asNewPlanBulkBpsPrice(): NewPlanBulkBpsPrice =
            newPlanBulkBpsPrice.getOrThrow("newPlanBulkBpsPrice")

        fun asNewPlanBulkPrice(): NewPlanBulkPrice = newPlanBulkPrice.getOrThrow("newPlanBulkPrice")

        fun asNewPlanThresholdTotalAmountPrice(): NewPlanThresholdTotalAmountPrice =
            newPlanThresholdTotalAmountPrice.getOrThrow("newPlanThresholdTotalAmountPrice")

        fun asNewPlanTieredPackagePrice(): NewPlanTieredPackagePrice =
            newPlanTieredPackagePrice.getOrThrow("newPlanTieredPackagePrice")

        fun asNewPlanTieredWithMinimumPrice(): NewPlanTieredWithMinimumPrice =
            newPlanTieredWithMinimumPrice.getOrThrow("newPlanTieredWithMinimumPrice")

        fun asNewPlanUnitWithPercentPrice(): NewPlanUnitWithPercentPrice =
            newPlanUnitWithPercentPrice.getOrThrow("newPlanUnitWithPercentPrice")

        fun asNewPlanPackageWithAllocationPrice(): NewPlanPackageWithAllocationPrice =
            newPlanPackageWithAllocationPrice.getOrThrow("newPlanPackageWithAllocationPrice")

        fun asNewPlanTierWithProrationPrice(): NewPlanTierWithProrationPrice =
            newPlanTierWithProrationPrice.getOrThrow("newPlanTierWithProrationPrice")

        fun asNewPlanUnitWithProrationPrice(): NewPlanUnitWithProrationPrice =
            newPlanUnitWithProrationPrice.getOrThrow("newPlanUnitWithProrationPrice")

        fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                newPlanUnitPrice != null -> visitor.visitNewPlanUnitPrice(newPlanUnitPrice)
                newPlanPackagePrice != null -> visitor.visitNewPlanPackagePrice(newPlanPackagePrice)
                newPlanMatrixPrice != null -> visitor.visitNewPlanMatrixPrice(newPlanMatrixPrice)
                newPlanTieredPrice != null -> visitor.visitNewPlanTieredPrice(newPlanTieredPrice)
                newPlanTieredBpsPrice != null ->
                    visitor.visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice)
                newPlanBpsPrice != null -> visitor.visitNewPlanBpsPrice(newPlanBpsPrice)
                newPlanBulkBpsPrice != null -> visitor.visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice)
                newPlanBulkPrice != null -> visitor.visitNewPlanBulkPrice(newPlanBulkPrice)
                newPlanThresholdTotalAmountPrice != null ->
                    visitor.visitNewPlanThresholdTotalAmountPrice(newPlanThresholdTotalAmountPrice)
                newPlanTieredPackagePrice != null ->
                    visitor.visitNewPlanTieredPackagePrice(newPlanTieredPackagePrice)
                newPlanTieredWithMinimumPrice != null ->
                    visitor.visitNewPlanTieredWithMinimumPrice(newPlanTieredWithMinimumPrice)
                newPlanUnitWithPercentPrice != null ->
                    visitor.visitNewPlanUnitWithPercentPrice(newPlanUnitWithPercentPrice)
                newPlanPackageWithAllocationPrice != null ->
                    visitor.visitNewPlanPackageWithAllocationPrice(
                        newPlanPackageWithAllocationPrice
                    )
                newPlanTierWithProrationPrice != null ->
                    visitor.visitNewPlanTierWithProrationPrice(newPlanTierWithProrationPrice)
                newPlanUnitWithProrationPrice != null ->
                    visitor.visitNewPlanUnitWithProrationPrice(newPlanUnitWithProrationPrice)
                else -> visitor.unknown(_json)
            }
        }

        fun validate(): Price = apply {
            if (!validated) {
                if (
                    newPlanUnitPrice == null &&
                        newPlanPackagePrice == null &&
                        newPlanMatrixPrice == null &&
                        newPlanTieredPrice == null &&
                        newPlanTieredBpsPrice == null &&
                        newPlanBpsPrice == null &&
                        newPlanBulkBpsPrice == null &&
                        newPlanBulkPrice == null &&
                        newPlanThresholdTotalAmountPrice == null &&
                        newPlanTieredPackagePrice == null &&
                        newPlanTieredWithMinimumPrice == null &&
                        newPlanUnitWithPercentPrice == null &&
                        newPlanPackageWithAllocationPrice == null &&
                        newPlanTierWithProrationPrice == null &&
                        newPlanUnitWithProrationPrice == null
                ) {
                    throw OrbInvalidDataException("Unknown Price: $_json")
                }
                newPlanUnitPrice?.validate()
                newPlanPackagePrice?.validate()
                newPlanMatrixPrice?.validate()
                newPlanTieredPrice?.validate()
                newPlanTieredBpsPrice?.validate()
                newPlanBpsPrice?.validate()
                newPlanBulkBpsPrice?.validate()
                newPlanBulkPrice?.validate()
                newPlanThresholdTotalAmountPrice?.validate()
                newPlanTieredPackagePrice?.validate()
                newPlanTieredWithMinimumPrice?.validate()
                newPlanUnitWithPercentPrice?.validate()
                newPlanPackageWithAllocationPrice?.validate()
                newPlanTierWithProrationPrice?.validate()
                newPlanUnitWithProrationPrice?.validate()
                validated = true
            }
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Price &&
                this.newPlanUnitPrice == other.newPlanUnitPrice &&
                this.newPlanPackagePrice == other.newPlanPackagePrice &&
                this.newPlanMatrixPrice == other.newPlanMatrixPrice &&
                this.newPlanTieredPrice == other.newPlanTieredPrice &&
                this.newPlanTieredBpsPrice == other.newPlanTieredBpsPrice &&
                this.newPlanBpsPrice == other.newPlanBpsPrice &&
                this.newPlanBulkBpsPrice == other.newPlanBulkBpsPrice &&
                this.newPlanBulkPrice == other.newPlanBulkPrice &&
                this.newPlanThresholdTotalAmountPrice == other.newPlanThresholdTotalAmountPrice &&
                this.newPlanTieredPackagePrice == other.newPlanTieredPackagePrice &&
                this.newPlanTieredWithMinimumPrice == other.newPlanTieredWithMinimumPrice &&
                this.newPlanUnitWithPercentPrice == other.newPlanUnitWithPercentPrice &&
                this.newPlanPackageWithAllocationPrice == other.newPlanPackageWithAllocationPrice &&
                this.newPlanTierWithProrationPrice == other.newPlanTierWithProrationPrice &&
                this.newPlanUnitWithProrationPrice == other.newPlanUnitWithProrationPrice
        }

        override fun hashCode(): Int {
            return Objects.hash(
                newPlanUnitPrice,
                newPlanPackagePrice,
                newPlanMatrixPrice,
                newPlanTieredPrice,
                newPlanTieredBpsPrice,
                newPlanBpsPrice,
                newPlanBulkBpsPrice,
                newPlanBulkPrice,
                newPlanThresholdTotalAmountPrice,
                newPlanTieredPackagePrice,
                newPlanTieredWithMinimumPrice,
                newPlanUnitWithPercentPrice,
                newPlanPackageWithAllocationPrice,
                newPlanTierWithProrationPrice,
                newPlanUnitWithProrationPrice,
            )
        }

        override fun toString(): String {
            return when {
                newPlanUnitPrice != null -> "Price{newPlanUnitPrice=$newPlanUnitPrice}"
                newPlanPackagePrice != null -> "Price{newPlanPackagePrice=$newPlanPackagePrice}"
                newPlanMatrixPrice != null -> "Price{newPlanMatrixPrice=$newPlanMatrixPrice}"
                newPlanTieredPrice != null -> "Price{newPlanTieredPrice=$newPlanTieredPrice}"
                newPlanTieredBpsPrice != null ->
                    "Price{newPlanTieredBpsPrice=$newPlanTieredBpsPrice}"
                newPlanBpsPrice != null -> "Price{newPlanBpsPrice=$newPlanBpsPrice}"
                newPlanBulkBpsPrice != null -> "Price{newPlanBulkBpsPrice=$newPlanBulkBpsPrice}"
                newPlanBulkPrice != null -> "Price{newPlanBulkPrice=$newPlanBulkPrice}"
                newPlanThresholdTotalAmountPrice != null ->
                    "Price{newPlanThresholdTotalAmountPrice=$newPlanThresholdTotalAmountPrice}"
                newPlanTieredPackagePrice != null ->
                    "Price{newPlanTieredPackagePrice=$newPlanTieredPackagePrice}"
                newPlanTieredWithMinimumPrice != null ->
                    "Price{newPlanTieredWithMinimumPrice=$newPlanTieredWithMinimumPrice}"
                newPlanUnitWithPercentPrice != null ->
                    "Price{newPlanUnitWithPercentPrice=$newPlanUnitWithPercentPrice}"
                newPlanPackageWithAllocationPrice != null ->
                    "Price{newPlanPackageWithAllocationPrice=$newPlanPackageWithAllocationPrice}"
                newPlanTierWithProrationPrice != null ->
                    "Price{newPlanTierWithProrationPrice=$newPlanTierWithProrationPrice}"
                newPlanUnitWithProrationPrice != null ->
                    "Price{newPlanUnitWithProrationPrice=$newPlanUnitWithProrationPrice}"
                _json != null -> "Price{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Price")
            }
        }

        companion object {

            @JvmStatic
            fun ofNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice) =
                Price(newPlanUnitPrice = newPlanUnitPrice)

            @JvmStatic
            fun ofNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice) =
                Price(newPlanPackagePrice = newPlanPackagePrice)

            @JvmStatic
            fun ofNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice) =
                Price(newPlanMatrixPrice = newPlanMatrixPrice)

            @JvmStatic
            fun ofNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice) =
                Price(newPlanTieredPrice = newPlanTieredPrice)

            @JvmStatic
            fun ofNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) =
                Price(newPlanTieredBpsPrice = newPlanTieredBpsPrice)

            @JvmStatic
            fun ofNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice) =
                Price(newPlanBpsPrice = newPlanBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) =
                Price(newPlanBulkBpsPrice = newPlanBulkBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice) =
                Price(newPlanBulkPrice = newPlanBulkPrice)

            @JvmStatic
            fun ofNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ) = Price(newPlanThresholdTotalAmountPrice = newPlanThresholdTotalAmountPrice)

            @JvmStatic
            fun ofNewPlanTieredPackagePrice(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) =
                Price(newPlanTieredPackagePrice = newPlanTieredPackagePrice)

            @JvmStatic
            fun ofNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ) = Price(newPlanTieredWithMinimumPrice = newPlanTieredWithMinimumPrice)

            @JvmStatic
            fun ofNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ) = Price(newPlanUnitWithPercentPrice = newPlanUnitWithPercentPrice)

            @JvmStatic
            fun ofNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ) = Price(newPlanPackageWithAllocationPrice = newPlanPackageWithAllocationPrice)

            @JvmStatic
            fun ofNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ) = Price(newPlanTierWithProrationPrice = newPlanTierWithProrationPrice)

            @JvmStatic
            fun ofNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ) = Price(newPlanUnitWithProrationPrice = newPlanUnitWithProrationPrice)
        }

        interface Visitor<out T> {

            fun visitNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice): T

            fun visitNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice): T

            fun visitNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice): T

            fun visitNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice): T

            fun visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice): T

            fun visitNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice): T

            fun visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice): T

            fun visitNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice): T

            fun visitNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ): T

            fun visitNewPlanTieredPackagePrice(
                newPlanTieredPackagePrice: NewPlanTieredPackagePrice
            ): T

            fun visitNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ): T

            fun visitNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ): T

            fun visitNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ): T

            fun visitNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ): T

            fun visitNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ): T

            fun unknown(json: JsonValue?): T {
                throw OrbInvalidDataException("Unknown Price: $json")
            }
        }

        class Deserializer : BaseDeserializer<Price>(Price::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Price {
                val json = JsonValue.fromJsonNode(node)
                tryDeserialize(node, jacksonTypeRef<NewPlanUnitPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanUnitPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanPackagePrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanPackagePrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanMatrixPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanMatrixPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanTieredPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanTieredPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanTieredBpsPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanTieredBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanBpsPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanBulkBpsPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanBulkBpsPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanBulkPrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanBulkPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanThresholdTotalAmountPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanThresholdTotalAmountPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanTieredPackagePrice>()) { it.validate() }
                    ?.let {
                        return Price(newPlanTieredPackagePrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanTieredWithMinimumPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanTieredWithMinimumPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithPercentPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanUnitWithPercentPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanPackageWithAllocationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanPackageWithAllocationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanTierWithProrationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanTierWithProrationPrice = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithProrationPrice>()) {
                        it.validate()
                    }
                    ?.let {
                        return Price(newPlanUnitWithProrationPrice = it, _json = json)
                    }

                return Price(_json = json)
            }
        }

        class Serializer : BaseSerializer<Price>(Price::class) {

            override fun serialize(
                value: Price,
                generator: JsonGenerator,
                provider: SerializerProvider
            ) {
                when {
                    value.newPlanUnitPrice != null -> generator.writeObject(value.newPlanUnitPrice)
                    value.newPlanPackagePrice != null ->
                        generator.writeObject(value.newPlanPackagePrice)
                    value.newPlanMatrixPrice != null ->
                        generator.writeObject(value.newPlanMatrixPrice)
                    value.newPlanTieredPrice != null ->
                        generator.writeObject(value.newPlanTieredPrice)
                    value.newPlanTieredBpsPrice != null ->
                        generator.writeObject(value.newPlanTieredBpsPrice)
                    value.newPlanBpsPrice != null -> generator.writeObject(value.newPlanBpsPrice)
                    value.newPlanBulkBpsPrice != null ->
                        generator.writeObject(value.newPlanBulkBpsPrice)
                    value.newPlanBulkPrice != null -> generator.writeObject(value.newPlanBulkPrice)
                    value.newPlanThresholdTotalAmountPrice != null ->
                        generator.writeObject(value.newPlanThresholdTotalAmountPrice)
                    value.newPlanTieredPackagePrice != null ->
                        generator.writeObject(value.newPlanTieredPackagePrice)
                    value.newPlanTieredWithMinimumPrice != null ->
                        generator.writeObject(value.newPlanTieredWithMinimumPrice)
                    value.newPlanUnitWithPercentPrice != null ->
                        generator.writeObject(value.newPlanUnitWithPercentPrice)
                    value.newPlanPackageWithAllocationPrice != null ->
                        generator.writeObject(value.newPlanPackageWithAllocationPrice)
                    value.newPlanTierWithProrationPrice != null ->
                        generator.writeObject(value.newPlanTierWithProrationPrice)
                    value.newPlanUnitWithProrationPrice != null ->
                        generator.writeObject(value.newPlanUnitWithProrationPrice)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Price")
                }
            }
        }

        @JsonDeserialize(builder = NewPlanUnitPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitConfig: JsonField<UnitConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_config") @ExcludeMissing fun _unitConfig() = unitConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    unitConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanUnitPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.unitConfig == other.unitConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            unitConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, unitConfig=$unitConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitConfig: JsonField<UnitConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitPrice: NewPlanUnitPrice) = apply {
                    this.externalPriceId = newPlanUnitPrice.externalPriceId
                    this.name = newPlanUnitPrice.name
                    this.billableMetricId = newPlanUnitPrice.billableMetricId
                    this.itemId = newPlanUnitPrice.itemId
                    this.billedInAdvance = newPlanUnitPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanUnitPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanUnitPrice.invoiceGroupingKey
                    this.cadence = newPlanUnitPrice.cadence
                    this.conversionRate = newPlanUnitPrice.conversionRate
                    this.modelType = newPlanUnitPrice.modelType
                    this.unitConfig = newPlanUnitPrice.unitConfig
                    this.currency = newPlanUnitPrice.currency
                    additionalProperties(newPlanUnitPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

                @JsonProperty("unit_config")
                @ExcludeMissing
                fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                    this.unitConfig = unitConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitPrice =
                    NewPlanUnitPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        unitConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT = ModelType(JsonField.of("unit"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT,
                }

                enum class Value {
                    UNIT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT -> Value.UNIT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT -> Known.UNIT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitConfig.Builder::class)
            @NoAutoDetect
            class UnitConfig
            private constructor(
                private val unitAmount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Rate per unit of usage */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /** Rate per unit of usage */
                @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitConfig = apply {
                    if (!validated) {
                        unitAmount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitConfig &&
                        this.unitAmount == other.unitAmount &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(unitAmount, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var unitAmount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitConfig: UnitConfig) = apply {
                        this.unitAmount = unitConfig.unitAmount
                        additionalProperties(unitConfig.additionalProperties)
                    }

                    /** Rate per unit of usage */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Rate per unit of usage */
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitConfig =
                        UnitConfig(unitAmount, additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanPackagePrice.Builder::class)
        @NoAutoDetect
        class NewPlanPackagePrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val packageConfig: JsonField<PackageConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("package_config") @ExcludeMissing fun _packageConfig() = packageConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanPackagePrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    packageConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanPackagePrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.packageConfig == other.packageConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            packageConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanPackagePrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, packageConfig=$packageConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var packageConfig: JsonField<PackageConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanPackagePrice: NewPlanPackagePrice) = apply {
                    this.externalPriceId = newPlanPackagePrice.externalPriceId
                    this.name = newPlanPackagePrice.name
                    this.billableMetricId = newPlanPackagePrice.billableMetricId
                    this.itemId = newPlanPackagePrice.itemId
                    this.billedInAdvance = newPlanPackagePrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanPackagePrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanPackagePrice.invoiceGroupingKey
                    this.cadence = newPlanPackagePrice.cadence
                    this.conversionRate = newPlanPackagePrice.conversionRate
                    this.modelType = newPlanPackagePrice.modelType
                    this.packageConfig = newPlanPackagePrice.packageConfig
                    this.currency = newPlanPackagePrice.currency
                    additionalProperties(newPlanPackagePrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun packageConfig(packageConfig: PackageConfig) =
                    packageConfig(JsonField.of(packageConfig))

                @JsonProperty("package_config")
                @ExcludeMissing
                fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                    this.packageConfig = packageConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanPackagePrice =
                    NewPlanPackagePrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        packageConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val PACKAGE = ModelType(JsonField.of("package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE,
                }

                enum class Value {
                    PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE -> Value.PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE -> Known.PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageConfig.Builder::class)
            @NoAutoDetect
            class PackageConfig
            private constructor(
                private val packageAmount: JsonField<String>,
                private val packageSize: JsonField<Long>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** A currency amount to rate usage by */
                fun packageAmount(): String = packageAmount.getRequired("package_amount")

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(): Long = packageSize.getRequired("package_size")

                /** A currency amount to rate usage by */
                @JsonProperty("package_amount") @ExcludeMissing fun _packageAmount() = packageAmount

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                @JsonProperty("package_size") @ExcludeMissing fun _packageSize() = packageSize

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageConfig = apply {
                    if (!validated) {
                        packageAmount()
                        packageSize()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PackageConfig &&
                        this.packageAmount == other.packageAmount &&
                        this.packageSize == other.packageSize &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                packageAmount,
                                packageSize,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var packageAmount: JsonField<String> = JsonMissing.of()
                    private var packageSize: JsonField<Long> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageConfig: PackageConfig) = apply {
                        this.packageAmount = packageConfig.packageAmount
                        this.packageSize = packageConfig.packageSize
                        additionalProperties(packageConfig.additionalProperties)
                    }

                    /** A currency amount to rate usage by */
                    fun packageAmount(packageAmount: String) =
                        packageAmount(JsonField.of(packageAmount))

                    /** A currency amount to rate usage by */
                    @JsonProperty("package_amount")
                    @ExcludeMissing
                    fun packageAmount(packageAmount: JsonField<String>) = apply {
                        this.packageAmount = packageAmount
                    }

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    @JsonProperty("package_size")
                    @ExcludeMissing
                    fun packageSize(packageSize: JsonField<Long>) = apply {
                        this.packageSize = packageSize
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageConfig =
                        PackageConfig(
                            packageAmount,
                            packageSize,
                            additionalProperties.toUnmodifiable(),
                        )
                }
            }
        }

        @JsonDeserialize(builder = NewPlanMatrixPrice.Builder::class)
        @NoAutoDetect
        class NewPlanMatrixPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val matrixConfig: JsonField<MatrixConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("matrix_config") @ExcludeMissing fun _matrixConfig() = matrixConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanMatrixPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    matrixConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanMatrixPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.matrixConfig == other.matrixConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            matrixConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanMatrixPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, matrixConfig=$matrixConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var matrixConfig: JsonField<MatrixConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanMatrixPrice: NewPlanMatrixPrice) = apply {
                    this.externalPriceId = newPlanMatrixPrice.externalPriceId
                    this.name = newPlanMatrixPrice.name
                    this.billableMetricId = newPlanMatrixPrice.billableMetricId
                    this.itemId = newPlanMatrixPrice.itemId
                    this.billedInAdvance = newPlanMatrixPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanMatrixPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanMatrixPrice.invoiceGroupingKey
                    this.cadence = newPlanMatrixPrice.cadence
                    this.conversionRate = newPlanMatrixPrice.conversionRate
                    this.modelType = newPlanMatrixPrice.modelType
                    this.matrixConfig = newPlanMatrixPrice.matrixConfig
                    this.currency = newPlanMatrixPrice.currency
                    additionalProperties(newPlanMatrixPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun matrixConfig(matrixConfig: MatrixConfig) =
                    matrixConfig(JsonField.of(matrixConfig))

                @JsonProperty("matrix_config")
                @ExcludeMissing
                fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                    this.matrixConfig = matrixConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanMatrixPrice =
                    NewPlanMatrixPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        matrixConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = MatrixConfig.Builder::class)
            @NoAutoDetect
            class MatrixConfig
            private constructor(
                private val dimensions: JsonField<List<String?>>,
                private val defaultUnitAmount: JsonField<String>,
                private val matrixValues: JsonField<List<MatrixValue>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(): String =
                    defaultUnitAmount.getRequired("default_unit_amount")

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

                /** One or two event property values to evaluate matrix groups by */
                @JsonProperty("dimensions") @ExcludeMissing fun _dimensions() = dimensions

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                @JsonProperty("default_unit_amount")
                @ExcludeMissing
                fun _defaultUnitAmount() = defaultUnitAmount

                /** Matrix values for specified matrix grouping keys */
                @JsonProperty("matrix_values") @ExcludeMissing fun _matrixValues() = matrixValues

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): MatrixConfig = apply {
                    if (!validated) {
                        dimensions()
                        defaultUnitAmount()
                        matrixValues().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MatrixConfig &&
                        this.dimensions == other.dimensions &&
                        this.defaultUnitAmount == other.defaultUnitAmount &&
                        this.matrixValues == other.matrixValues &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                dimensions,
                                defaultUnitAmount,
                                matrixValues,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "MatrixConfig{dimensions=$dimensions, defaultUnitAmount=$defaultUnitAmount, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var dimensions: JsonField<List<String?>> = JsonMissing.of()
                    private var defaultUnitAmount: JsonField<String> = JsonMissing.of()
                    private var matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixConfig: MatrixConfig) = apply {
                        this.dimensions = matrixConfig.dimensions
                        this.defaultUnitAmount = matrixConfig.defaultUnitAmount
                        this.matrixValues = matrixConfig.matrixValues
                        additionalProperties(matrixConfig.additionalProperties)
                    }

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                    /** One or two event property values to evaluate matrix groups by */
                    @JsonProperty("dimensions")
                    @ExcludeMissing
                    fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                        this.dimensions = dimensions
                    }

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(defaultUnitAmount: String) =
                        defaultUnitAmount(JsonField.of(defaultUnitAmount))

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    @JsonProperty("default_unit_amount")
                    @ExcludeMissing
                    fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                        this.defaultUnitAmount = defaultUnitAmount
                    }

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(matrixValues: List<MatrixValue>) =
                        matrixValues(JsonField.of(matrixValues))

                    /** Matrix values for specified matrix grouping keys */
                    @JsonProperty("matrix_values")
                    @ExcludeMissing
                    fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                        this.matrixValues = matrixValues
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): MatrixConfig =
                        MatrixConfig(
                            dimensions.map { it.toUnmodifiable() },
                            defaultUnitAmount,
                            matrixValues.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable(),
                        )
                }

                @JsonDeserialize(builder = MatrixValue.Builder::class)
                @NoAutoDetect
                class MatrixValue
                private constructor(
                    private val unitAmount: JsonField<String>,
                    private val dimensionValues: JsonField<List<String?>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(): List<String?> =
                        dimensionValues.getRequired("dimension_values")

                    /** Unit price for the specified dimension_values */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    @JsonProperty("dimension_values")
                    @ExcludeMissing
                    fun _dimensionValues() = dimensionValues

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): MatrixValue = apply {
                        if (!validated) {
                            unitAmount()
                            dimensionValues()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MatrixValue &&
                            this.unitAmount == other.unitAmount &&
                            this.dimensionValues == other.dimensionValues &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    unitAmount,
                                    dimensionValues,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "MatrixValue{unitAmount=$unitAmount, dimensionValues=$dimensionValues, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var dimensionValues: JsonField<List<String?>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixValue: MatrixValue) = apply {
                            this.unitAmount = matrixValue.unitAmount
                            this.dimensionValues = matrixValue.dimensionValues
                            additionalProperties(matrixValue.additionalProperties)
                        }

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Unit price for the specified dimension_values */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(dimensionValues: List<String?>) =
                            dimensionValues(JsonField.of(dimensionValues))

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        @JsonProperty("dimension_values")
                        @ExcludeMissing
                        fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                            this.dimensionValues = dimensionValues
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): MatrixValue =
                            MatrixValue(
                                unitAmount,
                                dimensionValues.map { it.toUnmodifiable() },
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val MATRIX = ModelType(JsonField.of("matrix"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX,
                }

                enum class Value {
                    MATRIX,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX -> Value.MATRIX
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX -> Known.MATRIX
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }
        }

        @JsonDeserialize(builder = NewPlanTieredPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredConfig: JsonField<TieredConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_config") @ExcludeMissing fun _tieredConfig() = tieredConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    tieredConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanTieredPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.tieredConfig == other.tieredConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            tieredConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, tieredConfig=$tieredConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredConfig: JsonField<TieredConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPrice: NewPlanTieredPrice) = apply {
                    this.externalPriceId = newPlanTieredPrice.externalPriceId
                    this.name = newPlanTieredPrice.name
                    this.billableMetricId = newPlanTieredPrice.billableMetricId
                    this.itemId = newPlanTieredPrice.itemId
                    this.billedInAdvance = newPlanTieredPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredPrice.invoiceGroupingKey
                    this.cadence = newPlanTieredPrice.cadence
                    this.conversionRate = newPlanTieredPrice.conversionRate
                    this.modelType = newPlanTieredPrice.modelType
                    this.tieredConfig = newPlanTieredPrice.tieredConfig
                    this.currency = newPlanTieredPrice.currency
                    additionalProperties(newPlanTieredPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredConfig(tieredConfig: TieredConfig) =
                    tieredConfig(JsonField.of(tieredConfig))

                @JsonProperty("tiered_config")
                @ExcludeMissing
                fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                    this.tieredConfig = tieredConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredPrice =
                    NewPlanTieredPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        tieredConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED = ModelType(JsonField.of("tiered"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED,
                }

                enum class Value {
                    TIERED,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED -> Value.TIERED
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED -> Known.TIERED
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredConfig.Builder::class)
            @NoAutoDetect
            class TieredConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Tiers for rating based on total usage quantities into the specified tier */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredConfig: TieredConfig) = apply {
                        this.tiers = tieredConfig.tiers
                        additionalProperties(tieredConfig.additionalProperties)
                    }

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredConfig =
                        TieredConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val firstUnit: JsonField<Double>,
                    private val lastUnit: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Inclusive tier starting value */
                    fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(): Optional<Double> =
                        Optional.ofNullable(lastUnit.getNullable("last_unit"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Inclusive tier starting value */
                    @JsonProperty("first_unit") @ExcludeMissing fun _firstUnit() = firstUnit

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    @JsonProperty("last_unit") @ExcludeMissing fun _lastUnit() = lastUnit

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            firstUnit()
                            lastUnit()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.firstUnit == other.firstUnit &&
                            this.lastUnit == other.lastUnit &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    firstUnit,
                                    lastUnit,
                                    unitAmount,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{firstUnit=$firstUnit, lastUnit=$lastUnit, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var firstUnit: JsonField<Double> = JsonMissing.of()
                        private var lastUnit: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.firstUnit = tier.firstUnit
                            this.lastUnit = tier.lastUnit
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                        /** Inclusive tier starting value */
                        @JsonProperty("first_unit")
                        @ExcludeMissing
                        fun firstUnit(firstUnit: JsonField<Double>) = apply {
                            this.firstUnit = firstUnit
                        }

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(lastUnit: Double) = lastUnit(JsonField.of(lastUnit))

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @JsonProperty("last_unit")
                        @ExcludeMissing
                        fun lastUnit(lastUnit: JsonField<Double>) = apply {
                            this.lastUnit = lastUnit
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                firstUnit,
                                lastUnit,
                                unitAmount,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }
        }

        @JsonDeserialize(builder = NewPlanTieredBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredBpsPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredBpsConfig: JsonField<TieredBpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredBpsConfig(): TieredBpsConfig =
                tieredBpsConfig.getRequired("tiered_bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_bps_config")
            @ExcludeMissing
            fun _tieredBpsConfig() = tieredBpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredBpsPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    tieredBpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanTieredBpsPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.tieredBpsConfig == other.tieredBpsConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            tieredBpsConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredBpsPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, tieredBpsConfig=$tieredBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) = apply {
                    this.externalPriceId = newPlanTieredBpsPrice.externalPriceId
                    this.name = newPlanTieredBpsPrice.name
                    this.billableMetricId = newPlanTieredBpsPrice.billableMetricId
                    this.itemId = newPlanTieredBpsPrice.itemId
                    this.billedInAdvance = newPlanTieredBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanTieredBpsPrice.cadence
                    this.conversionRate = newPlanTieredBpsPrice.conversionRate
                    this.modelType = newPlanTieredBpsPrice.modelType
                    this.tieredBpsConfig = newPlanTieredBpsPrice.tieredBpsConfig
                    this.currency = newPlanTieredBpsPrice.currency
                    additionalProperties(newPlanTieredBpsPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                    tieredBpsConfig(JsonField.of(tieredBpsConfig))

                @JsonProperty("tiered_bps_config")
                @ExcludeMissing
                fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                    this.tieredBpsConfig = tieredBpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredBpsPrice =
                    NewPlanTieredBpsPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        tieredBpsConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_BPS = ModelType(JsonField.of("tiered_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_BPS,
                }

                enum class Value {
                    TIERED_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_BPS -> Value.TIERED_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_BPS -> Known.TIERED_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredBpsConfig.Builder::class)
            @NoAutoDetect
            class TieredBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredBpsConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                        this.tiers = tieredBpsConfig.tiers
                        additionalProperties(tieredBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredBpsConfig =
                        TieredBpsConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val minimumAmount: JsonField<String>,
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Inclusive tier starting value */
                    fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                    /** Exclusive tier ending value */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Per-event basis point rate */
                    fun bps(): Double = bps.getRequired("bps")

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Inclusive tier starting value */
                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    fun _minimumAmount() = minimumAmount

                    /** Exclusive tier ending value */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Per-event basis point rate */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** Per unit maximum to charge */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            minimumAmount()
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.minimumAmount == other.minimumAmount &&
                            this.maximumAmount == other.maximumAmount &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    minimumAmount,
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var minimumAmount: JsonField<String> = JsonMissing.of()
                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.minimumAmount = tier.minimumAmount
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun minimumAmount(minimumAmount: String) =
                            minimumAmount(JsonField.of(minimumAmount))

                        /** Inclusive tier starting value */
                        @JsonProperty("minimum_amount")
                        @ExcludeMissing
                        fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                            this.minimumAmount = minimumAmount
                        }

                        /** Exclusive tier ending value */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Exclusive tier ending value */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Per-event basis point rate */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Per-event basis point rate */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** Per unit maximum to charge */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                minimumAmount,
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }
        }

        @JsonDeserialize(builder = NewPlanBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBpsPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bpsConfig: JsonField<BpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bps_config") @ExcludeMissing fun _bpsConfig() = bpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBpsPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    bpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanBpsPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.bpsConfig == other.bpsConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            bpsConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBpsPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, bpsConfig=$bpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bpsConfig: JsonField<BpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBpsPrice: NewPlanBpsPrice) = apply {
                    this.externalPriceId = newPlanBpsPrice.externalPriceId
                    this.name = newPlanBpsPrice.name
                    this.billableMetricId = newPlanBpsPrice.billableMetricId
                    this.itemId = newPlanBpsPrice.itemId
                    this.billedInAdvance = newPlanBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanBpsPrice.cadence
                    this.conversionRate = newPlanBpsPrice.conversionRate
                    this.modelType = newPlanBpsPrice.modelType
                    this.bpsConfig = newPlanBpsPrice.bpsConfig
                    this.currency = newPlanBpsPrice.currency
                    additionalProperties(newPlanBpsPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

                @JsonProperty("bps_config")
                @ExcludeMissing
                fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply {
                    this.bpsConfig = bpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBpsPrice =
                    NewPlanBpsPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        bpsConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BpsConfig.Builder::class)
            @NoAutoDetect
            class BpsConfig
            private constructor(
                private val bps: JsonField<Double>,
                private val perUnitMaximum: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Basis point take rate per event */
                fun bps(): Double = bps.getRequired("bps")

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /** Basis point take rate per event */
                @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                /** Optional currency amount maximum to cap spend per event */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum() = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BpsConfig = apply {
                    if (!validated) {
                        bps()
                        perUnitMaximum()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BpsConfig &&
                        this.bps == other.bps &&
                        this.perUnitMaximum == other.perUnitMaximum &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode =
                            Objects.hash(
                                bps,
                                perUnitMaximum,
                                additionalProperties,
                            )
                    }
                    return hashCode
                }

                override fun toString() =
                    "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: JsonField<Double> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bpsConfig: BpsConfig) = apply {
                        this.bps = bpsConfig.bps
                        this.perUnitMaximum = bpsConfig.perUnitMaximum
                        additionalProperties(bpsConfig.additionalProperties)
                    }

                    /** Basis point take rate per event */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /** Basis point take rate per event */
                    @JsonProperty("bps")
                    @ExcludeMissing
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(perUnitMaximum: String) =
                        perUnitMaximum(JsonField.of(perUnitMaximum))

                    /** Optional currency amount maximum to cap spend per event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BpsConfig =
                        BpsConfig(
                            bps,
                            perUnitMaximum,
                            additionalProperties.toUnmodifiable(),
                        )
                }
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BPS = ModelType(JsonField.of("bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BPS,
                }

                enum class Value {
                    BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BPS -> Value.BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BPS -> Known.BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }
        }

        @JsonDeserialize(builder = NewPlanBulkBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBulkBpsPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bulkBpsConfig: JsonField<BulkBpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bulk_bps_config") @ExcludeMissing fun _bulkBpsConfig() = bulkBpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBulkBpsPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    bulkBpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanBulkBpsPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.bulkBpsConfig == other.bulkBpsConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            bulkBpsConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBulkBpsPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, bulkBpsConfig=$bulkBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) = apply {
                    this.externalPriceId = newPlanBulkBpsPrice.externalPriceId
                    this.name = newPlanBulkBpsPrice.name
                    this.billableMetricId = newPlanBulkBpsPrice.billableMetricId
                    this.itemId = newPlanBulkBpsPrice.itemId
                    this.billedInAdvance = newPlanBulkBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBulkBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBulkBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanBulkBpsPrice.cadence
                    this.conversionRate = newPlanBulkBpsPrice.conversionRate
                    this.modelType = newPlanBulkBpsPrice.modelType
                    this.bulkBpsConfig = newPlanBulkBpsPrice.bulkBpsConfig
                    this.currency = newPlanBulkBpsPrice.currency
                    additionalProperties(newPlanBulkBpsPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                    bulkBpsConfig(JsonField.of(bulkBpsConfig))

                @JsonProperty("bulk_bps_config")
                @ExcludeMissing
                fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                    this.bulkBpsConfig = bulkBpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBulkBpsPrice =
                    NewPlanBulkBpsPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        bulkBpsConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BulkBpsConfig.Builder::class)
            @NoAutoDetect
            class BulkBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BulkBpsConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                        this.tiers = bulkBpsConfig.tiers
                        additionalProperties(bulkBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkBpsConfig =
                        BulkBpsConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Upper bound for tier */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Basis points to rate on */
                    fun bps(): Double = bps.getRequired("bps")

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Upper bound for tier */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Basis points to rate on */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** The maximum amount to charge for any one event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.maximumAmount == other.maximumAmount &&
                            this.bps == other.bps &&
                            this.perUnitMaximum == other.perUnitMaximum &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    maximumAmount,
                                    bps,
                                    perUnitMaximum,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for tier */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Upper bound for tier */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Basis points to rate on */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Basis points to rate on */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** The maximum amount to charge for any one event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK_BPS = ModelType(JsonField.of("bulk_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_BPS,
                }

                enum class Value {
                    BULK_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_BPS -> Value.BULK_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_BPS -> Known.BULK_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }
        }

        @JsonDeserialize(builder = NewPlanBulkPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBulkPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bulkConfig: JsonField<BulkConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bulk_config") @ExcludeMissing fun _bulkConfig() = bulkConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBulkPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    bulkConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanBulkPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.bulkConfig == other.bulkConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            bulkConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBulkPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, bulkConfig=$bulkConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bulkConfig: JsonField<BulkConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkPrice: NewPlanBulkPrice) = apply {
                    this.externalPriceId = newPlanBulkPrice.externalPriceId
                    this.name = newPlanBulkPrice.name
                    this.billableMetricId = newPlanBulkPrice.billableMetricId
                    this.itemId = newPlanBulkPrice.itemId
                    this.billedInAdvance = newPlanBulkPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBulkPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBulkPrice.invoiceGroupingKey
                    this.cadence = newPlanBulkPrice.cadence
                    this.conversionRate = newPlanBulkPrice.conversionRate
                    this.modelType = newPlanBulkPrice.modelType
                    this.bulkConfig = newPlanBulkPrice.bulkConfig
                    this.currency = newPlanBulkPrice.currency
                    additionalProperties(newPlanBulkPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

                @JsonProperty("bulk_config")
                @ExcludeMissing
                fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                    this.bulkConfig = bulkConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBulkPrice =
                    NewPlanBulkPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        bulkConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            @JsonDeserialize(builder = BulkConfig.Builder::class)
            @NoAutoDetect
            class BulkConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Bulk tiers for rating based on total usage volume */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is BulkConfig &&
                        this.tiers == other.tiers &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(tiers, additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkConfig: BulkConfig) = apply {
                        this.tiers = bulkConfig.tiers
                        additionalProperties(bulkConfig.additionalProperties)
                    }

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Bulk tiers for rating based on total usage volume */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkConfig =
                        BulkConfig(
                            tiers.map { it.toUnmodifiable() },
                            additionalProperties.toUnmodifiable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumUnits: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    private var hashCode: Int = 0

                    /** Upper bound for this tier */
                    fun maximumUnits(): Optional<Double> =
                        Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Upper bound for this tier */
                    @JsonProperty("maximum_units")
                    @ExcludeMissing
                    fun _maximumUnits() = maximumUnits

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumUnits()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Tier &&
                            this.maximumUnits == other.maximumUnits &&
                            this.unitAmount == other.unitAmount &&
                            this.additionalProperties == other.additionalProperties
                    }

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode =
                                Objects.hash(
                                    maximumUnits,
                                    unitAmount,
                                    additionalProperties,
                                )
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumUnits=$maximumUnits, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumUnits: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumUnits = tier.maximumUnits
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for this tier */
                        fun maximumUnits(maximumUnits: Double) =
                            maximumUnits(JsonField.of(maximumUnits))

                        /** Upper bound for this tier */
                        @JsonProperty("maximum_units")
                        @ExcludeMissing
                        fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                            this.maximumUnits = maximumUnits
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumUnits,
                                unitAmount,
                                additionalProperties.toUnmodifiable(),
                            )
                    }
                }
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK = ModelType(JsonField.of("bulk"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK,
                }

                enum class Value {
                    BULK,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK -> Value.BULK
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK -> Known.BULK
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }
        }

        @JsonDeserialize(builder = NewPlanThresholdTotalAmountPrice.Builder::class)
        @NoAutoDetect
        class NewPlanThresholdTotalAmountPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("threshold_total_amount_config")
            @ExcludeMissing
            fun _thresholdTotalAmountConfig() = thresholdTotalAmountConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanThresholdTotalAmountPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    thresholdTotalAmountConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanThresholdTotalAmountPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.thresholdTotalAmountConfig == other.thresholdTotalAmountConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            thresholdTotalAmountConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanThresholdTotalAmountPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
                ) = apply {
                    this.externalPriceId = newPlanThresholdTotalAmountPrice.externalPriceId
                    this.name = newPlanThresholdTotalAmountPrice.name
                    this.billableMetricId = newPlanThresholdTotalAmountPrice.billableMetricId
                    this.itemId = newPlanThresholdTotalAmountPrice.itemId
                    this.billedInAdvance = newPlanThresholdTotalAmountPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanThresholdTotalAmountPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanThresholdTotalAmountPrice.invoiceGroupingKey
                    this.cadence = newPlanThresholdTotalAmountPrice.cadence
                    this.conversionRate = newPlanThresholdTotalAmountPrice.conversionRate
                    this.modelType = newPlanThresholdTotalAmountPrice.modelType
                    this.thresholdTotalAmountConfig =
                        newPlanThresholdTotalAmountPrice.thresholdTotalAmountConfig
                    this.currency = newPlanThresholdTotalAmountPrice.currency
                    additionalProperties(newPlanThresholdTotalAmountPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

                @JsonProperty("threshold_total_amount_config")
                @ExcludeMissing
                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
                ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanThresholdTotalAmountPrice =
                    NewPlanThresholdTotalAmountPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        thresholdTotalAmountConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val THRESHOLD_TOTAL_AMOUNT = ModelType(JsonField.of("threshold_total_amount"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    THRESHOLD_TOTAL_AMOUNT,
                }

                enum class Value {
                    THRESHOLD_TOTAL_AMOUNT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = ThresholdTotalAmountConfig.Builder::class)
            @NoAutoDetect
            class ThresholdTotalAmountConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): ThresholdTotalAmountConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ThresholdTotalAmountConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                        apply {
                            additionalProperties(thresholdTotalAmountConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): ThresholdTotalAmountConfig =
                        ThresholdTotalAmountConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanTieredPackagePrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredPackagePrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredPackageConfig: JsonField<TieredPackageConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredPackageConfig(): TieredPackageConfig =
                tieredPackageConfig.getRequired("tiered_package_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_package_config")
            @ExcludeMissing
            fun _tieredPackageConfig() = tieredPackageConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredPackagePrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    tieredPackageConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanTieredPackagePrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.tieredPackageConfig == other.tieredPackageConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            tieredPackageConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredPackagePrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, tieredPackageConfig=$tieredPackageConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) = apply {
                    this.externalPriceId = newPlanTieredPackagePrice.externalPriceId
                    this.name = newPlanTieredPackagePrice.name
                    this.billableMetricId = newPlanTieredPackagePrice.billableMetricId
                    this.itemId = newPlanTieredPackagePrice.itemId
                    this.billedInAdvance = newPlanTieredPackagePrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredPackagePrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredPackagePrice.invoiceGroupingKey
                    this.cadence = newPlanTieredPackagePrice.cadence
                    this.conversionRate = newPlanTieredPackagePrice.conversionRate
                    this.modelType = newPlanTieredPackagePrice.modelType
                    this.tieredPackageConfig = newPlanTieredPackagePrice.tieredPackageConfig
                    this.currency = newPlanTieredPackagePrice.currency
                    additionalProperties(newPlanTieredPackagePrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                    tieredPackageConfig(JsonField.of(tieredPackageConfig))

                @JsonProperty("tiered_package_config")
                @ExcludeMissing
                fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) =
                    apply {
                        this.tieredPackageConfig = tieredPackageConfig
                    }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredPackagePrice =
                    NewPlanTieredPackagePrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        tieredPackageConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_PACKAGE = ModelType(JsonField.of("tiered_package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_PACKAGE,
                }

                enum class Value {
                    TIERED_PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_PACKAGE -> Value.TIERED_PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_PACKAGE -> Known.TIERED_PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredPackageConfig.Builder::class)
            @NoAutoDetect
            class TieredPackageConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredPackageConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredPackageConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredPackageConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                        additionalProperties(tieredPackageConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredPackageConfig =
                        TieredPackageConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanTieredWithMinimumPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredWithMinimumPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
                tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_with_minimum_config")
            @ExcludeMissing
            fun _tieredWithMinimumConfig() = tieredWithMinimumConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredWithMinimumPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    tieredWithMinimumConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanTieredWithMinimumPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.tieredWithMinimumConfig == other.tieredWithMinimumConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            tieredWithMinimumConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredWithMinimumPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, tieredWithMinimumConfig=$tieredWithMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice) =
                    apply {
                        this.externalPriceId = newPlanTieredWithMinimumPrice.externalPriceId
                        this.name = newPlanTieredWithMinimumPrice.name
                        this.billableMetricId = newPlanTieredWithMinimumPrice.billableMetricId
                        this.itemId = newPlanTieredWithMinimumPrice.itemId
                        this.billedInAdvance = newPlanTieredWithMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanTieredWithMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanTieredWithMinimumPrice.invoiceGroupingKey
                        this.cadence = newPlanTieredWithMinimumPrice.cadence
                        this.conversionRate = newPlanTieredWithMinimumPrice.conversionRate
                        this.modelType = newPlanTieredWithMinimumPrice.modelType
                        this.tieredWithMinimumConfig =
                            newPlanTieredWithMinimumPrice.tieredWithMinimumConfig
                        this.currency = newPlanTieredWithMinimumPrice.currency
                        additionalProperties(newPlanTieredWithMinimumPrice.additionalProperties)
                    }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                    tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

                @JsonProperty("tiered_with_minimum_config")
                @ExcludeMissing
                fun tieredWithMinimumConfig(
                    tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
                ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredWithMinimumPrice =
                    NewPlanTieredWithMinimumPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        tieredWithMinimumConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_MINIMUM = ModelType(JsonField.of("tiered_with_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_MINIMUM,
                }

                enum class Value {
                    TIERED_WITH_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithMinimumConfig.Builder::class)
            @NoAutoDetect
            class TieredWithMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredWithMinimumConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                        additionalProperties(tieredWithMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithMinimumConfig =
                        TieredWithMinimumConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanUnitWithPercentPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitWithPercentPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitWithPercentConfig(): UnitWithPercentConfig =
                unitWithPercentConfig.getRequired("unit_with_percent_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_with_percent_config")
            @ExcludeMissing
            fun _unitWithPercentConfig() = unitWithPercentConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitWithPercentPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    unitWithPercentConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanUnitWithPercentPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.unitWithPercentConfig == other.unitWithPercentConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            unitWithPercentConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitWithPercentPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, unitWithPercentConfig=$unitWithPercentConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitWithPercentConfig: JsonField<UnitWithPercentConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice) =
                    apply {
                        this.externalPriceId = newPlanUnitWithPercentPrice.externalPriceId
                        this.name = newPlanUnitWithPercentPrice.name
                        this.billableMetricId = newPlanUnitWithPercentPrice.billableMetricId
                        this.itemId = newPlanUnitWithPercentPrice.itemId
                        this.billedInAdvance = newPlanUnitWithPercentPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanUnitWithPercentPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanUnitWithPercentPrice.invoiceGroupingKey
                        this.cadence = newPlanUnitWithPercentPrice.cadence
                        this.conversionRate = newPlanUnitWithPercentPrice.conversionRate
                        this.modelType = newPlanUnitWithPercentPrice.modelType
                        this.unitWithPercentConfig =
                            newPlanUnitWithPercentPrice.unitWithPercentConfig
                        this.currency = newPlanUnitWithPercentPrice.currency
                        additionalProperties(newPlanUnitWithPercentPrice.additionalProperties)
                    }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                    unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

                @JsonProperty("unit_with_percent_config")
                @ExcludeMissing
                fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                    apply {
                        this.unitWithPercentConfig = unitWithPercentConfig
                    }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitWithPercentPrice =
                    NewPlanUnitWithPercentPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        unitWithPercentConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT_WITH_PERCENT = ModelType(JsonField.of("unit_with_percent"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PERCENT,
                }

                enum class Value {
                    UNIT_WITH_PERCENT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithPercentConfig.Builder::class)
            @NoAutoDetect
            class UnitWithPercentConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithPercentConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitWithPercentConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithPercentConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                        additionalProperties(unitWithPercentConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithPercentConfig =
                        UnitWithPercentConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanPackageWithAllocationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanPackageWithAllocationPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                packageWithAllocationConfig.getRequired("package_with_allocation_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("package_with_allocation_config")
            @ExcludeMissing
            fun _packageWithAllocationConfig() = packageWithAllocationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanPackageWithAllocationPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    packageWithAllocationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanPackageWithAllocationPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.packageWithAllocationConfig == other.packageWithAllocationConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            packageWithAllocationConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanPackageWithAllocationPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, packageWithAllocationConfig=$packageWithAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
                ) = apply {
                    this.externalPriceId = newPlanPackageWithAllocationPrice.externalPriceId
                    this.name = newPlanPackageWithAllocationPrice.name
                    this.billableMetricId = newPlanPackageWithAllocationPrice.billableMetricId
                    this.itemId = newPlanPackageWithAllocationPrice.itemId
                    this.billedInAdvance = newPlanPackageWithAllocationPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanPackageWithAllocationPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanPackageWithAllocationPrice.invoiceGroupingKey
                    this.cadence = newPlanPackageWithAllocationPrice.cadence
                    this.conversionRate = newPlanPackageWithAllocationPrice.conversionRate
                    this.modelType = newPlanPackageWithAllocationPrice.modelType
                    this.packageWithAllocationConfig =
                        newPlanPackageWithAllocationPrice.packageWithAllocationConfig
                    this.currency = newPlanPackageWithAllocationPrice.currency
                    additionalProperties(newPlanPackageWithAllocationPrice.additionalProperties)
                }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: PackageWithAllocationConfig
                ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

                @JsonProperty("package_with_allocation_config")
                @ExcludeMissing
                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
                ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanPackageWithAllocationPrice =
                    NewPlanPackageWithAllocationPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        packageWithAllocationConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val PACKAGE_WITH_ALLOCATION = ModelType(JsonField.of("package_with_allocation"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE_WITH_ALLOCATION,
                }

                enum class Value {
                    PACKAGE_WITH_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageWithAllocationConfig.Builder::class)
            @NoAutoDetect
            class PackageWithAllocationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageWithAllocationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PackageWithAllocationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                        apply {
                            additionalProperties(packageWithAllocationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageWithAllocationConfig =
                        PackageWithAllocationConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanTierWithProrationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTierWithProrationPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredWithProrationConfig(): TieredWithProrationConfig =
                tieredWithProrationConfig.getRequired("tiered_with_proration_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_with_proration_config")
            @ExcludeMissing
            fun _tieredWithProrationConfig() = tieredWithProrationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTierWithProrationPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    tieredWithProrationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanTierWithProrationPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.tieredWithProrationConfig == other.tieredWithProrationConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            tieredWithProrationConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTierWithProrationPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, tieredWithProrationConfig=$tieredWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice) =
                    apply {
                        this.externalPriceId = newPlanTierWithProrationPrice.externalPriceId
                        this.name = newPlanTierWithProrationPrice.name
                        this.billableMetricId = newPlanTierWithProrationPrice.billableMetricId
                        this.itemId = newPlanTierWithProrationPrice.itemId
                        this.billedInAdvance = newPlanTierWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanTierWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanTierWithProrationPrice.invoiceGroupingKey
                        this.cadence = newPlanTierWithProrationPrice.cadence
                        this.conversionRate = newPlanTierWithProrationPrice.conversionRate
                        this.modelType = newPlanTierWithProrationPrice.modelType
                        this.tieredWithProrationConfig =
                            newPlanTierWithProrationPrice.tieredWithProrationConfig
                        this.currency = newPlanTierWithProrationPrice.currency
                        additionalProperties(newPlanTierWithProrationPrice.additionalProperties)
                    }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: TieredWithProrationConfig
                ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

                @JsonProperty("tiered_with_proration_config")
                @ExcludeMissing
                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
                ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTierWithProrationPrice =
                    NewPlanTierWithProrationPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        tieredWithProrationConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_PRORATION = ModelType(JsonField.of("tiered_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_PRORATION,
                }

                enum class Value {
                    TIERED_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithProrationConfig.Builder::class)
            @NoAutoDetect
            class TieredWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is TieredWithProrationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithProrationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                        apply {
                            additionalProperties(tieredWithProrationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithProrationConfig =
                        TieredWithProrationConfig(additionalProperties.toUnmodifiable())
                }
            }
        }

        @JsonDeserialize(builder = NewPlanUnitWithProrationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitWithProrationPrice
        private constructor(
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            private var hashCode: Int = 0

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitWithProrationConfig(): UnitWithProrationConfig =
                unitWithProrationConfig.getRequired("unit_with_proration_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_with_proration_config")
            @ExcludeMissing
            fun _unitWithProrationConfig() = unitWithProrationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitWithProrationPrice = apply {
                if (!validated) {
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    conversionRate()
                    modelType()
                    unitWithProrationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NewPlanUnitWithProrationPrice &&
                    this.externalPriceId == other.externalPriceId &&
                    this.name == other.name &&
                    this.billableMetricId == other.billableMetricId &&
                    this.itemId == other.itemId &&
                    this.billedInAdvance == other.billedInAdvance &&
                    this.fixedPriceQuantity == other.fixedPriceQuantity &&
                    this.invoiceGroupingKey == other.invoiceGroupingKey &&
                    this.cadence == other.cadence &&
                    this.conversionRate == other.conversionRate &&
                    this.modelType == other.modelType &&
                    this.unitWithProrationConfig == other.unitWithProrationConfig &&
                    this.currency == other.currency &&
                    this.additionalProperties == other.additionalProperties
            }

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode =
                        Objects.hash(
                            externalPriceId,
                            name,
                            billableMetricId,
                            itemId,
                            billedInAdvance,
                            fixedPriceQuantity,
                            invoiceGroupingKey,
                            cadence,
                            conversionRate,
                            modelType,
                            unitWithProrationConfig,
                            currency,
                            additionalProperties,
                        )
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitWithProrationPrice{externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, conversionRate=$conversionRate, modelType=$modelType, unitWithProrationConfig=$unitWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitWithProrationConfig: JsonField<UnitWithProrationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice) =
                    apply {
                        this.externalPriceId = newPlanUnitWithProrationPrice.externalPriceId
                        this.name = newPlanUnitWithProrationPrice.name
                        this.billableMetricId = newPlanUnitWithProrationPrice.billableMetricId
                        this.itemId = newPlanUnitWithProrationPrice.itemId
                        this.billedInAdvance = newPlanUnitWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanUnitWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanUnitWithProrationPrice.invoiceGroupingKey
                        this.cadence = newPlanUnitWithProrationPrice.cadence
                        this.conversionRate = newPlanUnitWithProrationPrice.conversionRate
                        this.modelType = newPlanUnitWithProrationPrice.modelType
                        this.unitWithProrationConfig =
                            newPlanUnitWithProrationPrice.unitWithProrationConfig
                        this.currency = newPlanUnitWithProrationPrice.currency
                        additionalProperties(newPlanUnitWithProrationPrice.additionalProperties)
                    }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                    unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

                @JsonProperty("unit_with_proration_config")
                @ExcludeMissing
                fun unitWithProrationConfig(
                    unitWithProrationConfig: JsonField<UnitWithProrationConfig>
                ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitWithProrationPrice =
                    NewPlanUnitWithProrationPrice(
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        conversionRate,
                        modelType,
                        unitWithProrationConfig,
                        currency,
                        additionalProperties.toUnmodifiable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cadence && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ModelType && this.value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val UNIT_WITH_PRORATION = ModelType(JsonField.of("unit_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PRORATION,
                }

                enum class Value {
                    UNIT_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithProrationConfig.Builder::class)
            @NoAutoDetect
            class UnitWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                private var hashCode: Int = 0

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitWithProrationConfig &&
                        this.additionalProperties == other.additionalProperties
                }

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = Objects.hash(additionalProperties)
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithProrationConfig{additionalProperties=$additionalProperties}"

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                        additionalProperties(unitWithProrationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithProrationConfig =
                        UnitWithProrationConfig(additionalProperties.toUnmodifiable())
                }
            }
        }
    }

    /**
     * User-specified key/value pairs for the resource. Individual keys can be removed by setting
     * the value to `null`, and the entire metadata mapping can be cleared by setting `metadata` to
     * `null`.
     */
    @JsonDeserialize(builder = Metadata.Builder::class)
    @NoAutoDetect
    class Metadata
    private constructor(
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var hashCode: Int = 0

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Metadata && this.additionalProperties == other.additionalProperties
        }

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode = Objects.hash(additionalProperties)
            }
            return hashCode
        }

        override fun toString() = "Metadata{additionalProperties=$additionalProperties}"

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(metadata: Metadata) = apply {
                additionalProperties(metadata.additionalProperties)
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): Metadata = Metadata(additionalProperties.toUnmodifiable())
        }
    }

    class Status
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Status && this.value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            @JvmField val ACTIVE = Status(JsonField.of("active"))

            @JvmField val DRAFT = Status(JsonField.of("draft"))

            @JvmStatic fun of(value: String) = Status(JsonField.of(value))
        }

        enum class Known {
            ACTIVE,
            DRAFT,
        }

        enum class Value {
            ACTIVE,
            DRAFT,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                ACTIVE -> Value.ACTIVE
                DRAFT -> Value.DRAFT
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                ACTIVE -> Known.ACTIVE
                DRAFT -> Known.DRAFT
                else -> throw OrbInvalidDataException("Unknown Status: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }
}
