// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.google.common.collect.ArrayListMultimap
import com.google.common.collect.ListMultimap
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import com.withorb.api.models.*
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

class PlanCreateParams
constructor(
    private val currency: String,
    private val name: String,
    private val prices: List<Price>,
    private val defaultInvoiceMemo: String?,
    private val externalPlanId: String?,
    private val metadata: Metadata?,
    private val netTerms: Long?,
    private val status: Status?,
    private val additionalHeaders: Map<String, List<String>>,
    private val additionalQueryParams: Map<String, List<String>>,
    private val additionalBodyProperties: Map<String, JsonValue>,
) {

    fun currency(): String = currency

    fun name(): String = name

    fun prices(): List<Price> = prices

    fun defaultInvoiceMemo(): Optional<String> = Optional.ofNullable(defaultInvoiceMemo)

    fun externalPlanId(): Optional<String> = Optional.ofNullable(externalPlanId)

    fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata)

    fun netTerms(): Optional<Long> = Optional.ofNullable(netTerms)

    fun status(): Optional<Status> = Optional.ofNullable(status)

    @JvmSynthetic
    internal fun getBody(): PlanCreateBody {
        return PlanCreateBody(
            currency,
            name,
            prices,
            defaultInvoiceMemo,
            externalPlanId,
            metadata,
            netTerms,
            status,
            additionalBodyProperties,
        )
    }

    @JvmSynthetic internal fun getHeaders(): Map<String, List<String>> = additionalHeaders

    @JvmSynthetic internal fun getQueryParams(): Map<String, List<String>> = additionalQueryParams

    @JsonDeserialize(builder = PlanCreateBody.Builder::class)
    @NoAutoDetect
    class PlanCreateBody
    internal constructor(
        private val currency: String?,
        private val name: String?,
        private val prices: List<Price>?,
        private val defaultInvoiceMemo: String?,
        private val externalPlanId: String?,
        private val metadata: Metadata?,
        private val netTerms: Long?,
        private val status: Status?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        @JsonProperty("currency") fun currency(): String? = currency

        @JsonProperty("name") fun name(): String? = name

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        @JsonProperty("prices") fun prices(): List<Price>? = prices

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        @JsonProperty("default_invoice_memo") fun defaultInvoiceMemo(): String? = defaultInvoiceMemo

        @JsonProperty("external_plan_id") fun externalPlanId(): String? = externalPlanId

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") fun metadata(): Metadata? = metadata

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        @JsonProperty("net_terms") fun netTerms(): Long? = netTerms

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        @JsonProperty("status") fun status(): Status? = status

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var currency: String? = null
            private var name: String? = null
            private var prices: List<Price>? = null
            private var defaultInvoiceMemo: String? = null
            private var externalPlanId: String? = null
            private var metadata: Metadata? = null
            private var netTerms: Long? = null
            private var status: Status? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(planCreateBody: PlanCreateBody) = apply {
                this.currency = planCreateBody.currency
                this.name = planCreateBody.name
                this.prices = planCreateBody.prices
                this.defaultInvoiceMemo = planCreateBody.defaultInvoiceMemo
                this.externalPlanId = planCreateBody.externalPlanId
                this.metadata = planCreateBody.metadata
                this.netTerms = planCreateBody.netTerms
                this.status = planCreateBody.status
                additionalProperties(planCreateBody.additionalProperties)
            }

            /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
            @JsonProperty("currency")
            fun currency(currency: String) = apply { this.currency = currency }

            @JsonProperty("name") fun name(name: String) = apply { this.name = name }

            /**
             * Prices for this plan. If the plan has phases, this includes prices across all phases
             * of the plan.
             */
            @JsonProperty("prices") fun prices(prices: List<Price>) = apply { this.prices = prices }

            /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
            @JsonProperty("default_invoice_memo")
            fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
                this.defaultInvoiceMemo = defaultInvoiceMemo
            }

            @JsonProperty("external_plan_id")
            fun externalPlanId(externalPlanId: String) = apply {
                this.externalPlanId = externalPlanId
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata")
            fun metadata(metadata: Metadata) = apply { this.metadata = metadata }

            /**
             * The net terms determines the difference between the invoice date and the issue date
             * for the invoice. If you intend the invoice to be due on issue, set this to 0.
             */
            @JsonProperty("net_terms")
            fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

            /**
             * The status of the plan to create (either active or draft). If not specified, this
             * defaults to active.
             */
            @JsonProperty("status") fun status(status: Status) = apply { this.status = status }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): PlanCreateBody =
                PlanCreateBody(
                    checkNotNull(currency) { "`currency` is required but was not set" },
                    checkNotNull(name) { "`name` is required but was not set" },
                    checkNotNull(prices) { "`prices` is required but was not set" }.toImmutable(),
                    defaultInvoiceMemo,
                    externalPlanId,
                    metadata,
                    netTerms,
                    status,
                    additionalProperties.toImmutable(),
                )
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PlanCreateBody && this.currency == other.currency && this.name == other.name && this.prices == other.prices && this.defaultInvoiceMemo == other.defaultInvoiceMemo && this.externalPlanId == other.externalPlanId && this.metadata == other.metadata && this.netTerms == other.netTerms && this.status == other.status && this.additionalProperties == other.additionalProperties /* spotless:on */
        }

        private var hashCode: Int = 0

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode = /* spotless:off */ Objects.hash(currency, name, prices, defaultInvoiceMemo, externalPlanId, metadata, netTerms, status, additionalProperties) /* spotless:on */
            }
            return hashCode
        }

        override fun toString() =
            "PlanCreateBody{currency=$currency, name=$name, prices=$prices, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, metadata=$metadata, netTerms=$netTerms, status=$status, additionalProperties=$additionalProperties}"
    }

    fun _additionalHeaders(): Map<String, List<String>> = additionalHeaders

    fun _additionalQueryParams(): Map<String, List<String>> = additionalQueryParams

    fun _additionalBodyProperties(): Map<String, JsonValue> = additionalBodyProperties

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is PlanCreateParams && this.currency == other.currency && this.name == other.name && this.prices == other.prices && this.defaultInvoiceMemo == other.defaultInvoiceMemo && this.externalPlanId == other.externalPlanId && this.metadata == other.metadata && this.netTerms == other.netTerms && this.status == other.status && this.additionalHeaders == other.additionalHeaders && this.additionalQueryParams == other.additionalQueryParams && this.additionalBodyProperties == other.additionalBodyProperties /* spotless:on */
    }

    override fun hashCode(): Int {
        return /* spotless:off */ Objects.hash(currency, name, prices, defaultInvoiceMemo, externalPlanId, metadata, netTerms, status, additionalHeaders, additionalQueryParams, additionalBodyProperties) /* spotless:on */
    }

    override fun toString() =
        "PlanCreateParams{currency=$currency, name=$name, prices=$prices, defaultInvoiceMemo=$defaultInvoiceMemo, externalPlanId=$externalPlanId, metadata=$metadata, netTerms=$netTerms, status=$status, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams, additionalBodyProperties=$additionalBodyProperties}"

    fun toBuilder() = Builder().from(this)

    companion object {

        @JvmStatic fun builder() = Builder()
    }

    @NoAutoDetect
    class Builder {

        private var currency: String? = null
        private var name: String? = null
        private var prices: MutableList<Price> = mutableListOf()
        private var defaultInvoiceMemo: String? = null
        private var externalPlanId: String? = null
        private var metadata: Metadata? = null
        private var netTerms: Long? = null
        private var status: Status? = null
        private var additionalHeaders: ListMultimap<String, String> = ArrayListMultimap.create()
        private var additionalQueryParams: ListMultimap<String, String> = ArrayListMultimap.create()
        private var additionalBodyProperties: MutableMap<String, JsonValue> = mutableMapOf()

        @JvmSynthetic
        internal fun from(planCreateParams: PlanCreateParams) = apply {
            this.currency = planCreateParams.currency
            this.name = planCreateParams.name
            this.prices(planCreateParams.prices)
            this.defaultInvoiceMemo = planCreateParams.defaultInvoiceMemo
            this.externalPlanId = planCreateParams.externalPlanId
            this.metadata = planCreateParams.metadata
            this.netTerms = planCreateParams.netTerms
            this.status = planCreateParams.status
            additionalHeaders(planCreateParams.additionalHeaders)
            additionalQueryParams(planCreateParams.additionalQueryParams)
            additionalBodyProperties(planCreateParams.additionalBodyProperties)
        }

        /** An ISO 4217 currency string for invoices generated by subscriptions on this plan. */
        fun currency(currency: String) = apply { this.currency = currency }

        fun name(name: String) = apply { this.name = name }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun prices(prices: List<Price>) = apply {
            this.prices.clear()
            this.prices.addAll(prices)
        }

        /**
         * Prices for this plan. If the plan has phases, this includes prices across all phases of
         * the plan.
         */
        fun addPrice(price: Price) = apply { this.prices.add(price) }

        /** Free-form text which is available on the invoice PDF and the Orb invoice portal. */
        fun defaultInvoiceMemo(defaultInvoiceMemo: String) = apply {
            this.defaultInvoiceMemo = defaultInvoiceMemo
        }

        fun externalPlanId(externalPlanId: String) = apply { this.externalPlanId = externalPlanId }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(metadata: Metadata) = apply { this.metadata = metadata }

        /**
         * The net terms determines the difference between the invoice date and the issue date for
         * the invoice. If you intend the invoice to be due on issue, set this to 0.
         */
        fun netTerms(netTerms: Long) = apply { this.netTerms = netTerms }

        /**
         * The status of the plan to create (either active or draft). If not specified, this
         * defaults to active.
         */
        fun status(status: Status) = apply { this.status = status }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.putAll(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(::putAdditionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replaceValues(name, listOf(value))
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replaceValues(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(::replaceAdditionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.removeAll(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            names.forEach(::removeAdditionalHeaders)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.putAll(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                additionalQueryParams.forEach(::putAdditionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replaceValues(key, listOf(value))
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replaceValues(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                additionalQueryParams.forEach(::replaceAdditionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply {
            additionalQueryParams.removeAll(key)
        }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalQueryParams)
        }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            this.additionalBodyProperties.clear()
            this.additionalBodyProperties.putAll(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            this.additionalBodyProperties.put(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                this.additionalBodyProperties.putAll(additionalBodyProperties)
            }

        fun build(): PlanCreateParams =
            PlanCreateParams(
                checkNotNull(currency) { "`currency` is required but was not set" },
                checkNotNull(name) { "`name` is required but was not set" },
                checkNotNull(prices) { "`prices` is required but was not set" }.toImmutable(),
                defaultInvoiceMemo,
                externalPlanId,
                metadata,
                netTerms,
                status,
                additionalHeaders
                    .asMap()
                    .mapValues { it.value.toList().toImmutable() }
                    .toImmutable(),
                additionalQueryParams
                    .asMap()
                    .mapValues { it.value.toList().toImmutable() }
                    .toImmutable(),
                additionalBodyProperties.toImmutable(),
            )
    }

    @JsonDeserialize(using = Price.Deserializer::class)
    @JsonSerialize(using = Price.Serializer::class)
    class Price
    private constructor(
        private val newPlanUnitPrice: NewPlanUnitPrice? = null,
        private val newPlanPackagePrice: NewPlanPackagePrice? = null,
        private val newPlanMatrixPrice: NewPlanMatrixPrice? = null,
        private val newPlanTieredPrice: NewPlanTieredPrice? = null,
        private val newPlanTieredBpsPrice: NewPlanTieredBpsPrice? = null,
        private val newPlanBpsPrice: NewPlanBpsPrice? = null,
        private val newPlanBulkBpsPrice: NewPlanBulkBpsPrice? = null,
        private val newPlanBulkPrice: NewPlanBulkPrice? = null,
        private val newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice? = null,
        private val newPlanTieredPackagePrice: NewPlanTieredPackagePrice? = null,
        private val newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice? = null,
        private val newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice? = null,
        private val newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice? = null,
        private val newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice? = null,
        private val newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice? = null,
        private val newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice? = null,
        private val newPlanGroupedWithProratedMinimumPrice:
            NewPlanGroupedWithProratedMinimumPrice? =
            null,
        private val newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice? =
            null,
        private val newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice? = null,
        private val newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice? = null,
        private val _json: JsonValue? = null,
    ) {

        private var validated: Boolean = false

        fun newPlanUnitPrice(): Optional<NewPlanUnitPrice> = Optional.ofNullable(newPlanUnitPrice)

        fun newPlanPackagePrice(): Optional<NewPlanPackagePrice> =
            Optional.ofNullable(newPlanPackagePrice)

        fun newPlanMatrixPrice(): Optional<NewPlanMatrixPrice> =
            Optional.ofNullable(newPlanMatrixPrice)

        fun newPlanTieredPrice(): Optional<NewPlanTieredPrice> =
            Optional.ofNullable(newPlanTieredPrice)

        fun newPlanTieredBpsPrice(): Optional<NewPlanTieredBpsPrice> =
            Optional.ofNullable(newPlanTieredBpsPrice)

        fun newPlanBpsPrice(): Optional<NewPlanBpsPrice> = Optional.ofNullable(newPlanBpsPrice)

        fun newPlanBulkBpsPrice(): Optional<NewPlanBulkBpsPrice> =
            Optional.ofNullable(newPlanBulkBpsPrice)

        fun newPlanBulkPrice(): Optional<NewPlanBulkPrice> = Optional.ofNullable(newPlanBulkPrice)

        fun newPlanThresholdTotalAmountPrice(): Optional<NewPlanThresholdTotalAmountPrice> =
            Optional.ofNullable(newPlanThresholdTotalAmountPrice)

        fun newPlanTieredPackagePrice(): Optional<NewPlanTieredPackagePrice> =
            Optional.ofNullable(newPlanTieredPackagePrice)

        fun newPlanTieredWithMinimumPrice(): Optional<NewPlanTieredWithMinimumPrice> =
            Optional.ofNullable(newPlanTieredWithMinimumPrice)

        fun newPlanUnitWithPercentPrice(): Optional<NewPlanUnitWithPercentPrice> =
            Optional.ofNullable(newPlanUnitWithPercentPrice)

        fun newPlanPackageWithAllocationPrice(): Optional<NewPlanPackageWithAllocationPrice> =
            Optional.ofNullable(newPlanPackageWithAllocationPrice)

        fun newPlanTierWithProrationPrice(): Optional<NewPlanTierWithProrationPrice> =
            Optional.ofNullable(newPlanTierWithProrationPrice)

        fun newPlanUnitWithProrationPrice(): Optional<NewPlanUnitWithProrationPrice> =
            Optional.ofNullable(newPlanUnitWithProrationPrice)

        fun newPlanGroupedAllocationPrice(): Optional<NewPlanGroupedAllocationPrice> =
            Optional.ofNullable(newPlanGroupedAllocationPrice)

        fun newPlanGroupedWithProratedMinimumPrice():
            Optional<NewPlanGroupedWithProratedMinimumPrice> =
            Optional.ofNullable(newPlanGroupedWithProratedMinimumPrice)

        fun newPlanGroupedWithMeteredMinimumPrice():
            Optional<NewPlanGroupedWithMeteredMinimumPrice> =
            Optional.ofNullable(newPlanGroupedWithMeteredMinimumPrice)

        fun newPlanMatrixWithDisplayNamePrice(): Optional<NewPlanMatrixWithDisplayNamePrice> =
            Optional.ofNullable(newPlanMatrixWithDisplayNamePrice)

        fun newPlanBulkWithProrationPrice(): Optional<NewPlanBulkWithProrationPrice> =
            Optional.ofNullable(newPlanBulkWithProrationPrice)

        fun isNewPlanUnitPrice(): Boolean = newPlanUnitPrice != null

        fun isNewPlanPackagePrice(): Boolean = newPlanPackagePrice != null

        fun isNewPlanMatrixPrice(): Boolean = newPlanMatrixPrice != null

        fun isNewPlanTieredPrice(): Boolean = newPlanTieredPrice != null

        fun isNewPlanTieredBpsPrice(): Boolean = newPlanTieredBpsPrice != null

        fun isNewPlanBpsPrice(): Boolean = newPlanBpsPrice != null

        fun isNewPlanBulkBpsPrice(): Boolean = newPlanBulkBpsPrice != null

        fun isNewPlanBulkPrice(): Boolean = newPlanBulkPrice != null

        fun isNewPlanThresholdTotalAmountPrice(): Boolean = newPlanThresholdTotalAmountPrice != null

        fun isNewPlanTieredPackagePrice(): Boolean = newPlanTieredPackagePrice != null

        fun isNewPlanTieredWithMinimumPrice(): Boolean = newPlanTieredWithMinimumPrice != null

        fun isNewPlanUnitWithPercentPrice(): Boolean = newPlanUnitWithPercentPrice != null

        fun isNewPlanPackageWithAllocationPrice(): Boolean =
            newPlanPackageWithAllocationPrice != null

        fun isNewPlanTierWithProrationPrice(): Boolean = newPlanTierWithProrationPrice != null

        fun isNewPlanUnitWithProrationPrice(): Boolean = newPlanUnitWithProrationPrice != null

        fun isNewPlanGroupedAllocationPrice(): Boolean = newPlanGroupedAllocationPrice != null

        fun isNewPlanGroupedWithProratedMinimumPrice(): Boolean =
            newPlanGroupedWithProratedMinimumPrice != null

        fun isNewPlanGroupedWithMeteredMinimumPrice(): Boolean =
            newPlanGroupedWithMeteredMinimumPrice != null

        fun isNewPlanMatrixWithDisplayNamePrice(): Boolean =
            newPlanMatrixWithDisplayNamePrice != null

        fun isNewPlanBulkWithProrationPrice(): Boolean = newPlanBulkWithProrationPrice != null

        fun asNewPlanUnitPrice(): NewPlanUnitPrice = newPlanUnitPrice.getOrThrow("newPlanUnitPrice")

        fun asNewPlanPackagePrice(): NewPlanPackagePrice =
            newPlanPackagePrice.getOrThrow("newPlanPackagePrice")

        fun asNewPlanMatrixPrice(): NewPlanMatrixPrice =
            newPlanMatrixPrice.getOrThrow("newPlanMatrixPrice")

        fun asNewPlanTieredPrice(): NewPlanTieredPrice =
            newPlanTieredPrice.getOrThrow("newPlanTieredPrice")

        fun asNewPlanTieredBpsPrice(): NewPlanTieredBpsPrice =
            newPlanTieredBpsPrice.getOrThrow("newPlanTieredBpsPrice")

        fun asNewPlanBpsPrice(): NewPlanBpsPrice = newPlanBpsPrice.getOrThrow("newPlanBpsPrice")

        fun asNewPlanBulkBpsPrice(): NewPlanBulkBpsPrice =
            newPlanBulkBpsPrice.getOrThrow("newPlanBulkBpsPrice")

        fun asNewPlanBulkPrice(): NewPlanBulkPrice = newPlanBulkPrice.getOrThrow("newPlanBulkPrice")

        fun asNewPlanThresholdTotalAmountPrice(): NewPlanThresholdTotalAmountPrice =
            newPlanThresholdTotalAmountPrice.getOrThrow("newPlanThresholdTotalAmountPrice")

        fun asNewPlanTieredPackagePrice(): NewPlanTieredPackagePrice =
            newPlanTieredPackagePrice.getOrThrow("newPlanTieredPackagePrice")

        fun asNewPlanTieredWithMinimumPrice(): NewPlanTieredWithMinimumPrice =
            newPlanTieredWithMinimumPrice.getOrThrow("newPlanTieredWithMinimumPrice")

        fun asNewPlanUnitWithPercentPrice(): NewPlanUnitWithPercentPrice =
            newPlanUnitWithPercentPrice.getOrThrow("newPlanUnitWithPercentPrice")

        fun asNewPlanPackageWithAllocationPrice(): NewPlanPackageWithAllocationPrice =
            newPlanPackageWithAllocationPrice.getOrThrow("newPlanPackageWithAllocationPrice")

        fun asNewPlanTierWithProrationPrice(): NewPlanTierWithProrationPrice =
            newPlanTierWithProrationPrice.getOrThrow("newPlanTierWithProrationPrice")

        fun asNewPlanUnitWithProrationPrice(): NewPlanUnitWithProrationPrice =
            newPlanUnitWithProrationPrice.getOrThrow("newPlanUnitWithProrationPrice")

        fun asNewPlanGroupedAllocationPrice(): NewPlanGroupedAllocationPrice =
            newPlanGroupedAllocationPrice.getOrThrow("newPlanGroupedAllocationPrice")

        fun asNewPlanGroupedWithProratedMinimumPrice(): NewPlanGroupedWithProratedMinimumPrice =
            newPlanGroupedWithProratedMinimumPrice.getOrThrow(
                "newPlanGroupedWithProratedMinimumPrice"
            )

        fun asNewPlanGroupedWithMeteredMinimumPrice(): NewPlanGroupedWithMeteredMinimumPrice =
            newPlanGroupedWithMeteredMinimumPrice.getOrThrow(
                "newPlanGroupedWithMeteredMinimumPrice"
            )

        fun asNewPlanMatrixWithDisplayNamePrice(): NewPlanMatrixWithDisplayNamePrice =
            newPlanMatrixWithDisplayNamePrice.getOrThrow("newPlanMatrixWithDisplayNamePrice")

        fun asNewPlanBulkWithProrationPrice(): NewPlanBulkWithProrationPrice =
            newPlanBulkWithProrationPrice.getOrThrow("newPlanBulkWithProrationPrice")

        fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                newPlanUnitPrice != null -> visitor.visitNewPlanUnitPrice(newPlanUnitPrice)
                newPlanPackagePrice != null -> visitor.visitNewPlanPackagePrice(newPlanPackagePrice)
                newPlanMatrixPrice != null -> visitor.visitNewPlanMatrixPrice(newPlanMatrixPrice)
                newPlanTieredPrice != null -> visitor.visitNewPlanTieredPrice(newPlanTieredPrice)
                newPlanTieredBpsPrice != null ->
                    visitor.visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice)
                newPlanBpsPrice != null -> visitor.visitNewPlanBpsPrice(newPlanBpsPrice)
                newPlanBulkBpsPrice != null -> visitor.visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice)
                newPlanBulkPrice != null -> visitor.visitNewPlanBulkPrice(newPlanBulkPrice)
                newPlanThresholdTotalAmountPrice != null ->
                    visitor.visitNewPlanThresholdTotalAmountPrice(newPlanThresholdTotalAmountPrice)
                newPlanTieredPackagePrice != null ->
                    visitor.visitNewPlanTieredPackagePrice(newPlanTieredPackagePrice)
                newPlanTieredWithMinimumPrice != null ->
                    visitor.visitNewPlanTieredWithMinimumPrice(newPlanTieredWithMinimumPrice)
                newPlanUnitWithPercentPrice != null ->
                    visitor.visitNewPlanUnitWithPercentPrice(newPlanUnitWithPercentPrice)
                newPlanPackageWithAllocationPrice != null ->
                    visitor.visitNewPlanPackageWithAllocationPrice(
                        newPlanPackageWithAllocationPrice
                    )
                newPlanTierWithProrationPrice != null ->
                    visitor.visitNewPlanTierWithProrationPrice(newPlanTierWithProrationPrice)
                newPlanUnitWithProrationPrice != null ->
                    visitor.visitNewPlanUnitWithProrationPrice(newPlanUnitWithProrationPrice)
                newPlanGroupedAllocationPrice != null ->
                    visitor.visitNewPlanGroupedAllocationPrice(newPlanGroupedAllocationPrice)
                newPlanGroupedWithProratedMinimumPrice != null ->
                    visitor.visitNewPlanGroupedWithProratedMinimumPrice(
                        newPlanGroupedWithProratedMinimumPrice
                    )
                newPlanGroupedWithMeteredMinimumPrice != null ->
                    visitor.visitNewPlanGroupedWithMeteredMinimumPrice(
                        newPlanGroupedWithMeteredMinimumPrice
                    )
                newPlanMatrixWithDisplayNamePrice != null ->
                    visitor.visitNewPlanMatrixWithDisplayNamePrice(
                        newPlanMatrixWithDisplayNamePrice
                    )
                newPlanBulkWithProrationPrice != null ->
                    visitor.visitNewPlanBulkWithProrationPrice(newPlanBulkWithProrationPrice)
                else -> visitor.unknown(_json)
            }
        }

        fun validate(): Price = apply {
            if (!validated) {
                if (
                    newPlanUnitPrice == null &&
                        newPlanPackagePrice == null &&
                        newPlanMatrixPrice == null &&
                        newPlanTieredPrice == null &&
                        newPlanTieredBpsPrice == null &&
                        newPlanBpsPrice == null &&
                        newPlanBulkBpsPrice == null &&
                        newPlanBulkPrice == null &&
                        newPlanThresholdTotalAmountPrice == null &&
                        newPlanTieredPackagePrice == null &&
                        newPlanTieredWithMinimumPrice == null &&
                        newPlanUnitWithPercentPrice == null &&
                        newPlanPackageWithAllocationPrice == null &&
                        newPlanTierWithProrationPrice == null &&
                        newPlanUnitWithProrationPrice == null &&
                        newPlanGroupedAllocationPrice == null &&
                        newPlanGroupedWithProratedMinimumPrice == null &&
                        newPlanGroupedWithMeteredMinimumPrice == null &&
                        newPlanMatrixWithDisplayNamePrice == null &&
                        newPlanBulkWithProrationPrice == null
                ) {
                    throw OrbInvalidDataException("Unknown Price: $_json")
                }
                newPlanUnitPrice?.validate()
                newPlanPackagePrice?.validate()
                newPlanMatrixPrice?.validate()
                newPlanTieredPrice?.validate()
                newPlanTieredBpsPrice?.validate()
                newPlanBpsPrice?.validate()
                newPlanBulkBpsPrice?.validate()
                newPlanBulkPrice?.validate()
                newPlanThresholdTotalAmountPrice?.validate()
                newPlanTieredPackagePrice?.validate()
                newPlanTieredWithMinimumPrice?.validate()
                newPlanUnitWithPercentPrice?.validate()
                newPlanPackageWithAllocationPrice?.validate()
                newPlanTierWithProrationPrice?.validate()
                newPlanUnitWithProrationPrice?.validate()
                newPlanGroupedAllocationPrice?.validate()
                newPlanGroupedWithProratedMinimumPrice?.validate()
                newPlanGroupedWithMeteredMinimumPrice?.validate()
                newPlanMatrixWithDisplayNamePrice?.validate()
                newPlanBulkWithProrationPrice?.validate()
                validated = true
            }
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Price && this.newPlanUnitPrice == other.newPlanUnitPrice && this.newPlanPackagePrice == other.newPlanPackagePrice && this.newPlanMatrixPrice == other.newPlanMatrixPrice && this.newPlanTieredPrice == other.newPlanTieredPrice && this.newPlanTieredBpsPrice == other.newPlanTieredBpsPrice && this.newPlanBpsPrice == other.newPlanBpsPrice && this.newPlanBulkBpsPrice == other.newPlanBulkBpsPrice && this.newPlanBulkPrice == other.newPlanBulkPrice && this.newPlanThresholdTotalAmountPrice == other.newPlanThresholdTotalAmountPrice && this.newPlanTieredPackagePrice == other.newPlanTieredPackagePrice && this.newPlanTieredWithMinimumPrice == other.newPlanTieredWithMinimumPrice && this.newPlanUnitWithPercentPrice == other.newPlanUnitWithPercentPrice && this.newPlanPackageWithAllocationPrice == other.newPlanPackageWithAllocationPrice && this.newPlanTierWithProrationPrice == other.newPlanTierWithProrationPrice && this.newPlanUnitWithProrationPrice == other.newPlanUnitWithProrationPrice && this.newPlanGroupedAllocationPrice == other.newPlanGroupedAllocationPrice && this.newPlanGroupedWithProratedMinimumPrice == other.newPlanGroupedWithProratedMinimumPrice && this.newPlanGroupedWithMeteredMinimumPrice == other.newPlanGroupedWithMeteredMinimumPrice && this.newPlanMatrixWithDisplayNamePrice == other.newPlanMatrixWithDisplayNamePrice && this.newPlanBulkWithProrationPrice == other.newPlanBulkWithProrationPrice /* spotless:on */
        }

        override fun hashCode(): Int {
            return /* spotless:off */ Objects.hash(newPlanUnitPrice, newPlanPackagePrice, newPlanMatrixPrice, newPlanTieredPrice, newPlanTieredBpsPrice, newPlanBpsPrice, newPlanBulkBpsPrice, newPlanBulkPrice, newPlanThresholdTotalAmountPrice, newPlanTieredPackagePrice, newPlanTieredWithMinimumPrice, newPlanUnitWithPercentPrice, newPlanPackageWithAllocationPrice, newPlanTierWithProrationPrice, newPlanUnitWithProrationPrice, newPlanGroupedAllocationPrice, newPlanGroupedWithProratedMinimumPrice, newPlanGroupedWithMeteredMinimumPrice, newPlanMatrixWithDisplayNamePrice, newPlanBulkWithProrationPrice) /* spotless:on */
        }

        override fun toString(): String {
            return when {
                newPlanUnitPrice != null -> "Price{newPlanUnitPrice=$newPlanUnitPrice}"
                newPlanPackagePrice != null -> "Price{newPlanPackagePrice=$newPlanPackagePrice}"
                newPlanMatrixPrice != null -> "Price{newPlanMatrixPrice=$newPlanMatrixPrice}"
                newPlanTieredPrice != null -> "Price{newPlanTieredPrice=$newPlanTieredPrice}"
                newPlanTieredBpsPrice != null ->
                    "Price{newPlanTieredBpsPrice=$newPlanTieredBpsPrice}"
                newPlanBpsPrice != null -> "Price{newPlanBpsPrice=$newPlanBpsPrice}"
                newPlanBulkBpsPrice != null -> "Price{newPlanBulkBpsPrice=$newPlanBulkBpsPrice}"
                newPlanBulkPrice != null -> "Price{newPlanBulkPrice=$newPlanBulkPrice}"
                newPlanThresholdTotalAmountPrice != null ->
                    "Price{newPlanThresholdTotalAmountPrice=$newPlanThresholdTotalAmountPrice}"
                newPlanTieredPackagePrice != null ->
                    "Price{newPlanTieredPackagePrice=$newPlanTieredPackagePrice}"
                newPlanTieredWithMinimumPrice != null ->
                    "Price{newPlanTieredWithMinimumPrice=$newPlanTieredWithMinimumPrice}"
                newPlanUnitWithPercentPrice != null ->
                    "Price{newPlanUnitWithPercentPrice=$newPlanUnitWithPercentPrice}"
                newPlanPackageWithAllocationPrice != null ->
                    "Price{newPlanPackageWithAllocationPrice=$newPlanPackageWithAllocationPrice}"
                newPlanTierWithProrationPrice != null ->
                    "Price{newPlanTierWithProrationPrice=$newPlanTierWithProrationPrice}"
                newPlanUnitWithProrationPrice != null ->
                    "Price{newPlanUnitWithProrationPrice=$newPlanUnitWithProrationPrice}"
                newPlanGroupedAllocationPrice != null ->
                    "Price{newPlanGroupedAllocationPrice=$newPlanGroupedAllocationPrice}"
                newPlanGroupedWithProratedMinimumPrice != null ->
                    "Price{newPlanGroupedWithProratedMinimumPrice=$newPlanGroupedWithProratedMinimumPrice}"
                newPlanGroupedWithMeteredMinimumPrice != null ->
                    "Price{newPlanGroupedWithMeteredMinimumPrice=$newPlanGroupedWithMeteredMinimumPrice}"
                newPlanMatrixWithDisplayNamePrice != null ->
                    "Price{newPlanMatrixWithDisplayNamePrice=$newPlanMatrixWithDisplayNamePrice}"
                newPlanBulkWithProrationPrice != null ->
                    "Price{newPlanBulkWithProrationPrice=$newPlanBulkWithProrationPrice}"
                _json != null -> "Price{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Price")
            }
        }

        companion object {

            @JvmStatic
            fun ofNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice) =
                Price(newPlanUnitPrice = newPlanUnitPrice)

            @JvmStatic
            fun ofNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice) =
                Price(newPlanPackagePrice = newPlanPackagePrice)

            @JvmStatic
            fun ofNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice) =
                Price(newPlanMatrixPrice = newPlanMatrixPrice)

            @JvmStatic
            fun ofNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice) =
                Price(newPlanTieredPrice = newPlanTieredPrice)

            @JvmStatic
            fun ofNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) =
                Price(newPlanTieredBpsPrice = newPlanTieredBpsPrice)

            @JvmStatic
            fun ofNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice) =
                Price(newPlanBpsPrice = newPlanBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) =
                Price(newPlanBulkBpsPrice = newPlanBulkBpsPrice)

            @JvmStatic
            fun ofNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice) =
                Price(newPlanBulkPrice = newPlanBulkPrice)

            @JvmStatic
            fun ofNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ) = Price(newPlanThresholdTotalAmountPrice = newPlanThresholdTotalAmountPrice)

            @JvmStatic
            fun ofNewPlanTieredPackagePrice(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) =
                Price(newPlanTieredPackagePrice = newPlanTieredPackagePrice)

            @JvmStatic
            fun ofNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ) = Price(newPlanTieredWithMinimumPrice = newPlanTieredWithMinimumPrice)

            @JvmStatic
            fun ofNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ) = Price(newPlanUnitWithPercentPrice = newPlanUnitWithPercentPrice)

            @JvmStatic
            fun ofNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ) = Price(newPlanPackageWithAllocationPrice = newPlanPackageWithAllocationPrice)

            @JvmStatic
            fun ofNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ) = Price(newPlanTierWithProrationPrice = newPlanTierWithProrationPrice)

            @JvmStatic
            fun ofNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ) = Price(newPlanUnitWithProrationPrice = newPlanUnitWithProrationPrice)

            @JvmStatic
            fun ofNewPlanGroupedAllocationPrice(
                newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice
            ) = Price(newPlanGroupedAllocationPrice = newPlanGroupedAllocationPrice)

            @JvmStatic
            fun ofNewPlanGroupedWithProratedMinimumPrice(
                newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
            ) =
                Price(
                    newPlanGroupedWithProratedMinimumPrice = newPlanGroupedWithProratedMinimumPrice
                )

            @JvmStatic
            fun ofNewPlanGroupedWithMeteredMinimumPrice(
                newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
            ) = Price(newPlanGroupedWithMeteredMinimumPrice = newPlanGroupedWithMeteredMinimumPrice)

            @JvmStatic
            fun ofNewPlanMatrixWithDisplayNamePrice(
                newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
            ) = Price(newPlanMatrixWithDisplayNamePrice = newPlanMatrixWithDisplayNamePrice)

            @JvmStatic
            fun ofNewPlanBulkWithProrationPrice(
                newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice
            ) = Price(newPlanBulkWithProrationPrice = newPlanBulkWithProrationPrice)
        }

        interface Visitor<out T> {

            fun visitNewPlanUnitPrice(newPlanUnitPrice: NewPlanUnitPrice): T

            fun visitNewPlanPackagePrice(newPlanPackagePrice: NewPlanPackagePrice): T

            fun visitNewPlanMatrixPrice(newPlanMatrixPrice: NewPlanMatrixPrice): T

            fun visitNewPlanTieredPrice(newPlanTieredPrice: NewPlanTieredPrice): T

            fun visitNewPlanTieredBpsPrice(newPlanTieredBpsPrice: NewPlanTieredBpsPrice): T

            fun visitNewPlanBpsPrice(newPlanBpsPrice: NewPlanBpsPrice): T

            fun visitNewPlanBulkBpsPrice(newPlanBulkBpsPrice: NewPlanBulkBpsPrice): T

            fun visitNewPlanBulkPrice(newPlanBulkPrice: NewPlanBulkPrice): T

            fun visitNewPlanThresholdTotalAmountPrice(
                newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
            ): T

            fun visitNewPlanTieredPackagePrice(
                newPlanTieredPackagePrice: NewPlanTieredPackagePrice
            ): T

            fun visitNewPlanTieredWithMinimumPrice(
                newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice
            ): T

            fun visitNewPlanUnitWithPercentPrice(
                newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice
            ): T

            fun visitNewPlanPackageWithAllocationPrice(
                newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
            ): T

            fun visitNewPlanTierWithProrationPrice(
                newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice
            ): T

            fun visitNewPlanUnitWithProrationPrice(
                newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice
            ): T

            fun visitNewPlanGroupedAllocationPrice(
                newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice
            ): T

            fun visitNewPlanGroupedWithProratedMinimumPrice(
                newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
            ): T

            fun visitNewPlanGroupedWithMeteredMinimumPrice(
                newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
            ): T

            fun visitNewPlanMatrixWithDisplayNamePrice(
                newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
            ): T

            fun visitNewPlanBulkWithProrationPrice(
                newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice
            ): T

            fun unknown(json: JsonValue?): T {
                throw OrbInvalidDataException("Unknown Price: $json")
            }
        }

        class Deserializer : BaseDeserializer<Price>(Price::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Price {
                val json = JsonValue.fromJsonNode(node)
                val modelType =
                    json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

                when (modelType) {
                    "unit" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitPrice>()) { it.validate() }
                            ?.let {
                                return Price(newPlanUnitPrice = it, _json = json)
                            }
                    }
                    "package" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanPackagePrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanPackagePrice = it, _json = json)
                            }
                    }
                    "matrix" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanMatrixPrice>()) { it.validate() }
                            ?.let {
                                return Price(newPlanMatrixPrice = it, _json = json)
                            }
                    }
                    "tiered" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredPrice>()) { it.validate() }
                            ?.let {
                                return Price(newPlanTieredPrice = it, _json = json)
                            }
                    }
                    "tiered_bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredBpsPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanTieredBpsPrice = it, _json = json)
                            }
                    }
                    "bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBpsPrice>()) { it.validate() }
                            ?.let {
                                return Price(newPlanBpsPrice = it, _json = json)
                            }
                    }
                    "bulk_bps" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkBpsPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanBulkBpsPrice = it, _json = json)
                            }
                    }
                    "bulk" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkPrice>()) { it.validate() }
                            ?.let {
                                return Price(newPlanBulkPrice = it, _json = json)
                            }
                    }
                    "threshold_total_amount" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanThresholdTotalAmountPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanThresholdTotalAmountPrice = it, _json = json)
                            }
                    }
                    "tiered_package" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredPackagePrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanTieredPackagePrice = it, _json = json)
                            }
                    }
                    "tiered_with_minimum" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTieredWithMinimumPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanTieredWithMinimumPrice = it, _json = json)
                            }
                    }
                    "unit_with_percent" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithPercentPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanUnitWithPercentPrice = it, _json = json)
                            }
                    }
                    "package_with_allocation" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanPackageWithAllocationPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanPackageWithAllocationPrice = it, _json = json)
                            }
                    }
                    "tiered_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanTierWithProrationPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanTierWithProrationPrice = it, _json = json)
                            }
                    }
                    "unit_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanUnitWithProrationPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanUnitWithProrationPrice = it, _json = json)
                            }
                    }
                    "grouped_allocation" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanGroupedAllocationPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanGroupedAllocationPrice = it, _json = json)
                            }
                    }
                    "grouped_with_prorated_minimum" -> {
                        tryDeserialize(
                                node,
                                jacksonTypeRef<NewPlanGroupedWithProratedMinimumPrice>()
                            ) {
                                it.validate()
                            }
                            ?.let {
                                return Price(
                                    newPlanGroupedWithProratedMinimumPrice = it,
                                    _json = json
                                )
                            }
                    }
                    "grouped_with_metered_minimum" -> {
                        tryDeserialize(
                                node,
                                jacksonTypeRef<NewPlanGroupedWithMeteredMinimumPrice>()
                            ) {
                                it.validate()
                            }
                            ?.let {
                                return Price(
                                    newPlanGroupedWithMeteredMinimumPrice = it,
                                    _json = json
                                )
                            }
                    }
                    "matrix_with_display_name" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanMatrixWithDisplayNamePrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanMatrixWithDisplayNamePrice = it, _json = json)
                            }
                    }
                    "bulk_with_proration" -> {
                        tryDeserialize(node, jacksonTypeRef<NewPlanBulkWithProrationPrice>()) {
                                it.validate()
                            }
                            ?.let {
                                return Price(newPlanBulkWithProrationPrice = it, _json = json)
                            }
                    }
                }

                return Price(_json = json)
            }
        }

        class Serializer : BaseSerializer<Price>(Price::class) {

            override fun serialize(
                value: Price,
                generator: JsonGenerator,
                provider: SerializerProvider
            ) {
                when {
                    value.newPlanUnitPrice != null -> generator.writeObject(value.newPlanUnitPrice)
                    value.newPlanPackagePrice != null ->
                        generator.writeObject(value.newPlanPackagePrice)
                    value.newPlanMatrixPrice != null ->
                        generator.writeObject(value.newPlanMatrixPrice)
                    value.newPlanTieredPrice != null ->
                        generator.writeObject(value.newPlanTieredPrice)
                    value.newPlanTieredBpsPrice != null ->
                        generator.writeObject(value.newPlanTieredBpsPrice)
                    value.newPlanBpsPrice != null -> generator.writeObject(value.newPlanBpsPrice)
                    value.newPlanBulkBpsPrice != null ->
                        generator.writeObject(value.newPlanBulkBpsPrice)
                    value.newPlanBulkPrice != null -> generator.writeObject(value.newPlanBulkPrice)
                    value.newPlanThresholdTotalAmountPrice != null ->
                        generator.writeObject(value.newPlanThresholdTotalAmountPrice)
                    value.newPlanTieredPackagePrice != null ->
                        generator.writeObject(value.newPlanTieredPackagePrice)
                    value.newPlanTieredWithMinimumPrice != null ->
                        generator.writeObject(value.newPlanTieredWithMinimumPrice)
                    value.newPlanUnitWithPercentPrice != null ->
                        generator.writeObject(value.newPlanUnitWithPercentPrice)
                    value.newPlanPackageWithAllocationPrice != null ->
                        generator.writeObject(value.newPlanPackageWithAllocationPrice)
                    value.newPlanTierWithProrationPrice != null ->
                        generator.writeObject(value.newPlanTierWithProrationPrice)
                    value.newPlanUnitWithProrationPrice != null ->
                        generator.writeObject(value.newPlanUnitWithProrationPrice)
                    value.newPlanGroupedAllocationPrice != null ->
                        generator.writeObject(value.newPlanGroupedAllocationPrice)
                    value.newPlanGroupedWithProratedMinimumPrice != null ->
                        generator.writeObject(value.newPlanGroupedWithProratedMinimumPrice)
                    value.newPlanGroupedWithMeteredMinimumPrice != null ->
                        generator.writeObject(value.newPlanGroupedWithMeteredMinimumPrice)
                    value.newPlanMatrixWithDisplayNamePrice != null ->
                        generator.writeObject(value.newPlanMatrixWithDisplayNamePrice)
                    value.newPlanBulkWithProrationPrice != null ->
                        generator.writeObject(value.newPlanBulkWithProrationPrice)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Price")
                }
            }
        }

        @JsonDeserialize(builder = NewPlanUnitPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitConfig: JsonField<UnitConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_config") @ExcludeMissing fun _unitConfig() = unitConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    unitConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitConfig: JsonField<UnitConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitPrice: NewPlanUnitPrice) = apply {
                    this.metadata = newPlanUnitPrice.metadata
                    this.externalPriceId = newPlanUnitPrice.externalPriceId
                    this.name = newPlanUnitPrice.name
                    this.billableMetricId = newPlanUnitPrice.billableMetricId
                    this.itemId = newPlanUnitPrice.itemId
                    this.billedInAdvance = newPlanUnitPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanUnitPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanUnitPrice.invoiceGroupingKey
                    this.cadence = newPlanUnitPrice.cadence
                    this.billingCycleConfiguration = newPlanUnitPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration = newPlanUnitPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanUnitPrice.conversionRate
                    this.modelType = newPlanUnitPrice.modelType
                    this.unitConfig = newPlanUnitPrice.unitConfig
                    this.currency = newPlanUnitPrice.currency
                    additionalProperties(newPlanUnitPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

                @JsonProperty("unit_config")
                @ExcludeMissing
                fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                    this.unitConfig = unitConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitPrice =
                    NewPlanUnitPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        unitConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT = ModelType(JsonField.of("unit"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT,
                }

                enum class Value {
                    UNIT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT -> Value.UNIT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT -> Known.UNIT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitConfig.Builder::class)
            @NoAutoDetect
            class UnitConfig
            private constructor(
                private val unitAmount: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** Rate per unit of usage */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /** Rate per unit of usage */
                @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitConfig = apply {
                    if (!validated) {
                        unitAmount()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var unitAmount: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitConfig: UnitConfig) = apply {
                        this.unitAmount = unitConfig.unitAmount
                        additionalProperties(unitConfig.additionalProperties)
                    }

                    /** Rate per unit of usage */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Rate per unit of usage */
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitConfig =
                        UnitConfig(unitAmount, additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitConfig && this.unitAmount == other.unitAmount && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(unitAmount, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.unitConfig == other.unitConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, unitConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitConfig=$unitConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanPackagePrice.Builder::class)
        @NoAutoDetect
        class NewPlanPackagePrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val packageConfig: JsonField<PackageConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("package_config") @ExcludeMissing fun _packageConfig() = packageConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanPackagePrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    packageConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var packageConfig: JsonField<PackageConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanPackagePrice: NewPlanPackagePrice) = apply {
                    this.metadata = newPlanPackagePrice.metadata
                    this.externalPriceId = newPlanPackagePrice.externalPriceId
                    this.name = newPlanPackagePrice.name
                    this.billableMetricId = newPlanPackagePrice.billableMetricId
                    this.itemId = newPlanPackagePrice.itemId
                    this.billedInAdvance = newPlanPackagePrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanPackagePrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanPackagePrice.invoiceGroupingKey
                    this.cadence = newPlanPackagePrice.cadence
                    this.billingCycleConfiguration = newPlanPackagePrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanPackagePrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanPackagePrice.conversionRate
                    this.modelType = newPlanPackagePrice.modelType
                    this.packageConfig = newPlanPackagePrice.packageConfig
                    this.currency = newPlanPackagePrice.currency
                    additionalProperties(newPlanPackagePrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun packageConfig(packageConfig: PackageConfig) =
                    packageConfig(JsonField.of(packageConfig))

                @JsonProperty("package_config")
                @ExcludeMissing
                fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                    this.packageConfig = packageConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanPackagePrice =
                    NewPlanPackagePrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        packageConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val PACKAGE = ModelType(JsonField.of("package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE,
                }

                enum class Value {
                    PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE -> Value.PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE -> Known.PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageConfig.Builder::class)
            @NoAutoDetect
            class PackageConfig
            private constructor(
                private val packageAmount: JsonField<String>,
                private val packageSize: JsonField<Long>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** A currency amount to rate usage by */
                fun packageAmount(): String = packageAmount.getRequired("package_amount")

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(): Long = packageSize.getRequired("package_size")

                /** A currency amount to rate usage by */
                @JsonProperty("package_amount") @ExcludeMissing fun _packageAmount() = packageAmount

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                @JsonProperty("package_size") @ExcludeMissing fun _packageSize() = packageSize

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageConfig = apply {
                    if (!validated) {
                        packageAmount()
                        packageSize()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var packageAmount: JsonField<String> = JsonMissing.of()
                    private var packageSize: JsonField<Long> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageConfig: PackageConfig) = apply {
                        this.packageAmount = packageConfig.packageAmount
                        this.packageSize = packageConfig.packageSize
                        additionalProperties(packageConfig.additionalProperties)
                    }

                    /** A currency amount to rate usage by */
                    fun packageAmount(packageAmount: String) =
                        packageAmount(JsonField.of(packageAmount))

                    /** A currency amount to rate usage by */
                    @JsonProperty("package_amount")
                    @ExcludeMissing
                    fun packageAmount(packageAmount: JsonField<String>) = apply {
                        this.packageAmount = packageAmount
                    }

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                    /**
                     * An integer amount to represent package size. For example, 1000 here would
                     * divide usage by 1000 before multiplying by package_amount in rating
                     */
                    @JsonProperty("package_size")
                    @ExcludeMissing
                    fun packageSize(packageSize: JsonField<Long>) = apply {
                        this.packageSize = packageSize
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageConfig =
                        PackageConfig(
                            packageAmount,
                            packageSize,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is PackageConfig && this.packageAmount == other.packageAmount && this.packageSize == other.packageSize && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(packageAmount, packageSize, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanPackagePrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.packageConfig == other.packageConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, packageConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageConfig=$packageConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanMatrixPrice.Builder::class)
        @NoAutoDetect
        class NewPlanMatrixPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val matrixConfig: JsonField<MatrixConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("matrix_config") @ExcludeMissing fun _matrixConfig() = matrixConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanMatrixPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    matrixConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var matrixConfig: JsonField<MatrixConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanMatrixPrice: NewPlanMatrixPrice) = apply {
                    this.metadata = newPlanMatrixPrice.metadata
                    this.externalPriceId = newPlanMatrixPrice.externalPriceId
                    this.name = newPlanMatrixPrice.name
                    this.billableMetricId = newPlanMatrixPrice.billableMetricId
                    this.itemId = newPlanMatrixPrice.itemId
                    this.billedInAdvance = newPlanMatrixPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanMatrixPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanMatrixPrice.invoiceGroupingKey
                    this.cadence = newPlanMatrixPrice.cadence
                    this.billingCycleConfiguration = newPlanMatrixPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanMatrixPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanMatrixPrice.conversionRate
                    this.modelType = newPlanMatrixPrice.modelType
                    this.matrixConfig = newPlanMatrixPrice.matrixConfig
                    this.currency = newPlanMatrixPrice.currency
                    additionalProperties(newPlanMatrixPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun matrixConfig(matrixConfig: MatrixConfig) =
                    matrixConfig(JsonField.of(matrixConfig))

                @JsonProperty("matrix_config")
                @ExcludeMissing
                fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                    this.matrixConfig = matrixConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanMatrixPrice =
                    NewPlanMatrixPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        matrixConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = MatrixConfig.Builder::class)
            @NoAutoDetect
            class MatrixConfig
            private constructor(
                private val dimensions: JsonField<List<String?>>,
                private val defaultUnitAmount: JsonField<String>,
                private val matrixValues: JsonField<List<MatrixValue>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(): String =
                    defaultUnitAmount.getRequired("default_unit_amount")

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

                /** One or two event property values to evaluate matrix groups by */
                @JsonProperty("dimensions") @ExcludeMissing fun _dimensions() = dimensions

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                @JsonProperty("default_unit_amount")
                @ExcludeMissing
                fun _defaultUnitAmount() = defaultUnitAmount

                /** Matrix values for specified matrix grouping keys */
                @JsonProperty("matrix_values") @ExcludeMissing fun _matrixValues() = matrixValues

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): MatrixConfig = apply {
                    if (!validated) {
                        dimensions()
                        defaultUnitAmount()
                        matrixValues().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var dimensions: JsonField<List<String?>> = JsonMissing.of()
                    private var defaultUnitAmount: JsonField<String> = JsonMissing.of()
                    private var matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixConfig: MatrixConfig) = apply {
                        this.dimensions = matrixConfig.dimensions
                        this.defaultUnitAmount = matrixConfig.defaultUnitAmount
                        this.matrixValues = matrixConfig.matrixValues
                        additionalProperties(matrixConfig.additionalProperties)
                    }

                    /** One or two event property values to evaluate matrix groups by */
                    fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                    /** One or two event property values to evaluate matrix groups by */
                    @JsonProperty("dimensions")
                    @ExcludeMissing
                    fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                        this.dimensions = dimensions
                    }

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    fun defaultUnitAmount(defaultUnitAmount: String) =
                        defaultUnitAmount(JsonField.of(defaultUnitAmount))

                    /**
                     * Default per unit rate for any usage not bucketed into a specified
                     * matrix_value
                     */
                    @JsonProperty("default_unit_amount")
                    @ExcludeMissing
                    fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                        this.defaultUnitAmount = defaultUnitAmount
                    }

                    /** Matrix values for specified matrix grouping keys */
                    fun matrixValues(matrixValues: List<MatrixValue>) =
                        matrixValues(JsonField.of(matrixValues))

                    /** Matrix values for specified matrix grouping keys */
                    @JsonProperty("matrix_values")
                    @ExcludeMissing
                    fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                        this.matrixValues = matrixValues
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): MatrixConfig =
                        MatrixConfig(
                            dimensions.map { it.toImmutable() },
                            defaultUnitAmount,
                            matrixValues.map { it.toImmutable() },
                            additionalProperties.toImmutable(),
                        )
                }

                @JsonDeserialize(builder = MatrixValue.Builder::class)
                @NoAutoDetect
                class MatrixValue
                private constructor(
                    private val unitAmount: JsonField<String>,
                    private val dimensionValues: JsonField<List<String?>>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(): List<String?> =
                        dimensionValues.getRequired("dimension_values")

                    /** Unit price for the specified dimension_values */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    @JsonProperty("dimension_values")
                    @ExcludeMissing
                    fun _dimensionValues() = dimensionValues

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): MatrixValue = apply {
                        if (!validated) {
                            unitAmount()
                            dimensionValues()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var dimensionValues: JsonField<List<String?>> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(matrixValue: MatrixValue) = apply {
                            this.unitAmount = matrixValue.unitAmount
                            this.dimensionValues = matrixValue.dimensionValues
                            additionalProperties(matrixValue.additionalProperties)
                        }

                        /** Unit price for the specified dimension_values */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Unit price for the specified dimension_values */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        fun dimensionValues(dimensionValues: List<String?>) =
                            dimensionValues(JsonField.of(dimensionValues))

                        /**
                         * One or two matrix keys to filter usage to this Matrix value by. For
                         * example, ["region", "tier"] could be used to filter cloud usage by a
                         * cloud region and an instance tier.
                         */
                        @JsonProperty("dimension_values")
                        @ExcludeMissing
                        fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                            this.dimensionValues = dimensionValues
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): MatrixValue =
                            MatrixValue(
                                unitAmount,
                                dimensionValues.map { it.toImmutable() },
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is MatrixValue && this.unitAmount == other.unitAmount && this.dimensionValues == other.dimensionValues && this.additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    private var hashCode: Int = 0

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = /* spotless:off */ Objects.hash(unitAmount, dimensionValues, additionalProperties) /* spotless:on */
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "MatrixValue{unitAmount=$unitAmount, dimensionValues=$dimensionValues, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixConfig && this.dimensions == other.dimensions && this.defaultUnitAmount == other.defaultUnitAmount && this.matrixValues == other.matrixValues && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(dimensions, defaultUnitAmount, matrixValues, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "MatrixConfig{dimensions=$dimensions, defaultUnitAmount=$defaultUnitAmount, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val MATRIX = ModelType(JsonField.of("matrix"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX,
                }

                enum class Value {
                    MATRIX,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX -> Value.MATRIX
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX -> Known.MATRIX
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanMatrixPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.matrixConfig == other.matrixConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, matrixConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanMatrixPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, matrixConfig=$matrixConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanTieredPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredConfig: JsonField<TieredConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_config") @ExcludeMissing fun _tieredConfig() = tieredConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    tieredConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredConfig: JsonField<TieredConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPrice: NewPlanTieredPrice) = apply {
                    this.metadata = newPlanTieredPrice.metadata
                    this.externalPriceId = newPlanTieredPrice.externalPriceId
                    this.name = newPlanTieredPrice.name
                    this.billableMetricId = newPlanTieredPrice.billableMetricId
                    this.itemId = newPlanTieredPrice.itemId
                    this.billedInAdvance = newPlanTieredPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredPrice.invoiceGroupingKey
                    this.cadence = newPlanTieredPrice.cadence
                    this.billingCycleConfiguration = newPlanTieredPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanTieredPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanTieredPrice.conversionRate
                    this.modelType = newPlanTieredPrice.modelType
                    this.tieredConfig = newPlanTieredPrice.tieredConfig
                    this.currency = newPlanTieredPrice.currency
                    additionalProperties(newPlanTieredPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredConfig(tieredConfig: TieredConfig) =
                    tieredConfig(JsonField.of(tieredConfig))

                @JsonProperty("tiered_config")
                @ExcludeMissing
                fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                    this.tieredConfig = tieredConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredPrice =
                    NewPlanTieredPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        tieredConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED = ModelType(JsonField.of("tiered"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED,
                }

                enum class Value {
                    TIERED,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED -> Value.TIERED
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED -> Known.TIERED
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredConfig.Builder::class)
            @NoAutoDetect
            class TieredConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Tiers for rating based on total usage quantities into the specified tier */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredConfig: TieredConfig) = apply {
                        this.tiers = tieredConfig.tiers
                        additionalProperties(tieredConfig.additionalProperties)
                    }

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Tiers for rating based on total usage quantities into the specified tier */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredConfig =
                        TieredConfig(
                            tiers.map { it.toImmutable() },
                            additionalProperties.toImmutable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val firstUnit: JsonField<Double>,
                    private val lastUnit: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    /** Inclusive tier starting value */
                    fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(): Optional<Double> =
                        Optional.ofNullable(lastUnit.getNullable("last_unit"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Inclusive tier starting value */
                    @JsonProperty("first_unit") @ExcludeMissing fun _firstUnit() = firstUnit

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    @JsonProperty("last_unit") @ExcludeMissing fun _lastUnit() = lastUnit

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            firstUnit()
                            lastUnit()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var firstUnit: JsonField<Double> = JsonMissing.of()
                        private var lastUnit: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.firstUnit = tier.firstUnit
                            this.lastUnit = tier.lastUnit
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                        /** Inclusive tier starting value */
                        @JsonProperty("first_unit")
                        @ExcludeMissing
                        fun firstUnit(firstUnit: JsonField<Double>) = apply {
                            this.firstUnit = firstUnit
                        }

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        fun lastUnit(lastUnit: Double) = lastUnit(JsonField.of(lastUnit))

                        /**
                         * Exclusive tier ending value. If null, this is treated as the last tier
                         */
                        @JsonProperty("last_unit")
                        @ExcludeMissing
                        fun lastUnit(lastUnit: JsonField<Double>) = apply {
                            this.lastUnit = lastUnit
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                firstUnit,
                                lastUnit,
                                unitAmount,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && this.firstUnit == other.firstUnit && this.lastUnit == other.lastUnit && this.unitAmount == other.unitAmount && this.additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    private var hashCode: Int = 0

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = /* spotless:off */ Objects.hash(firstUnit, lastUnit, unitAmount, additionalProperties) /* spotless:on */
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{firstUnit=$firstUnit, lastUnit=$lastUnit, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredConfig && this.tiers == other.tiers && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(tiers, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.tieredConfig == other.tieredConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, tieredConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredConfig=$tieredConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanTieredBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredBpsPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredBpsConfig: JsonField<TieredBpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredBpsConfig(): TieredBpsConfig =
                tieredBpsConfig.getRequired("tiered_bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_bps_config")
            @ExcludeMissing
            fun _tieredBpsConfig() = tieredBpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredBpsPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    tieredBpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredBpsPrice: NewPlanTieredBpsPrice) = apply {
                    this.metadata = newPlanTieredBpsPrice.metadata
                    this.externalPriceId = newPlanTieredBpsPrice.externalPriceId
                    this.name = newPlanTieredBpsPrice.name
                    this.billableMetricId = newPlanTieredBpsPrice.billableMetricId
                    this.itemId = newPlanTieredBpsPrice.itemId
                    this.billedInAdvance = newPlanTieredBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanTieredBpsPrice.cadence
                    this.billingCycleConfiguration = newPlanTieredBpsPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanTieredBpsPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanTieredBpsPrice.conversionRate
                    this.modelType = newPlanTieredBpsPrice.modelType
                    this.tieredBpsConfig = newPlanTieredBpsPrice.tieredBpsConfig
                    this.currency = newPlanTieredBpsPrice.currency
                    additionalProperties(newPlanTieredBpsPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                    tieredBpsConfig(JsonField.of(tieredBpsConfig))

                @JsonProperty("tiered_bps_config")
                @ExcludeMissing
                fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                    this.tieredBpsConfig = tieredBpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredBpsPrice =
                    NewPlanTieredBpsPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        tieredBpsConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_BPS = ModelType(JsonField.of("tiered_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_BPS,
                }

                enum class Value {
                    TIERED_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_BPS -> Value.TIERED_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_BPS -> Known.TIERED_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredBpsConfig.Builder::class)
            @NoAutoDetect
            class TieredBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                        this.tiers = tieredBpsConfig.tiers
                        additionalProperties(tieredBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a Graduated BPS pricing model, where usage is bucketed into
                     * specified tiers
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredBpsConfig =
                        TieredBpsConfig(
                            tiers.map { it.toImmutable() },
                            additionalProperties.toImmutable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val minimumAmount: JsonField<String>,
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    /** Inclusive tier starting value */
                    fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                    /** Exclusive tier ending value */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Per-event basis point rate */
                    fun bps(): Double = bps.getRequired("bps")

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Inclusive tier starting value */
                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    fun _minimumAmount() = minimumAmount

                    /** Exclusive tier ending value */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Per-event basis point rate */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** Per unit maximum to charge */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            minimumAmount()
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var minimumAmount: JsonField<String> = JsonMissing.of()
                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.minimumAmount = tier.minimumAmount
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Inclusive tier starting value */
                        fun minimumAmount(minimumAmount: String) =
                            minimumAmount(JsonField.of(minimumAmount))

                        /** Inclusive tier starting value */
                        @JsonProperty("minimum_amount")
                        @ExcludeMissing
                        fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                            this.minimumAmount = minimumAmount
                        }

                        /** Exclusive tier ending value */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Exclusive tier ending value */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Per-event basis point rate */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Per-event basis point rate */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** Per unit maximum to charge */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** Per unit maximum to charge */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                minimumAmount,
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && this.minimumAmount == other.minimumAmount && this.maximumAmount == other.maximumAmount && this.bps == other.bps && this.perUnitMaximum == other.perUnitMaximum && this.additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    private var hashCode: Int = 0

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = /* spotless:off */ Objects.hash(minimumAmount, maximumAmount, bps, perUnitMaximum, additionalProperties) /* spotless:on */
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredBpsConfig && this.tiers == other.tiers && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(tiers, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredBpsPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.tieredBpsConfig == other.tieredBpsConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, tieredBpsConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredBpsConfig=$tieredBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBpsPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bpsConfig: JsonField<BpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bps_config") @ExcludeMissing fun _bpsConfig() = bpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBpsPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    bpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bpsConfig: JsonField<BpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBpsPrice: NewPlanBpsPrice) = apply {
                    this.metadata = newPlanBpsPrice.metadata
                    this.externalPriceId = newPlanBpsPrice.externalPriceId
                    this.name = newPlanBpsPrice.name
                    this.billableMetricId = newPlanBpsPrice.billableMetricId
                    this.itemId = newPlanBpsPrice.itemId
                    this.billedInAdvance = newPlanBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanBpsPrice.cadence
                    this.billingCycleConfiguration = newPlanBpsPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration = newPlanBpsPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanBpsPrice.conversionRate
                    this.modelType = newPlanBpsPrice.modelType
                    this.bpsConfig = newPlanBpsPrice.bpsConfig
                    this.currency = newPlanBpsPrice.currency
                    additionalProperties(newPlanBpsPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

                @JsonProperty("bps_config")
                @ExcludeMissing
                fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply {
                    this.bpsConfig = bpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBpsPrice =
                    NewPlanBpsPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        bpsConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            @JsonDeserialize(builder = BpsConfig.Builder::class)
            @NoAutoDetect
            class BpsConfig
            private constructor(
                private val bps: JsonField<Double>,
                private val perUnitMaximum: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** Basis point take rate per event */
                fun bps(): Double = bps.getRequired("bps")

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /** Basis point take rate per event */
                @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                /** Optional currency amount maximum to cap spend per event */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum() = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BpsConfig = apply {
                    if (!validated) {
                        bps()
                        perUnitMaximum()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: JsonField<Double> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bpsConfig: BpsConfig) = apply {
                        this.bps = bpsConfig.bps
                        this.perUnitMaximum = bpsConfig.perUnitMaximum
                        additionalProperties(bpsConfig.additionalProperties)
                    }

                    /** Basis point take rate per event */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /** Basis point take rate per event */
                    @JsonProperty("bps")
                    @ExcludeMissing
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Optional currency amount maximum to cap spend per event */
                    fun perUnitMaximum(perUnitMaximum: String) =
                        perUnitMaximum(JsonField.of(perUnitMaximum))

                    /** Optional currency amount maximum to cap spend per event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BpsConfig =
                        BpsConfig(
                            bps,
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BpsConfig && this.bps == other.bps && this.perUnitMaximum == other.perUnitMaximum && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(bps, perUnitMaximum, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BPS = ModelType(JsonField.of("bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BPS,
                }

                enum class Value {
                    BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BPS -> Value.BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BPS -> Known.BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBpsPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.bpsConfig == other.bpsConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, bpsConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bpsConfig=$bpsConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanBulkBpsPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBulkBpsPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bulkBpsConfig: JsonField<BulkBpsConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bulk_bps_config") @ExcludeMissing fun _bulkBpsConfig() = bulkBpsConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBulkBpsPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    bulkBpsConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkBpsPrice: NewPlanBulkBpsPrice) = apply {
                    this.metadata = newPlanBulkBpsPrice.metadata
                    this.externalPriceId = newPlanBulkBpsPrice.externalPriceId
                    this.name = newPlanBulkBpsPrice.name
                    this.billableMetricId = newPlanBulkBpsPrice.billableMetricId
                    this.itemId = newPlanBulkBpsPrice.itemId
                    this.billedInAdvance = newPlanBulkBpsPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBulkBpsPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBulkBpsPrice.invoiceGroupingKey
                    this.cadence = newPlanBulkBpsPrice.cadence
                    this.billingCycleConfiguration = newPlanBulkBpsPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanBulkBpsPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanBulkBpsPrice.conversionRate
                    this.modelType = newPlanBulkBpsPrice.modelType
                    this.bulkBpsConfig = newPlanBulkBpsPrice.bulkBpsConfig
                    this.currency = newPlanBulkBpsPrice.currency
                    additionalProperties(newPlanBulkBpsPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                    bulkBpsConfig(JsonField.of(bulkBpsConfig))

                @JsonProperty("bulk_bps_config")
                @ExcludeMissing
                fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                    this.bulkBpsConfig = bulkBpsConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBulkBpsPrice =
                    NewPlanBulkBpsPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        bulkBpsConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            @JsonDeserialize(builder = BulkBpsConfig.Builder::class)
            @NoAutoDetect
            class BulkBpsConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkBpsConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                        this.tiers = bulkBpsConfig.tiers
                        additionalProperties(bulkBpsConfig.additionalProperties)
                    }

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /**
                     * Tiers for a bulk BPS pricing model where all usage is aggregated to a single
                     * tier based on total volume
                     */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkBpsConfig =
                        BulkBpsConfig(
                            tiers.map { it.toImmutable() },
                            additionalProperties.toImmutable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumAmount: JsonField<String>,
                    private val bps: JsonField<Double>,
                    private val perUnitMaximum: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    /** Upper bound for tier */
                    fun maximumAmount(): Optional<String> =
                        Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                    /** Basis points to rate on */
                    fun bps(): Double = bps.getRequired("bps")

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(): Optional<String> =
                        Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                    /** Upper bound for tier */
                    @JsonProperty("maximum_amount")
                    @ExcludeMissing
                    fun _maximumAmount() = maximumAmount

                    /** Basis points to rate on */
                    @JsonProperty("bps") @ExcludeMissing fun _bps() = bps

                    /** The maximum amount to charge for any one event */
                    @JsonProperty("per_unit_maximum")
                    @ExcludeMissing
                    fun _perUnitMaximum() = perUnitMaximum

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumAmount()
                            bps()
                            perUnitMaximum()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumAmount: JsonField<String> = JsonMissing.of()
                        private var bps: JsonField<Double> = JsonMissing.of()
                        private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumAmount = tier.maximumAmount
                            this.bps = tier.bps
                            this.perUnitMaximum = tier.perUnitMaximum
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for tier */
                        fun maximumAmount(maximumAmount: String) =
                            maximumAmount(JsonField.of(maximumAmount))

                        /** Upper bound for tier */
                        @JsonProperty("maximum_amount")
                        @ExcludeMissing
                        fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                            this.maximumAmount = maximumAmount
                        }

                        /** Basis points to rate on */
                        fun bps(bps: Double) = bps(JsonField.of(bps))

                        /** Basis points to rate on */
                        @JsonProperty("bps")
                        @ExcludeMissing
                        fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                        /** The maximum amount to charge for any one event */
                        fun perUnitMaximum(perUnitMaximum: String) =
                            perUnitMaximum(JsonField.of(perUnitMaximum))

                        /** The maximum amount to charge for any one event */
                        @JsonProperty("per_unit_maximum")
                        @ExcludeMissing
                        fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                            this.perUnitMaximum = perUnitMaximum
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumAmount,
                                bps,
                                perUnitMaximum,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && this.maximumAmount == other.maximumAmount && this.bps == other.bps && this.perUnitMaximum == other.perUnitMaximum && this.additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    private var hashCode: Int = 0

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = /* spotless:off */ Objects.hash(maximumAmount, bps, perUnitMaximum, additionalProperties) /* spotless:on */
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumAmount=$maximumAmount, bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkBpsConfig && this.tiers == other.tiers && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(tiers, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK_BPS = ModelType(JsonField.of("bulk_bps"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_BPS,
                }

                enum class Value {
                    BULK_BPS,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_BPS -> Value.BULK_BPS
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_BPS -> Known.BULK_BPS
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkBpsPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.bulkBpsConfig == other.bulkBpsConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, bulkBpsConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBulkBpsPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkBpsConfig=$bulkBpsConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanBulkPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBulkPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bulkConfig: JsonField<BulkConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bulk_config") @ExcludeMissing fun _bulkConfig() = bulkConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBulkPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    bulkConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bulkConfig: JsonField<BulkConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkPrice: NewPlanBulkPrice) = apply {
                    this.metadata = newPlanBulkPrice.metadata
                    this.externalPriceId = newPlanBulkPrice.externalPriceId
                    this.name = newPlanBulkPrice.name
                    this.billableMetricId = newPlanBulkPrice.billableMetricId
                    this.itemId = newPlanBulkPrice.itemId
                    this.billedInAdvance = newPlanBulkPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanBulkPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanBulkPrice.invoiceGroupingKey
                    this.cadence = newPlanBulkPrice.cadence
                    this.billingCycleConfiguration = newPlanBulkPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration = newPlanBulkPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanBulkPrice.conversionRate
                    this.modelType = newPlanBulkPrice.modelType
                    this.bulkConfig = newPlanBulkPrice.bulkConfig
                    this.currency = newPlanBulkPrice.currency
                    additionalProperties(newPlanBulkPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

                @JsonProperty("bulk_config")
                @ExcludeMissing
                fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                    this.bulkConfig = bulkConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBulkPrice =
                    NewPlanBulkPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        bulkConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            @JsonDeserialize(builder = BulkConfig.Builder::class)
            @NoAutoDetect
            class BulkConfig
            private constructor(
                private val tiers: JsonField<List<Tier>>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(): List<Tier> = tiers.getRequired("tiers")

                /** Bulk tiers for rating based on total usage volume */
                @JsonProperty("tiers") @ExcludeMissing fun _tiers() = tiers

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkConfig = apply {
                    if (!validated) {
                        tiers().forEach { it.validate() }
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var tiers: JsonField<List<Tier>> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkConfig: BulkConfig) = apply {
                        this.tiers = bulkConfig.tiers
                        additionalProperties(bulkConfig.additionalProperties)
                    }

                    /** Bulk tiers for rating based on total usage volume */
                    fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                    /** Bulk tiers for rating based on total usage volume */
                    @JsonProperty("tiers")
                    @ExcludeMissing
                    fun tiers(tiers: JsonField<List<Tier>>) = apply { this.tiers = tiers }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkConfig =
                        BulkConfig(
                            tiers.map { it.toImmutable() },
                            additionalProperties.toImmutable()
                        )
                }

                @JsonDeserialize(builder = Tier.Builder::class)
                @NoAutoDetect
                class Tier
                private constructor(
                    private val maximumUnits: JsonField<Double>,
                    private val unitAmount: JsonField<String>,
                    private val additionalProperties: Map<String, JsonValue>,
                ) {

                    private var validated: Boolean = false

                    /** Upper bound for this tier */
                    fun maximumUnits(): Optional<Double> =
                        Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                    /** Amount per unit */
                    fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                    /** Upper bound for this tier */
                    @JsonProperty("maximum_units")
                    @ExcludeMissing
                    fun _maximumUnits() = maximumUnits

                    /** Amount per unit */
                    @JsonProperty("unit_amount") @ExcludeMissing fun _unitAmount() = unitAmount

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                    fun validate(): Tier = apply {
                        if (!validated) {
                            maximumUnits()
                            unitAmount()
                            validated = true
                        }
                    }

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        @JvmStatic fun builder() = Builder()
                    }

                    class Builder {

                        private var maximumUnits: JsonField<Double> = JsonMissing.of()
                        private var unitAmount: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        @JvmSynthetic
                        internal fun from(tier: Tier) = apply {
                            this.maximumUnits = tier.maximumUnits
                            this.unitAmount = tier.unitAmount
                            additionalProperties(tier.additionalProperties)
                        }

                        /** Upper bound for this tier */
                        fun maximumUnits(maximumUnits: Double) =
                            maximumUnits(JsonField.of(maximumUnits))

                        /** Upper bound for this tier */
                        @JsonProperty("maximum_units")
                        @ExcludeMissing
                        fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                            this.maximumUnits = maximumUnits
                        }

                        /** Amount per unit */
                        fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                        /** Amount per unit */
                        @JsonProperty("unit_amount")
                        @ExcludeMissing
                        fun unitAmount(unitAmount: JsonField<String>) = apply {
                            this.unitAmount = unitAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                this.additionalProperties.putAll(additionalProperties)
                            }

                        @JsonAnySetter
                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            this.additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun build(): Tier =
                            Tier(
                                maximumUnits,
                                unitAmount,
                                additionalProperties.toImmutable(),
                            )
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is Tier && this.maximumUnits == other.maximumUnits && this.unitAmount == other.unitAmount && this.additionalProperties == other.additionalProperties /* spotless:on */
                    }

                    private var hashCode: Int = 0

                    override fun hashCode(): Int {
                        if (hashCode == 0) {
                            hashCode = /* spotless:off */ Objects.hash(maximumUnits, unitAmount, additionalProperties) /* spotless:on */
                        }
                        return hashCode
                    }

                    override fun toString() =
                        "Tier{maximumUnits=$maximumUnits, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkConfig && this.tiers == other.tiers && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(tiers, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val BULK = ModelType(JsonField.of("bulk"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK,
                }

                enum class Value {
                    BULK,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK -> Value.BULK
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK -> Known.BULK
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.bulkConfig == other.bulkConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, bulkConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBulkPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkConfig=$bulkConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanThresholdTotalAmountPrice.Builder::class)
        @NoAutoDetect
        class NewPlanThresholdTotalAmountPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
                thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("threshold_total_amount_config")
            @ExcludeMissing
            fun _thresholdTotalAmountConfig() = thresholdTotalAmountConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanThresholdTotalAmountPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    thresholdTotalAmountConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanThresholdTotalAmountPrice: NewPlanThresholdTotalAmountPrice
                ) = apply {
                    this.metadata = newPlanThresholdTotalAmountPrice.metadata
                    this.externalPriceId = newPlanThresholdTotalAmountPrice.externalPriceId
                    this.name = newPlanThresholdTotalAmountPrice.name
                    this.billableMetricId = newPlanThresholdTotalAmountPrice.billableMetricId
                    this.itemId = newPlanThresholdTotalAmountPrice.itemId
                    this.billedInAdvance = newPlanThresholdTotalAmountPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanThresholdTotalAmountPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanThresholdTotalAmountPrice.invoiceGroupingKey
                    this.cadence = newPlanThresholdTotalAmountPrice.cadence
                    this.billingCycleConfiguration =
                        newPlanThresholdTotalAmountPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanThresholdTotalAmountPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanThresholdTotalAmountPrice.conversionRate
                    this.modelType = newPlanThresholdTotalAmountPrice.modelType
                    this.thresholdTotalAmountConfig =
                        newPlanThresholdTotalAmountPrice.thresholdTotalAmountConfig
                    this.currency = newPlanThresholdTotalAmountPrice.currency
                    additionalProperties(newPlanThresholdTotalAmountPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: ThresholdTotalAmountConfig
                ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

                @JsonProperty("threshold_total_amount_config")
                @ExcludeMissing
                fun thresholdTotalAmountConfig(
                    thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
                ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanThresholdTotalAmountPrice =
                    NewPlanThresholdTotalAmountPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        thresholdTotalAmountConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val THRESHOLD_TOTAL_AMOUNT = ModelType(JsonField.of("threshold_total_amount"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    THRESHOLD_TOTAL_AMOUNT,
                }

                enum class Value {
                    THRESHOLD_TOTAL_AMOUNT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = ThresholdTotalAmountConfig.Builder::class)
            @NoAutoDetect
            class ThresholdTotalAmountConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): ThresholdTotalAmountConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                        apply {
                            additionalProperties(thresholdTotalAmountConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): ThresholdTotalAmountConfig =
                        ThresholdTotalAmountConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ThresholdTotalAmountConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanThresholdTotalAmountPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, thresholdTotalAmountConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanThresholdTotalAmountPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanTieredPackagePrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredPackagePrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredPackageConfig: JsonField<TieredPackageConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredPackageConfig(): TieredPackageConfig =
                tieredPackageConfig.getRequired("tiered_package_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_package_config")
            @ExcludeMissing
            fun _tieredPackageConfig() = tieredPackageConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredPackagePrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    tieredPackageConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredPackagePrice: NewPlanTieredPackagePrice) = apply {
                    this.metadata = newPlanTieredPackagePrice.metadata
                    this.externalPriceId = newPlanTieredPackagePrice.externalPriceId
                    this.name = newPlanTieredPackagePrice.name
                    this.billableMetricId = newPlanTieredPackagePrice.billableMetricId
                    this.itemId = newPlanTieredPackagePrice.itemId
                    this.billedInAdvance = newPlanTieredPackagePrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanTieredPackagePrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanTieredPackagePrice.invoiceGroupingKey
                    this.cadence = newPlanTieredPackagePrice.cadence
                    this.billingCycleConfiguration =
                        newPlanTieredPackagePrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanTieredPackagePrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanTieredPackagePrice.conversionRate
                    this.modelType = newPlanTieredPackagePrice.modelType
                    this.tieredPackageConfig = newPlanTieredPackagePrice.tieredPackageConfig
                    this.currency = newPlanTieredPackagePrice.currency
                    additionalProperties(newPlanTieredPackagePrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                    tieredPackageConfig(JsonField.of(tieredPackageConfig))

                @JsonProperty("tiered_package_config")
                @ExcludeMissing
                fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) =
                    apply {
                        this.tieredPackageConfig = tieredPackageConfig
                    }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredPackagePrice =
                    NewPlanTieredPackagePrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        tieredPackageConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val TIERED_PACKAGE = ModelType(JsonField.of("tiered_package"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_PACKAGE,
                }

                enum class Value {
                    TIERED_PACKAGE,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_PACKAGE -> Value.TIERED_PACKAGE
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_PACKAGE -> Known.TIERED_PACKAGE
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredPackageConfig.Builder::class)
            @NoAutoDetect
            class TieredPackageConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredPackageConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                        additionalProperties(tieredPackageConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredPackageConfig =
                        TieredPackageConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredPackageConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredPackageConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredPackagePrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.tieredPackageConfig == other.tieredPackageConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, tieredPackageConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredPackagePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredPackageConfig=$tieredPackageConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanTieredWithMinimumPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTieredWithMinimumPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
                tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_with_minimum_config")
            @ExcludeMissing
            fun _tieredWithMinimumConfig() = tieredWithMinimumConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTieredWithMinimumPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    tieredWithMinimumConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTieredWithMinimumPrice: NewPlanTieredWithMinimumPrice) =
                    apply {
                        this.metadata = newPlanTieredWithMinimumPrice.metadata
                        this.externalPriceId = newPlanTieredWithMinimumPrice.externalPriceId
                        this.name = newPlanTieredWithMinimumPrice.name
                        this.billableMetricId = newPlanTieredWithMinimumPrice.billableMetricId
                        this.itemId = newPlanTieredWithMinimumPrice.itemId
                        this.billedInAdvance = newPlanTieredWithMinimumPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanTieredWithMinimumPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanTieredWithMinimumPrice.invoiceGroupingKey
                        this.cadence = newPlanTieredWithMinimumPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanTieredWithMinimumPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanTieredWithMinimumPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanTieredWithMinimumPrice.conversionRate
                        this.modelType = newPlanTieredWithMinimumPrice.modelType
                        this.tieredWithMinimumConfig =
                            newPlanTieredWithMinimumPrice.tieredWithMinimumConfig
                        this.currency = newPlanTieredWithMinimumPrice.currency
                        additionalProperties(newPlanTieredWithMinimumPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                    tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

                @JsonProperty("tiered_with_minimum_config")
                @ExcludeMissing
                fun tieredWithMinimumConfig(
                    tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
                ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTieredWithMinimumPrice =
                    NewPlanTieredWithMinimumPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        tieredWithMinimumConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_MINIMUM = ModelType(JsonField.of("tiered_with_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_MINIMUM,
                }

                enum class Value {
                    TIERED_WITH_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithMinimumConfig.Builder::class)
            @NoAutoDetect
            class TieredWithMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                        additionalProperties(tieredWithMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithMinimumConfig =
                        TieredWithMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredWithMinimumConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTieredWithMinimumPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.tieredWithMinimumConfig == other.tieredWithMinimumConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, tieredWithMinimumConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTieredWithMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithMinimumConfig=$tieredWithMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanUnitWithPercentPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitWithPercentPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitWithPercentConfig(): UnitWithPercentConfig =
                unitWithPercentConfig.getRequired("unit_with_percent_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_with_percent_config")
            @ExcludeMissing
            fun _unitWithPercentConfig() = unitWithPercentConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitWithPercentPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    unitWithPercentConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitWithPercentConfig: JsonField<UnitWithPercentConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithPercentPrice: NewPlanUnitWithPercentPrice) =
                    apply {
                        this.metadata = newPlanUnitWithPercentPrice.metadata
                        this.externalPriceId = newPlanUnitWithPercentPrice.externalPriceId
                        this.name = newPlanUnitWithPercentPrice.name
                        this.billableMetricId = newPlanUnitWithPercentPrice.billableMetricId
                        this.itemId = newPlanUnitWithPercentPrice.itemId
                        this.billedInAdvance = newPlanUnitWithPercentPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanUnitWithPercentPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanUnitWithPercentPrice.invoiceGroupingKey
                        this.cadence = newPlanUnitWithPercentPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanUnitWithPercentPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanUnitWithPercentPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanUnitWithPercentPrice.conversionRate
                        this.modelType = newPlanUnitWithPercentPrice.modelType
                        this.unitWithPercentConfig =
                            newPlanUnitWithPercentPrice.unitWithPercentConfig
                        this.currency = newPlanUnitWithPercentPrice.currency
                        additionalProperties(newPlanUnitWithPercentPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                    unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

                @JsonProperty("unit_with_percent_config")
                @ExcludeMissing
                fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                    apply {
                        this.unitWithPercentConfig = unitWithPercentConfig
                    }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitWithPercentPrice =
                    NewPlanUnitWithPercentPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        unitWithPercentConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val UNIT_WITH_PERCENT = ModelType(JsonField.of("unit_with_percent"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PERCENT,
                }

                enum class Value {
                    UNIT_WITH_PERCENT,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithPercentConfig.Builder::class)
            @NoAutoDetect
            class UnitWithPercentConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithPercentConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                        additionalProperties(unitWithPercentConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithPercentConfig =
                        UnitWithPercentConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitWithPercentConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithPercentConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitWithPercentPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.unitWithPercentConfig == other.unitWithPercentConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, unitWithPercentConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitWithPercentPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithPercentConfig=$unitWithPercentConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanPackageWithAllocationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanPackageWithAllocationPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun packageWithAllocationConfig(): PackageWithAllocationConfig =
                packageWithAllocationConfig.getRequired("package_with_allocation_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("package_with_allocation_config")
            @ExcludeMissing
            fun _packageWithAllocationConfig() = packageWithAllocationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanPackageWithAllocationPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    packageWithAllocationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanPackageWithAllocationPrice: NewPlanPackageWithAllocationPrice
                ) = apply {
                    this.metadata = newPlanPackageWithAllocationPrice.metadata
                    this.externalPriceId = newPlanPackageWithAllocationPrice.externalPriceId
                    this.name = newPlanPackageWithAllocationPrice.name
                    this.billableMetricId = newPlanPackageWithAllocationPrice.billableMetricId
                    this.itemId = newPlanPackageWithAllocationPrice.itemId
                    this.billedInAdvance = newPlanPackageWithAllocationPrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanPackageWithAllocationPrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanPackageWithAllocationPrice.invoiceGroupingKey
                    this.cadence = newPlanPackageWithAllocationPrice.cadence
                    this.billingCycleConfiguration =
                        newPlanPackageWithAllocationPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanPackageWithAllocationPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanPackageWithAllocationPrice.conversionRate
                    this.modelType = newPlanPackageWithAllocationPrice.modelType
                    this.packageWithAllocationConfig =
                        newPlanPackageWithAllocationPrice.packageWithAllocationConfig
                    this.currency = newPlanPackageWithAllocationPrice.currency
                    additionalProperties(newPlanPackageWithAllocationPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: PackageWithAllocationConfig
                ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

                @JsonProperty("package_with_allocation_config")
                @ExcludeMissing
                fun packageWithAllocationConfig(
                    packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
                ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanPackageWithAllocationPrice =
                    NewPlanPackageWithAllocationPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        packageWithAllocationConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val PACKAGE_WITH_ALLOCATION = ModelType(JsonField.of("package_with_allocation"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    PACKAGE_WITH_ALLOCATION,
                }

                enum class Value {
                    PACKAGE_WITH_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = PackageWithAllocationConfig.Builder::class)
            @NoAutoDetect
            class PackageWithAllocationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): PackageWithAllocationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                        apply {
                            additionalProperties(packageWithAllocationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): PackageWithAllocationConfig =
                        PackageWithAllocationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is PackageWithAllocationConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanPackageWithAllocationPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.packageWithAllocationConfig == other.packageWithAllocationConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, packageWithAllocationConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanPackageWithAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, packageWithAllocationConfig=$packageWithAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanTierWithProrationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanTierWithProrationPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun tieredWithProrationConfig(): TieredWithProrationConfig =
                tieredWithProrationConfig.getRequired("tiered_with_proration_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("tiered_with_proration_config")
            @ExcludeMissing
            fun _tieredWithProrationConfig() = tieredWithProrationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanTierWithProrationPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    tieredWithProrationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanTierWithProrationPrice: NewPlanTierWithProrationPrice) =
                    apply {
                        this.metadata = newPlanTierWithProrationPrice.metadata
                        this.externalPriceId = newPlanTierWithProrationPrice.externalPriceId
                        this.name = newPlanTierWithProrationPrice.name
                        this.billableMetricId = newPlanTierWithProrationPrice.billableMetricId
                        this.itemId = newPlanTierWithProrationPrice.itemId
                        this.billedInAdvance = newPlanTierWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanTierWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanTierWithProrationPrice.invoiceGroupingKey
                        this.cadence = newPlanTierWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanTierWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanTierWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanTierWithProrationPrice.conversionRate
                        this.modelType = newPlanTierWithProrationPrice.modelType
                        this.tieredWithProrationConfig =
                            newPlanTierWithProrationPrice.tieredWithProrationConfig
                        this.currency = newPlanTierWithProrationPrice.currency
                        additionalProperties(newPlanTierWithProrationPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: TieredWithProrationConfig
                ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

                @JsonProperty("tiered_with_proration_config")
                @ExcludeMissing
                fun tieredWithProrationConfig(
                    tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
                ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanTierWithProrationPrice =
                    NewPlanTierWithProrationPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        tieredWithProrationConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val TIERED_WITH_PRORATION = ModelType(JsonField.of("tiered_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    TIERED_WITH_PRORATION,
                }

                enum class Value {
                    TIERED_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = TieredWithProrationConfig.Builder::class)
            @NoAutoDetect
            class TieredWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): TieredWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) =
                        apply {
                            additionalProperties(tieredWithProrationConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): TieredWithProrationConfig =
                        TieredWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is TieredWithProrationConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "TieredWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanTierWithProrationPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.tieredWithProrationConfig == other.tieredWithProrationConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, tieredWithProrationConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanTierWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, tieredWithProrationConfig=$tieredWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanUnitWithProrationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanUnitWithProrationPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun unitWithProrationConfig(): UnitWithProrationConfig =
                unitWithProrationConfig.getRequired("unit_with_proration_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("unit_with_proration_config")
            @ExcludeMissing
            fun _unitWithProrationConfig() = unitWithProrationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanUnitWithProrationPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    unitWithProrationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var unitWithProrationConfig: JsonField<UnitWithProrationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanUnitWithProrationPrice: NewPlanUnitWithProrationPrice) =
                    apply {
                        this.metadata = newPlanUnitWithProrationPrice.metadata
                        this.externalPriceId = newPlanUnitWithProrationPrice.externalPriceId
                        this.name = newPlanUnitWithProrationPrice.name
                        this.billableMetricId = newPlanUnitWithProrationPrice.billableMetricId
                        this.itemId = newPlanUnitWithProrationPrice.itemId
                        this.billedInAdvance = newPlanUnitWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanUnitWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanUnitWithProrationPrice.invoiceGroupingKey
                        this.cadence = newPlanUnitWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanUnitWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanUnitWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanUnitWithProrationPrice.conversionRate
                        this.modelType = newPlanUnitWithProrationPrice.modelType
                        this.unitWithProrationConfig =
                            newPlanUnitWithProrationPrice.unitWithProrationConfig
                        this.currency = newPlanUnitWithProrationPrice.currency
                        additionalProperties(newPlanUnitWithProrationPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                    unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

                @JsonProperty("unit_with_proration_config")
                @ExcludeMissing
                fun unitWithProrationConfig(
                    unitWithProrationConfig: JsonField<UnitWithProrationConfig>
                ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanUnitWithProrationPrice =
                    NewPlanUnitWithProrationPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        unitWithProrationConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val UNIT_WITH_PRORATION = ModelType(JsonField.of("unit_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    UNIT_WITH_PRORATION,
                }

                enum class Value {
                    UNIT_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = UnitWithProrationConfig.Builder::class)
            @NoAutoDetect
            class UnitWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): UnitWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                        additionalProperties(unitWithProrationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): UnitWithProrationConfig =
                        UnitWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is UnitWithProrationConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "UnitWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanUnitWithProrationPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.unitWithProrationConfig == other.unitWithProrationConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, unitWithProrationConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanUnitWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, unitWithProrationConfig=$unitWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanGroupedAllocationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanGroupedAllocationPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun groupedAllocationConfig(): GroupedAllocationConfig =
                groupedAllocationConfig.getRequired("grouped_allocation_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("grouped_allocation_config")
            @ExcludeMissing
            fun _groupedAllocationConfig() = groupedAllocationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanGroupedAllocationPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    groupedAllocationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var groupedAllocationConfig: JsonField<GroupedAllocationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanGroupedAllocationPrice: NewPlanGroupedAllocationPrice) =
                    apply {
                        this.metadata = newPlanGroupedAllocationPrice.metadata
                        this.externalPriceId = newPlanGroupedAllocationPrice.externalPriceId
                        this.name = newPlanGroupedAllocationPrice.name
                        this.billableMetricId = newPlanGroupedAllocationPrice.billableMetricId
                        this.itemId = newPlanGroupedAllocationPrice.itemId
                        this.billedInAdvance = newPlanGroupedAllocationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanGroupedAllocationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanGroupedAllocationPrice.invoiceGroupingKey
                        this.cadence = newPlanGroupedAllocationPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanGroupedAllocationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanGroupedAllocationPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanGroupedAllocationPrice.conversionRate
                        this.modelType = newPlanGroupedAllocationPrice.modelType
                        this.groupedAllocationConfig =
                            newPlanGroupedAllocationPrice.groupedAllocationConfig
                        this.currency = newPlanGroupedAllocationPrice.currency
                        additionalProperties(newPlanGroupedAllocationPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                    groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

                @JsonProperty("grouped_allocation_config")
                @ExcludeMissing
                fun groupedAllocationConfig(
                    groupedAllocationConfig: JsonField<GroupedAllocationConfig>
                ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanGroupedAllocationPrice =
                    NewPlanGroupedAllocationPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        groupedAllocationConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = GroupedAllocationConfig.Builder::class)
            @NoAutoDetect
            class GroupedAllocationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedAllocationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                        additionalProperties(groupedAllocationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedAllocationConfig =
                        GroupedAllocationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedAllocationConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedAllocationConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val GROUPED_ALLOCATION = ModelType(JsonField.of("grouped_allocation"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_ALLOCATION,
                }

                enum class Value {
                    GROUPED_ALLOCATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedAllocationPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.groupedAllocationConfig == other.groupedAllocationConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, groupedAllocationConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanGroupedAllocationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedAllocationConfig=$groupedAllocationConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanGroupedWithProratedMinimumPrice.Builder::class)
        @NoAutoDetect
        class NewPlanGroupedWithProratedMinimumPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
                groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("grouped_with_prorated_minimum_config")
            @ExcludeMissing
            fun _groupedWithProratedMinimumConfig() = groupedWithProratedMinimumConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanGroupedWithProratedMinimumPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    groupedWithProratedMinimumConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var groupedWithProratedMinimumConfig:
                    JsonField<GroupedWithProratedMinimumConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanGroupedWithProratedMinimumPrice: NewPlanGroupedWithProratedMinimumPrice
                ) = apply {
                    this.metadata = newPlanGroupedWithProratedMinimumPrice.metadata
                    this.externalPriceId = newPlanGroupedWithProratedMinimumPrice.externalPriceId
                    this.name = newPlanGroupedWithProratedMinimumPrice.name
                    this.billableMetricId = newPlanGroupedWithProratedMinimumPrice.billableMetricId
                    this.itemId = newPlanGroupedWithProratedMinimumPrice.itemId
                    this.billedInAdvance = newPlanGroupedWithProratedMinimumPrice.billedInAdvance
                    this.fixedPriceQuantity =
                        newPlanGroupedWithProratedMinimumPrice.fixedPriceQuantity
                    this.invoiceGroupingKey =
                        newPlanGroupedWithProratedMinimumPrice.invoiceGroupingKey
                    this.cadence = newPlanGroupedWithProratedMinimumPrice.cadence
                    this.billingCycleConfiguration =
                        newPlanGroupedWithProratedMinimumPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanGroupedWithProratedMinimumPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanGroupedWithProratedMinimumPrice.conversionRate
                    this.modelType = newPlanGroupedWithProratedMinimumPrice.modelType
                    this.groupedWithProratedMinimumConfig =
                        newPlanGroupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    this.currency = newPlanGroupedWithProratedMinimumPrice.currency
                    additionalProperties(
                        newPlanGroupedWithProratedMinimumPrice.additionalProperties
                    )
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun groupedWithProratedMinimumConfig(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

                @JsonProperty("grouped_with_prorated_minimum_config")
                @ExcludeMissing
                fun groupedWithProratedMinimumConfig(
                    groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
                ) = apply {
                    this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig
                }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanGroupedWithProratedMinimumPrice =
                    NewPlanGroupedWithProratedMinimumPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        groupedWithProratedMinimumConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = GroupedWithProratedMinimumConfig.Builder::class)
            @NoAutoDetect
            class GroupedWithProratedMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedWithProratedMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                    ) = apply {
                        additionalProperties(groupedWithProratedMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedWithProratedMinimumConfig =
                        GroupedWithProratedMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedWithProratedMinimumConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val GROUPED_WITH_PRORATED_MINIMUM =
                        ModelType(JsonField.of("grouped_with_prorated_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_PRORATED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_PRORATED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedWithProratedMinimumPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, groupedWithProratedMinimumConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanGroupedWithProratedMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanGroupedWithMeteredMinimumPrice.Builder::class)
        @NoAutoDetect
        class NewPlanGroupedWithMeteredMinimumPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
                groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("grouped_with_metered_minimum_config")
            @ExcludeMissing
            fun _groupedWithMeteredMinimumConfig() = groupedWithMeteredMinimumConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanGroupedWithMeteredMinimumPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    groupedWithMeteredMinimumConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var groupedWithMeteredMinimumConfig:
                    JsonField<GroupedWithMeteredMinimumConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanGroupedWithMeteredMinimumPrice: NewPlanGroupedWithMeteredMinimumPrice
                ) = apply {
                    this.metadata = newPlanGroupedWithMeteredMinimumPrice.metadata
                    this.externalPriceId = newPlanGroupedWithMeteredMinimumPrice.externalPriceId
                    this.name = newPlanGroupedWithMeteredMinimumPrice.name
                    this.billableMetricId = newPlanGroupedWithMeteredMinimumPrice.billableMetricId
                    this.itemId = newPlanGroupedWithMeteredMinimumPrice.itemId
                    this.billedInAdvance = newPlanGroupedWithMeteredMinimumPrice.billedInAdvance
                    this.fixedPriceQuantity =
                        newPlanGroupedWithMeteredMinimumPrice.fixedPriceQuantity
                    this.invoiceGroupingKey =
                        newPlanGroupedWithMeteredMinimumPrice.invoiceGroupingKey
                    this.cadence = newPlanGroupedWithMeteredMinimumPrice.cadence
                    this.billingCycleConfiguration =
                        newPlanGroupedWithMeteredMinimumPrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanGroupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanGroupedWithMeteredMinimumPrice.conversionRate
                    this.modelType = newPlanGroupedWithMeteredMinimumPrice.modelType
                    this.groupedWithMeteredMinimumConfig =
                        newPlanGroupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    this.currency = newPlanGroupedWithMeteredMinimumPrice.currency
                    additionalProperties(newPlanGroupedWithMeteredMinimumPrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun groupedWithMeteredMinimumConfig(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

                @JsonProperty("grouped_with_metered_minimum_config")
                @ExcludeMissing
                fun groupedWithMeteredMinimumConfig(
                    groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
                ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanGroupedWithMeteredMinimumPrice =
                    NewPlanGroupedWithMeteredMinimumPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        groupedWithMeteredMinimumConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = GroupedWithMeteredMinimumConfig.Builder::class)
            @NoAutoDetect
            class GroupedWithMeteredMinimumConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): GroupedWithMeteredMinimumConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(
                        groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                    ) = apply {
                        additionalProperties(groupedWithMeteredMinimumConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): GroupedWithMeteredMinimumConfig =
                        GroupedWithMeteredMinimumConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is GroupedWithMeteredMinimumConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val GROUPED_WITH_METERED_MINIMUM =
                        ModelType(JsonField.of("grouped_with_metered_minimum"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    GROUPED_WITH_METERED_MINIMUM,
                }

                enum class Value {
                    GROUPED_WITH_METERED_MINIMUM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanGroupedWithMeteredMinimumPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, groupedWithMeteredMinimumConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanGroupedWithMeteredMinimumPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanMatrixWithDisplayNamePrice.Builder::class)
        @NoAutoDetect
        class NewPlanMatrixWithDisplayNamePrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
                matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("matrix_with_display_name_config")
            @ExcludeMissing
            fun _matrixWithDisplayNameConfig() = matrixWithDisplayNameConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanMatrixWithDisplayNamePrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    matrixWithDisplayNameConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    newPlanMatrixWithDisplayNamePrice: NewPlanMatrixWithDisplayNamePrice
                ) = apply {
                    this.metadata = newPlanMatrixWithDisplayNamePrice.metadata
                    this.externalPriceId = newPlanMatrixWithDisplayNamePrice.externalPriceId
                    this.name = newPlanMatrixWithDisplayNamePrice.name
                    this.billableMetricId = newPlanMatrixWithDisplayNamePrice.billableMetricId
                    this.itemId = newPlanMatrixWithDisplayNamePrice.itemId
                    this.billedInAdvance = newPlanMatrixWithDisplayNamePrice.billedInAdvance
                    this.fixedPriceQuantity = newPlanMatrixWithDisplayNamePrice.fixedPriceQuantity
                    this.invoiceGroupingKey = newPlanMatrixWithDisplayNamePrice.invoiceGroupingKey
                    this.cadence = newPlanMatrixWithDisplayNamePrice.cadence
                    this.billingCycleConfiguration =
                        newPlanMatrixWithDisplayNamePrice.billingCycleConfiguration
                    this.invoicingCycleConfiguration =
                        newPlanMatrixWithDisplayNamePrice.invoicingCycleConfiguration
                    this.conversionRate = newPlanMatrixWithDisplayNamePrice.conversionRate
                    this.modelType = newPlanMatrixWithDisplayNamePrice.modelType
                    this.matrixWithDisplayNameConfig =
                        newPlanMatrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                    this.currency = newPlanMatrixWithDisplayNamePrice.currency
                    additionalProperties(newPlanMatrixWithDisplayNamePrice.additionalProperties)
                }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun matrixWithDisplayNameConfig(
                    matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
                ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

                @JsonProperty("matrix_with_display_name_config")
                @ExcludeMissing
                fun matrixWithDisplayNameConfig(
                    matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>
                ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanMatrixWithDisplayNamePrice =
                    NewPlanMatrixWithDisplayNamePrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        matrixWithDisplayNameConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            @JsonDeserialize(builder = MatrixWithDisplayNameConfig.Builder::class)
            @NoAutoDetect
            class MatrixWithDisplayNameConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): MatrixWithDisplayNameConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                        apply {
                            additionalProperties(matrixWithDisplayNameConfig.additionalProperties)
                        }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): MatrixWithDisplayNameConfig =
                        MatrixWithDisplayNameConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixWithDisplayNameConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "MatrixWithDisplayNameConfig{additionalProperties=$additionalProperties}"
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val MATRIX_WITH_DISPLAY_NAME =
                        ModelType(JsonField.of("matrix_with_display_name"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    MATRIX_WITH_DISPLAY_NAME,
                }

                enum class Value {
                    MATRIX_WITH_DISPLAY_NAME,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanMatrixWithDisplayNamePrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, matrixWithDisplayNameConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanMatrixWithDisplayNamePrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @JsonDeserialize(builder = NewPlanBulkWithProrationPrice.Builder::class)
        @NoAutoDetect
        class NewPlanBulkWithProrationPrice
        private constructor(
            private val metadata: JsonField<Metadata>,
            private val externalPriceId: JsonField<String>,
            private val name: JsonField<String>,
            private val billableMetricId: JsonField<String>,
            private val itemId: JsonField<String>,
            private val billedInAdvance: JsonField<Boolean>,
            private val fixedPriceQuantity: JsonField<Double>,
            private val invoiceGroupingKey: JsonField<String>,
            private val cadence: JsonField<Cadence>,
            private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
            private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>,
            private val conversionRate: JsonField<Double>,
            private val modelType: JsonField<ModelType>,
            private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
            private val currency: JsonField<String>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(): Optional<Metadata> =
                Optional.ofNullable(metadata.getNullable("metadata"))

            /** An alias for the price. */
            fun externalPriceId(): Optional<String> =
                Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

            /** The name of the price. */
            fun name(): String = name.getRequired("name")

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(): Optional<String> =
                Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

            /** The id of the item the plan will be associated with. */
            fun itemId(): String = itemId.getRequired("item_id")

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(): Optional<Boolean> =
                Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(): Optional<Double> =
                Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(): Optional<String> =
                Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

            /** The cadence to bill for this price on. */
            fun cadence(): Cadence = cadence.getRequired("cadence")

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(): Optional<BillingCycleConfiguration> =
                Optional.ofNullable(
                    billingCycleConfiguration.getNullable("billing_cycle_configuration")
                )

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
                Optional.ofNullable(
                    invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
                )

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(): Optional<Double> =
                Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

            fun modelType(): ModelType = modelType.getRequired("model_type")

            fun bulkWithProrationConfig(): BulkWithProrationConfig =
                bulkWithProrationConfig.getRequired("bulk_with_proration_config")

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonProperty("metadata") @ExcludeMissing fun _metadata() = metadata

            /** An alias for the price. */
            @JsonProperty("external_price_id")
            @ExcludeMissing
            fun _externalPriceId() = externalPriceId

            /** The name of the price. */
            @JsonProperty("name") @ExcludeMissing fun _name() = name

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            @JsonProperty("billable_metric_id")
            @ExcludeMissing
            fun _billableMetricId() = billableMetricId

            /** The id of the item the plan will be associated with. */
            @JsonProperty("item_id") @ExcludeMissing fun _itemId() = itemId

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @JsonProperty("billed_in_advance")
            @ExcludeMissing
            fun _billedInAdvance() = billedInAdvance

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fun _fixedPriceQuantity() = fixedPriceQuantity

            /** The property used to group this price on an invoice */
            @JsonProperty("invoice_grouping_key")
            @ExcludeMissing
            fun _invoiceGroupingKey() = invoiceGroupingKey

            /** The cadence to bill for this price on. */
            @JsonProperty("cadence") @ExcludeMissing fun _cadence() = cadence

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            fun _billingCycleConfiguration() = billingCycleConfiguration

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            fun _invoicingCycleConfiguration() = invoicingCycleConfiguration

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @JsonProperty("conversion_rate") @ExcludeMissing fun _conversionRate() = conversionRate

            @JsonProperty("model_type") @ExcludeMissing fun _modelType() = modelType

            @JsonProperty("bulk_with_proration_config")
            @ExcludeMissing
            fun _bulkWithProrationConfig() = bulkWithProrationConfig

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency() = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): NewPlanBulkWithProrationPrice = apply {
                if (!validated) {
                    metadata().map { it.validate() }
                    externalPriceId()
                    name()
                    billableMetricId()
                    itemId()
                    billedInAdvance()
                    fixedPriceQuantity()
                    invoiceGroupingKey()
                    cadence()
                    billingCycleConfiguration().map { it.validate() }
                    invoicingCycleConfiguration().map { it.validate() }
                    conversionRate()
                    modelType()
                    bulkWithProrationConfig().validate()
                    currency()
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var metadata: JsonField<Metadata> = JsonMissing.of()
                private var externalPriceId: JsonField<String> = JsonMissing.of()
                private var name: JsonField<String> = JsonMissing.of()
                private var billableMetricId: JsonField<String> = JsonMissing.of()
                private var itemId: JsonField<String> = JsonMissing.of()
                private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
                private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
                private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
                private var cadence: JsonField<Cadence> = JsonMissing.of()
                private var billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
                    JsonMissing.of()
                private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
                    JsonMissing.of()
                private var conversionRate: JsonField<Double> = JsonMissing.of()
                private var modelType: JsonField<ModelType> = JsonMissing.of()
                private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig> =
                    JsonMissing.of()
                private var currency: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(newPlanBulkWithProrationPrice: NewPlanBulkWithProrationPrice) =
                    apply {
                        this.metadata = newPlanBulkWithProrationPrice.metadata
                        this.externalPriceId = newPlanBulkWithProrationPrice.externalPriceId
                        this.name = newPlanBulkWithProrationPrice.name
                        this.billableMetricId = newPlanBulkWithProrationPrice.billableMetricId
                        this.itemId = newPlanBulkWithProrationPrice.itemId
                        this.billedInAdvance = newPlanBulkWithProrationPrice.billedInAdvance
                        this.fixedPriceQuantity = newPlanBulkWithProrationPrice.fixedPriceQuantity
                        this.invoiceGroupingKey = newPlanBulkWithProrationPrice.invoiceGroupingKey
                        this.cadence = newPlanBulkWithProrationPrice.cadence
                        this.billingCycleConfiguration =
                            newPlanBulkWithProrationPrice.billingCycleConfiguration
                        this.invoicingCycleConfiguration =
                            newPlanBulkWithProrationPrice.invoicingCycleConfiguration
                        this.conversionRate = newPlanBulkWithProrationPrice.conversionRate
                        this.modelType = newPlanBulkWithProrationPrice.modelType
                        this.bulkWithProrationConfig =
                            newPlanBulkWithProrationPrice.bulkWithProrationConfig
                        this.currency = newPlanBulkWithProrationPrice.currency
                        additionalProperties(newPlanBulkWithProrationPrice.additionalProperties)
                    }

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

                /**
                 * User-specified key/value pairs for the resource. Individual keys can be removed
                 * by setting the value to `null`, and the entire metadata mapping can be cleared by
                 * setting `metadata` to `null`.
                 */
                @JsonProperty("metadata")
                @ExcludeMissing
                fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

                /** An alias for the price. */
                fun externalPriceId(externalPriceId: String) =
                    externalPriceId(JsonField.of(externalPriceId))

                /** An alias for the price. */
                @JsonProperty("external_price_id")
                @ExcludeMissing
                fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                    this.externalPriceId = externalPriceId
                }

                /** The name of the price. */
                fun name(name: String) = name(JsonField.of(name))

                /** The name of the price. */
                @JsonProperty("name")
                @ExcludeMissing
                fun name(name: JsonField<String>) = apply { this.name = name }

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                fun billableMetricId(billableMetricId: String) =
                    billableMetricId(JsonField.of(billableMetricId))

                /**
                 * The id of the billable metric for the price. Only needed if the price is
                 * usage-based.
                 */
                @JsonProperty("billable_metric_id")
                @ExcludeMissing
                fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                    this.billableMetricId = billableMetricId
                }

                /** The id of the item the plan will be associated with. */
                fun itemId(itemId: String) = itemId(JsonField.of(itemId))

                /** The id of the item the plan will be associated with. */
                @JsonProperty("item_id")
                @ExcludeMissing
                fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                fun billedInAdvance(billedInAdvance: Boolean) =
                    billedInAdvance(JsonField.of(billedInAdvance))

                /**
                 * If the Price represents a fixed cost, the price will be billed in-advance if this
                 * is true, and in-arrears if this is false.
                 */
                @JsonProperty("billed_in_advance")
                @ExcludeMissing
                fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                    this.billedInAdvance = billedInAdvance
                }

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                    fixedPriceQuantity(JsonField.of(fixedPriceQuantity))

                /**
                 * If the Price represents a fixed cost, this represents the quantity of units
                 * applied.
                 */
                @JsonProperty("fixed_price_quantity")
                @ExcludeMissing
                fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                    this.fixedPriceQuantity = fixedPriceQuantity
                }

                /** The property used to group this price on an invoice */
                fun invoiceGroupingKey(invoiceGroupingKey: String) =
                    invoiceGroupingKey(JsonField.of(invoiceGroupingKey))

                /** The property used to group this price on an invoice */
                @JsonProperty("invoice_grouping_key")
                @ExcludeMissing
                fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                    this.invoiceGroupingKey = invoiceGroupingKey
                }

                /** The cadence to bill for this price on. */
                fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

                /** The cadence to bill for this price on. */
                @JsonProperty("cadence")
                @ExcludeMissing
                fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                fun billingCycleConfiguration(
                    billingCycleConfiguration: BillingCycleConfiguration
                ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

                /**
                 * For custom cadence: specifies the duration of the billing period in days or
                 * months.
                 */
                @JsonProperty("billing_cycle_configuration")
                @ExcludeMissing
                fun billingCycleConfiguration(
                    billingCycleConfiguration: JsonField<BillingCycleConfiguration>
                ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: InvoicingCycleConfiguration
                ) = invoicingCycleConfiguration(JsonField.of(invoicingCycleConfiguration))

                /**
                 * Within each billing cycle, specifies the cadence at which invoices are produced.
                 * If unspecified, a single invoice is produced per billing cycle.
                 */
                @JsonProperty("invoicing_cycle_configuration")
                @ExcludeMissing
                fun invoicingCycleConfiguration(
                    invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
                ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                fun conversionRate(conversionRate: Double) =
                    conversionRate(JsonField.of(conversionRate))

                /** The per unit conversion rate of the price currency to the invoicing currency. */
                @JsonProperty("conversion_rate")
                @ExcludeMissing
                fun conversionRate(conversionRate: JsonField<Double>) = apply {
                    this.conversionRate = conversionRate
                }

                fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

                @JsonProperty("model_type")
                @ExcludeMissing
                fun modelType(modelType: JsonField<ModelType>) = apply {
                    this.modelType = modelType
                }

                fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                    bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

                @JsonProperty("bulk_with_proration_config")
                @ExcludeMissing
                fun bulkWithProrationConfig(
                    bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
                ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * An ISO 4217 currency string, or custom pricing unit identifier, in which this
                 * price is billed.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): NewPlanBulkWithProrationPrice =
                    NewPlanBulkWithProrationPrice(
                        metadata,
                        externalPriceId,
                        name,
                        billableMetricId,
                        itemId,
                        billedInAdvance,
                        fixedPriceQuantity,
                        invoiceGroupingKey,
                        cadence,
                        billingCycleConfiguration,
                        invoicingCycleConfiguration,
                        conversionRate,
                        modelType,
                        bulkWithProrationConfig,
                        currency,
                        additionalProperties.toImmutable(),
                    )
            }

            @JsonDeserialize(builder = BulkWithProrationConfig.Builder::class)
            @NoAutoDetect
            class BulkWithProrationConfig
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BulkWithProrationConfig = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                        additionalProperties(bulkWithProrationConfig.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BulkWithProrationConfig =
                        BulkWithProrationConfig(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BulkWithProrationConfig && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BulkWithProrationConfig{additionalProperties=$additionalProperties}"
            }

            class Cadence
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Cadence && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField val ANNUAL = Cadence(JsonField.of("annual"))

                    @JvmField val SEMI_ANNUAL = Cadence(JsonField.of("semi_annual"))

                    @JvmField val MONTHLY = Cadence(JsonField.of("monthly"))

                    @JvmField val QUARTERLY = Cadence(JsonField.of("quarterly"))

                    @JvmField val ONE_TIME = Cadence(JsonField.of("one_time"))

                    @JvmField val CUSTOM = Cadence(JsonField.of("custom"))

                    @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
                }

                enum class Known {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                }

                enum class Value {
                    ANNUAL,
                    SEMI_ANNUAL,
                    MONTHLY,
                    QUARTERLY,
                    ONE_TIME,
                    CUSTOM,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        ANNUAL -> Value.ANNUAL
                        SEMI_ANNUAL -> Value.SEMI_ANNUAL
                        MONTHLY -> Value.MONTHLY
                        QUARTERLY -> Value.QUARTERLY
                        ONE_TIME -> Value.ONE_TIME
                        CUSTOM -> Value.CUSTOM
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        ANNUAL -> Known.ANNUAL
                        SEMI_ANNUAL -> Known.SEMI_ANNUAL
                        MONTHLY -> Known.MONTHLY
                        QUARTERLY -> Known.QUARTERLY
                        ONE_TIME -> Known.ONE_TIME
                        CUSTOM -> Known.CUSTOM
                        else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            class ModelType
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is ModelType && this.value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()

                companion object {

                    @JvmField
                    val BULK_WITH_PRORATION = ModelType(JsonField.of("bulk_with_proration"))

                    @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
                }

                enum class Known {
                    BULK_WITH_PRORATION,
                }

                enum class Value {
                    BULK_WITH_PRORATION,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                        else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            @JsonDeserialize(builder = BillingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class BillingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): BillingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(billingCycleConfiguration: BillingCycleConfiguration) =
                        apply {
                            this.duration = billingCycleConfiguration.duration
                            this.durationUnit = billingCycleConfiguration.durationUnit
                            additionalProperties(billingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): BillingCycleConfiguration =
                        BillingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is BillingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            @JsonDeserialize(builder = InvoicingCycleConfiguration.Builder::class)
            @NoAutoDetect
            class InvoicingCycleConfiguration
            private constructor(
                private val duration: JsonField<Long>,
                private val durationUnit: JsonField<DurationUnit>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                /** The duration of the billing period. */
                fun duration(): Long = duration.getRequired("duration")

                /** The unit of billing period duration. */
                fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

                /** The duration of the billing period. */
                @JsonProperty("duration") @ExcludeMissing fun _duration() = duration

                /** The unit of billing period duration. */
                @JsonProperty("duration_unit") @ExcludeMissing fun _durationUnit() = durationUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): InvoicingCycleConfiguration = apply {
                    if (!validated) {
                        duration()
                        durationUnit()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var duration: JsonField<Long> = JsonMissing.of()
                    private var durationUnit: JsonField<DurationUnit> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                        apply {
                            this.duration = invoicingCycleConfiguration.duration
                            this.durationUnit = invoicingCycleConfiguration.durationUnit
                            additionalProperties(invoicingCycleConfiguration.additionalProperties)
                        }

                    /** The duration of the billing period. */
                    fun duration(duration: Long) = duration(JsonField.of(duration))

                    /** The duration of the billing period. */
                    @JsonProperty("duration")
                    @ExcludeMissing
                    fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                    /** The unit of billing period duration. */
                    fun durationUnit(durationUnit: DurationUnit) =
                        durationUnit(JsonField.of(durationUnit))

                    /** The unit of billing period duration. */
                    @JsonProperty("duration_unit")
                    @ExcludeMissing
                    fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                        this.durationUnit = durationUnit
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): InvoicingCycleConfiguration =
                        InvoicingCycleConfiguration(
                            duration,
                            durationUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                class DurationUnit
                @JsonCreator
                private constructor(
                    private val value: JsonField<String>,
                ) : Enum {

                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return /* spotless:off */ other is DurationUnit && this.value == other.value /* spotless:on */
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()

                    companion object {

                        @JvmField val DAY = DurationUnit(JsonField.of("day"))

                        @JvmField val MONTH = DurationUnit(JsonField.of("month"))

                        @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                    }

                    enum class Known {
                        DAY,
                        MONTH,
                    }

                    enum class Value {
                        DAY,
                        MONTH,
                        _UNKNOWN,
                    }

                    fun value(): Value =
                        when (this) {
                            DAY -> Value.DAY
                            MONTH -> Value.MONTH
                            else -> Value._UNKNOWN
                        }

                    fun known(): Known =
                        when (this) {
                            DAY -> Known.DAY
                            MONTH -> Known.MONTH
                            else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                        }

                    fun asString(): String = _value().asStringOrThrow()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is InvoicingCycleConfiguration && this.duration == other.duration && this.durationUnit == other.durationUnit && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(duration, durationUnit, additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() =
                    "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
            }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            @JsonDeserialize(builder = Metadata.Builder::class)
            @NoAutoDetect
            class Metadata
            private constructor(
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): Metadata = apply {
                    if (!validated) {
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(metadata: Metadata) = apply {
                        additionalProperties(metadata.additionalProperties)
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): Metadata = Metadata(additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
                }

                private var hashCode: Int = 0

                override fun hashCode(): Int {
                    if (hashCode == 0) {
                        hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
                    }
                    return hashCode
                }

                override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is NewPlanBulkWithProrationPrice && this.metadata == other.metadata && this.externalPriceId == other.externalPriceId && this.name == other.name && this.billableMetricId == other.billableMetricId && this.itemId == other.itemId && this.billedInAdvance == other.billedInAdvance && this.fixedPriceQuantity == other.fixedPriceQuantity && this.invoiceGroupingKey == other.invoiceGroupingKey && this.cadence == other.cadence && this.billingCycleConfiguration == other.billingCycleConfiguration && this.invoicingCycleConfiguration == other.invoicingCycleConfiguration && this.conversionRate == other.conversionRate && this.modelType == other.modelType && this.bulkWithProrationConfig == other.bulkWithProrationConfig && this.currency == other.currency && this.additionalProperties == other.additionalProperties /* spotless:on */
            }

            private var hashCode: Int = 0

            override fun hashCode(): Int {
                if (hashCode == 0) {
                    hashCode = /* spotless:off */ Objects.hash(metadata, externalPriceId, name, billableMetricId, itemId, billedInAdvance, fixedPriceQuantity, invoiceGroupingKey, cadence, billingCycleConfiguration, invoicingCycleConfiguration, conversionRate, modelType, bulkWithProrationConfig, currency, additionalProperties) /* spotless:on */
                }
                return hashCode
            }

            override fun toString() =
                "NewPlanBulkWithProrationPrice{metadata=$metadata, externalPriceId=$externalPriceId, name=$name, billableMetricId=$billableMetricId, itemId=$itemId, billedInAdvance=$billedInAdvance, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, cadence=$cadence, billingCycleConfiguration=$billingCycleConfiguration, invoicingCycleConfiguration=$invoicingCycleConfiguration, conversionRate=$conversionRate, modelType=$modelType, bulkWithProrationConfig=$bulkWithProrationConfig, currency=$currency, additionalProperties=$additionalProperties}"
        }
    }

    /**
     * User-specified key/value pairs for the resource. Individual keys can be removed by setting
     * the value to `null`, and the entire metadata mapping can be cleared by setting `metadata` to
     * `null`.
     */
    @JsonDeserialize(builder = Metadata.Builder::class)
    @NoAutoDetect
    class Metadata
    private constructor(
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(metadata: Metadata) = apply {
                additionalProperties(metadata.additionalProperties)
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): Metadata = Metadata(additionalProperties.toImmutable())
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Metadata && this.additionalProperties == other.additionalProperties /* spotless:on */
        }

        private var hashCode: Int = 0

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode = /* spotless:off */ Objects.hash(additionalProperties) /* spotless:on */
            }
            return hashCode
        }

        override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
    }

    class Status
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Status && this.value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            @JvmField val ACTIVE = Status(JsonField.of("active"))

            @JvmField val DRAFT = Status(JsonField.of("draft"))

            @JvmStatic fun of(value: String) = Status(JsonField.of(value))
        }

        enum class Known {
            ACTIVE,
            DRAFT,
        }

        enum class Value {
            ACTIVE,
            DRAFT,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                ACTIVE -> Value.ACTIVE
                DRAFT -> Value.DRAFT
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                ACTIVE -> Known.ACTIVE
                DRAFT -> Known.DRAFT
                else -> throw OrbInvalidDataException("Unknown Status: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }
}
