// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

@JsonDeserialize(using = NewSubscriptionPriceModel.Deserializer::class)
@JsonSerialize(using = NewSubscriptionPriceModel.Serializer::class)
class NewSubscriptionPriceModel
private constructor(
    private val unitPrice: NewSubscriptionUnitPrice? = null,
    private val packagePrice: NewSubscriptionPackagePrice? = null,
    private val matrixPrice: NewSubscriptionMatrixPrice? = null,
    private val tieredPrice: NewSubscriptionTieredPrice? = null,
    private val tieredBpsPrice: NewSubscriptionTieredBpsPrice? = null,
    private val bpsPrice: NewSubscriptionBpsPrice? = null,
    private val bulkBpsPrice: NewSubscriptionBulkBpsPrice? = null,
    private val bulkPrice: NewSubscriptionBulkPrice? = null,
    private val thresholdTotalAmountPrice: NewSubscriptionThresholdTotalAmountPrice? = null,
    private val tieredPackagePrice: NewSubscriptionTieredPackagePrice? = null,
    private val tieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice? = null,
    private val unitWithPercentPrice: NewSubscriptionUnitWithPercentPrice? = null,
    private val packageWithAllocationPrice: NewSubscriptionPackageWithAllocationPrice? = null,
    private val tierWithProrationPrice: NewSubscriptionTierWithProrationPrice? = null,
    private val unitWithProrationPrice: NewSubscriptionUnitWithProrationPrice? = null,
    private val groupedAllocationPrice: NewSubscriptionGroupedAllocationPrice? = null,
    private val groupedWithProratedMinimumPrice: NewSubscriptionGroupedWithProratedMinimumPrice? =
        null,
    private val bulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice? = null,
    private val scalableMatrixWithUnitPricingPrice:
        NewSubscriptionScalableMatrixWithUnitPricingPrice? =
        null,
    private val scalableMatrixWithTieredPricingPrice:
        NewSubscriptionScalableMatrixWithTieredPricingPrice? =
        null,
    private val cumulativeGroupedBulkPrice: NewSubscriptionCumulativeGroupedBulkPrice? = null,
    private val maxGroupTieredPackagePrice: NewSubscriptionMaxGroupTieredPackagePrice? = null,
    private val groupedWithMeteredMinimumPrice: NewSubscriptionGroupedWithMeteredMinimumPrice? =
        null,
    private val matrixWithDisplayNamePrice: NewSubscriptionMatrixWithDisplayNamePrice? = null,
    private val groupedTieredPackagePrice: NewSubscriptionGroupedTieredPackagePrice? = null,
    private val _json: JsonValue? = null,
) {

    fun unitPrice(): Optional<NewSubscriptionUnitPrice> = Optional.ofNullable(unitPrice)

    fun packagePrice(): Optional<NewSubscriptionPackagePrice> = Optional.ofNullable(packagePrice)

    fun matrixPrice(): Optional<NewSubscriptionMatrixPrice> = Optional.ofNullable(matrixPrice)

    fun tieredPrice(): Optional<NewSubscriptionTieredPrice> = Optional.ofNullable(tieredPrice)

    fun tieredBpsPrice(): Optional<NewSubscriptionTieredBpsPrice> =
        Optional.ofNullable(tieredBpsPrice)

    fun bpsPrice(): Optional<NewSubscriptionBpsPrice> = Optional.ofNullable(bpsPrice)

    fun bulkBpsPrice(): Optional<NewSubscriptionBulkBpsPrice> = Optional.ofNullable(bulkBpsPrice)

    fun bulkPrice(): Optional<NewSubscriptionBulkPrice> = Optional.ofNullable(bulkPrice)

    fun thresholdTotalAmountPrice(): Optional<NewSubscriptionThresholdTotalAmountPrice> =
        Optional.ofNullable(thresholdTotalAmountPrice)

    fun tieredPackagePrice(): Optional<NewSubscriptionTieredPackagePrice> =
        Optional.ofNullable(tieredPackagePrice)

    fun tieredWithMinimumPrice(): Optional<NewSubscriptionTieredWithMinimumPrice> =
        Optional.ofNullable(tieredWithMinimumPrice)

    fun unitWithPercentPrice(): Optional<NewSubscriptionUnitWithPercentPrice> =
        Optional.ofNullable(unitWithPercentPrice)

    fun packageWithAllocationPrice(): Optional<NewSubscriptionPackageWithAllocationPrice> =
        Optional.ofNullable(packageWithAllocationPrice)

    fun tierWithProrationPrice(): Optional<NewSubscriptionTierWithProrationPrice> =
        Optional.ofNullable(tierWithProrationPrice)

    fun unitWithProrationPrice(): Optional<NewSubscriptionUnitWithProrationPrice> =
        Optional.ofNullable(unitWithProrationPrice)

    fun groupedAllocationPrice(): Optional<NewSubscriptionGroupedAllocationPrice> =
        Optional.ofNullable(groupedAllocationPrice)

    fun groupedWithProratedMinimumPrice():
        Optional<NewSubscriptionGroupedWithProratedMinimumPrice> =
        Optional.ofNullable(groupedWithProratedMinimumPrice)

    fun bulkWithProrationPrice(): Optional<NewSubscriptionBulkWithProrationPrice> =
        Optional.ofNullable(bulkWithProrationPrice)

    fun scalableMatrixWithUnitPricingPrice():
        Optional<NewSubscriptionScalableMatrixWithUnitPricingPrice> =
        Optional.ofNullable(scalableMatrixWithUnitPricingPrice)

    fun scalableMatrixWithTieredPricingPrice():
        Optional<NewSubscriptionScalableMatrixWithTieredPricingPrice> =
        Optional.ofNullable(scalableMatrixWithTieredPricingPrice)

    fun cumulativeGroupedBulkPrice(): Optional<NewSubscriptionCumulativeGroupedBulkPrice> =
        Optional.ofNullable(cumulativeGroupedBulkPrice)

    fun maxGroupTieredPackagePrice(): Optional<NewSubscriptionMaxGroupTieredPackagePrice> =
        Optional.ofNullable(maxGroupTieredPackagePrice)

    fun groupedWithMeteredMinimumPrice(): Optional<NewSubscriptionGroupedWithMeteredMinimumPrice> =
        Optional.ofNullable(groupedWithMeteredMinimumPrice)

    fun matrixWithDisplayNamePrice(): Optional<NewSubscriptionMatrixWithDisplayNamePrice> =
        Optional.ofNullable(matrixWithDisplayNamePrice)

    fun groupedTieredPackagePrice(): Optional<NewSubscriptionGroupedTieredPackagePrice> =
        Optional.ofNullable(groupedTieredPackagePrice)

    fun isUnitPrice(): Boolean = unitPrice != null

    fun isPackagePrice(): Boolean = packagePrice != null

    fun isMatrixPrice(): Boolean = matrixPrice != null

    fun isTieredPrice(): Boolean = tieredPrice != null

    fun isTieredBpsPrice(): Boolean = tieredBpsPrice != null

    fun isBpsPrice(): Boolean = bpsPrice != null

    fun isBulkBpsPrice(): Boolean = bulkBpsPrice != null

    fun isBulkPrice(): Boolean = bulkPrice != null

    fun isThresholdTotalAmountPrice(): Boolean = thresholdTotalAmountPrice != null

    fun isTieredPackagePrice(): Boolean = tieredPackagePrice != null

    fun isTieredWithMinimumPrice(): Boolean = tieredWithMinimumPrice != null

    fun isUnitWithPercentPrice(): Boolean = unitWithPercentPrice != null

    fun isPackageWithAllocationPrice(): Boolean = packageWithAllocationPrice != null

    fun isTierWithProrationPrice(): Boolean = tierWithProrationPrice != null

    fun isUnitWithProrationPrice(): Boolean = unitWithProrationPrice != null

    fun isGroupedAllocationPrice(): Boolean = groupedAllocationPrice != null

    fun isGroupedWithProratedMinimumPrice(): Boolean = groupedWithProratedMinimumPrice != null

    fun isBulkWithProrationPrice(): Boolean = bulkWithProrationPrice != null

    fun isScalableMatrixWithUnitPricingPrice(): Boolean = scalableMatrixWithUnitPricingPrice != null

    fun isScalableMatrixWithTieredPricingPrice(): Boolean =
        scalableMatrixWithTieredPricingPrice != null

    fun isCumulativeGroupedBulkPrice(): Boolean = cumulativeGroupedBulkPrice != null

    fun isMaxGroupTieredPackagePrice(): Boolean = maxGroupTieredPackagePrice != null

    fun isGroupedWithMeteredMinimumPrice(): Boolean = groupedWithMeteredMinimumPrice != null

    fun isMatrixWithDisplayNamePrice(): Boolean = matrixWithDisplayNamePrice != null

    fun isGroupedTieredPackagePrice(): Boolean = groupedTieredPackagePrice != null

    fun asUnitPrice(): NewSubscriptionUnitPrice = unitPrice.getOrThrow("unitPrice")

    fun asPackagePrice(): NewSubscriptionPackagePrice = packagePrice.getOrThrow("packagePrice")

    fun asMatrixPrice(): NewSubscriptionMatrixPrice = matrixPrice.getOrThrow("matrixPrice")

    fun asTieredPrice(): NewSubscriptionTieredPrice = tieredPrice.getOrThrow("tieredPrice")

    fun asTieredBpsPrice(): NewSubscriptionTieredBpsPrice =
        tieredBpsPrice.getOrThrow("tieredBpsPrice")

    fun asBpsPrice(): NewSubscriptionBpsPrice = bpsPrice.getOrThrow("bpsPrice")

    fun asBulkBpsPrice(): NewSubscriptionBulkBpsPrice = bulkBpsPrice.getOrThrow("bulkBpsPrice")

    fun asBulkPrice(): NewSubscriptionBulkPrice = bulkPrice.getOrThrow("bulkPrice")

    fun asThresholdTotalAmountPrice(): NewSubscriptionThresholdTotalAmountPrice =
        thresholdTotalAmountPrice.getOrThrow("thresholdTotalAmountPrice")

    fun asTieredPackagePrice(): NewSubscriptionTieredPackagePrice =
        tieredPackagePrice.getOrThrow("tieredPackagePrice")

    fun asTieredWithMinimumPrice(): NewSubscriptionTieredWithMinimumPrice =
        tieredWithMinimumPrice.getOrThrow("tieredWithMinimumPrice")

    fun asUnitWithPercentPrice(): NewSubscriptionUnitWithPercentPrice =
        unitWithPercentPrice.getOrThrow("unitWithPercentPrice")

    fun asPackageWithAllocationPrice(): NewSubscriptionPackageWithAllocationPrice =
        packageWithAllocationPrice.getOrThrow("packageWithAllocationPrice")

    fun asTierWithProrationPrice(): NewSubscriptionTierWithProrationPrice =
        tierWithProrationPrice.getOrThrow("tierWithProrationPrice")

    fun asUnitWithProrationPrice(): NewSubscriptionUnitWithProrationPrice =
        unitWithProrationPrice.getOrThrow("unitWithProrationPrice")

    fun asGroupedAllocationPrice(): NewSubscriptionGroupedAllocationPrice =
        groupedAllocationPrice.getOrThrow("groupedAllocationPrice")

    fun asGroupedWithProratedMinimumPrice(): NewSubscriptionGroupedWithProratedMinimumPrice =
        groupedWithProratedMinimumPrice.getOrThrow("groupedWithProratedMinimumPrice")

    fun asBulkWithProrationPrice(): NewSubscriptionBulkWithProrationPrice =
        bulkWithProrationPrice.getOrThrow("bulkWithProrationPrice")

    fun asScalableMatrixWithUnitPricingPrice(): NewSubscriptionScalableMatrixWithUnitPricingPrice =
        scalableMatrixWithUnitPricingPrice.getOrThrow("scalableMatrixWithUnitPricingPrice")

    fun asScalableMatrixWithTieredPricingPrice():
        NewSubscriptionScalableMatrixWithTieredPricingPrice =
        scalableMatrixWithTieredPricingPrice.getOrThrow("scalableMatrixWithTieredPricingPrice")

    fun asCumulativeGroupedBulkPrice(): NewSubscriptionCumulativeGroupedBulkPrice =
        cumulativeGroupedBulkPrice.getOrThrow("cumulativeGroupedBulkPrice")

    fun asMaxGroupTieredPackagePrice(): NewSubscriptionMaxGroupTieredPackagePrice =
        maxGroupTieredPackagePrice.getOrThrow("maxGroupTieredPackagePrice")

    fun asGroupedWithMeteredMinimumPrice(): NewSubscriptionGroupedWithMeteredMinimumPrice =
        groupedWithMeteredMinimumPrice.getOrThrow("groupedWithMeteredMinimumPrice")

    fun asMatrixWithDisplayNamePrice(): NewSubscriptionMatrixWithDisplayNamePrice =
        matrixWithDisplayNamePrice.getOrThrow("matrixWithDisplayNamePrice")

    fun asGroupedTieredPackagePrice(): NewSubscriptionGroupedTieredPackagePrice =
        groupedTieredPackagePrice.getOrThrow("groupedTieredPackagePrice")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T {
        return when {
            unitPrice != null -> visitor.visitUnitPrice(unitPrice)
            packagePrice != null -> visitor.visitPackagePrice(packagePrice)
            matrixPrice != null -> visitor.visitMatrixPrice(matrixPrice)
            tieredPrice != null -> visitor.visitTieredPrice(tieredPrice)
            tieredBpsPrice != null -> visitor.visitTieredBpsPrice(tieredBpsPrice)
            bpsPrice != null -> visitor.visitBpsPrice(bpsPrice)
            bulkBpsPrice != null -> visitor.visitBulkBpsPrice(bulkBpsPrice)
            bulkPrice != null -> visitor.visitBulkPrice(bulkPrice)
            thresholdTotalAmountPrice != null ->
                visitor.visitThresholdTotalAmountPrice(thresholdTotalAmountPrice)
            tieredPackagePrice != null -> visitor.visitTieredPackagePrice(tieredPackagePrice)
            tieredWithMinimumPrice != null ->
                visitor.visitTieredWithMinimumPrice(tieredWithMinimumPrice)
            unitWithPercentPrice != null -> visitor.visitUnitWithPercentPrice(unitWithPercentPrice)
            packageWithAllocationPrice != null ->
                visitor.visitPackageWithAllocationPrice(packageWithAllocationPrice)
            tierWithProrationPrice != null ->
                visitor.visitTierWithProrationPrice(tierWithProrationPrice)
            unitWithProrationPrice != null ->
                visitor.visitUnitWithProrationPrice(unitWithProrationPrice)
            groupedAllocationPrice != null ->
                visitor.visitGroupedAllocationPrice(groupedAllocationPrice)
            groupedWithProratedMinimumPrice != null ->
                visitor.visitGroupedWithProratedMinimumPrice(groupedWithProratedMinimumPrice)
            bulkWithProrationPrice != null ->
                visitor.visitBulkWithProrationPrice(bulkWithProrationPrice)
            scalableMatrixWithUnitPricingPrice != null ->
                visitor.visitScalableMatrixWithUnitPricingPrice(scalableMatrixWithUnitPricingPrice)
            scalableMatrixWithTieredPricingPrice != null ->
                visitor.visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice
                )
            cumulativeGroupedBulkPrice != null ->
                visitor.visitCumulativeGroupedBulkPrice(cumulativeGroupedBulkPrice)
            maxGroupTieredPackagePrice != null ->
                visitor.visitMaxGroupTieredPackagePrice(maxGroupTieredPackagePrice)
            groupedWithMeteredMinimumPrice != null ->
                visitor.visitGroupedWithMeteredMinimumPrice(groupedWithMeteredMinimumPrice)
            matrixWithDisplayNamePrice != null ->
                visitor.visitMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice)
            groupedTieredPackagePrice != null ->
                visitor.visitGroupedTieredPackagePrice(groupedTieredPackagePrice)
            else -> visitor.unknown(_json)
        }
    }

    private var validated: Boolean = false

    fun validate(): NewSubscriptionPriceModel = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnitPrice(unitPrice: NewSubscriptionUnitPrice) {
                    unitPrice.validate()
                }

                override fun visitPackagePrice(packagePrice: NewSubscriptionPackagePrice) {
                    packagePrice.validate()
                }

                override fun visitMatrixPrice(matrixPrice: NewSubscriptionMatrixPrice) {
                    matrixPrice.validate()
                }

                override fun visitTieredPrice(tieredPrice: NewSubscriptionTieredPrice) {
                    tieredPrice.validate()
                }

                override fun visitTieredBpsPrice(tieredBpsPrice: NewSubscriptionTieredBpsPrice) {
                    tieredBpsPrice.validate()
                }

                override fun visitBpsPrice(bpsPrice: NewSubscriptionBpsPrice) {
                    bpsPrice.validate()
                }

                override fun visitBulkBpsPrice(bulkBpsPrice: NewSubscriptionBulkBpsPrice) {
                    bulkBpsPrice.validate()
                }

                override fun visitBulkPrice(bulkPrice: NewSubscriptionBulkPrice) {
                    bulkPrice.validate()
                }

                override fun visitThresholdTotalAmountPrice(
                    thresholdTotalAmountPrice: NewSubscriptionThresholdTotalAmountPrice
                ) {
                    thresholdTotalAmountPrice.validate()
                }

                override fun visitTieredPackagePrice(
                    tieredPackagePrice: NewSubscriptionTieredPackagePrice
                ) {
                    tieredPackagePrice.validate()
                }

                override fun visitTieredWithMinimumPrice(
                    tieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
                ) {
                    tieredWithMinimumPrice.validate()
                }

                override fun visitUnitWithPercentPrice(
                    unitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
                ) {
                    unitWithPercentPrice.validate()
                }

                override fun visitPackageWithAllocationPrice(
                    packageWithAllocationPrice: NewSubscriptionPackageWithAllocationPrice
                ) {
                    packageWithAllocationPrice.validate()
                }

                override fun visitTierWithProrationPrice(
                    tierWithProrationPrice: NewSubscriptionTierWithProrationPrice
                ) {
                    tierWithProrationPrice.validate()
                }

                override fun visitUnitWithProrationPrice(
                    unitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
                ) {
                    unitWithProrationPrice.validate()
                }

                override fun visitGroupedAllocationPrice(
                    groupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
                ) {
                    groupedAllocationPrice.validate()
                }

                override fun visitGroupedWithProratedMinimumPrice(
                    groupedWithProratedMinimumPrice: NewSubscriptionGroupedWithProratedMinimumPrice
                ) {
                    groupedWithProratedMinimumPrice.validate()
                }

                override fun visitBulkWithProrationPrice(
                    bulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
                ) {
                    bulkWithProrationPrice.validate()
                }

                override fun visitScalableMatrixWithUnitPricingPrice(
                    scalableMatrixWithUnitPricingPrice:
                        NewSubscriptionScalableMatrixWithUnitPricingPrice
                ) {
                    scalableMatrixWithUnitPricingPrice.validate()
                }

                override fun visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice:
                        NewSubscriptionScalableMatrixWithTieredPricingPrice
                ) {
                    scalableMatrixWithTieredPricingPrice.validate()
                }

                override fun visitCumulativeGroupedBulkPrice(
                    cumulativeGroupedBulkPrice: NewSubscriptionCumulativeGroupedBulkPrice
                ) {
                    cumulativeGroupedBulkPrice.validate()
                }

                override fun visitMaxGroupTieredPackagePrice(
                    maxGroupTieredPackagePrice: NewSubscriptionMaxGroupTieredPackagePrice
                ) {
                    maxGroupTieredPackagePrice.validate()
                }

                override fun visitGroupedWithMeteredMinimumPrice(
                    groupedWithMeteredMinimumPrice: NewSubscriptionGroupedWithMeteredMinimumPrice
                ) {
                    groupedWithMeteredMinimumPrice.validate()
                }

                override fun visitMatrixWithDisplayNamePrice(
                    matrixWithDisplayNamePrice: NewSubscriptionMatrixWithDisplayNamePrice
                ) {
                    matrixWithDisplayNamePrice.validate()
                }

                override fun visitGroupedTieredPackagePrice(
                    groupedTieredPackagePrice: NewSubscriptionGroupedTieredPackagePrice
                ) {
                    groupedTieredPackagePrice.validate()
                }
            }
        )
        validated = true
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is NewSubscriptionPriceModel && unitPrice == other.unitPrice && packagePrice == other.packagePrice && matrixPrice == other.matrixPrice && tieredPrice == other.tieredPrice && tieredBpsPrice == other.tieredBpsPrice && bpsPrice == other.bpsPrice && bulkBpsPrice == other.bulkBpsPrice && bulkPrice == other.bulkPrice && thresholdTotalAmountPrice == other.thresholdTotalAmountPrice && tieredPackagePrice == other.tieredPackagePrice && tieredWithMinimumPrice == other.tieredWithMinimumPrice && unitWithPercentPrice == other.unitWithPercentPrice && packageWithAllocationPrice == other.packageWithAllocationPrice && tierWithProrationPrice == other.tierWithProrationPrice && unitWithProrationPrice == other.unitWithProrationPrice && groupedAllocationPrice == other.groupedAllocationPrice && groupedWithProratedMinimumPrice == other.groupedWithProratedMinimumPrice && bulkWithProrationPrice == other.bulkWithProrationPrice && scalableMatrixWithUnitPricingPrice == other.scalableMatrixWithUnitPricingPrice && scalableMatrixWithTieredPricingPrice == other.scalableMatrixWithTieredPricingPrice && cumulativeGroupedBulkPrice == other.cumulativeGroupedBulkPrice && maxGroupTieredPackagePrice == other.maxGroupTieredPackagePrice && groupedWithMeteredMinimumPrice == other.groupedWithMeteredMinimumPrice && matrixWithDisplayNamePrice == other.matrixWithDisplayNamePrice && groupedTieredPackagePrice == other.groupedTieredPackagePrice /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unitPrice, packagePrice, matrixPrice, tieredPrice, tieredBpsPrice, bpsPrice, bulkBpsPrice, bulkPrice, thresholdTotalAmountPrice, tieredPackagePrice, tieredWithMinimumPrice, unitWithPercentPrice, packageWithAllocationPrice, tierWithProrationPrice, unitWithProrationPrice, groupedAllocationPrice, groupedWithProratedMinimumPrice, bulkWithProrationPrice, scalableMatrixWithUnitPricingPrice, scalableMatrixWithTieredPricingPrice, cumulativeGroupedBulkPrice, maxGroupTieredPackagePrice, groupedWithMeteredMinimumPrice, matrixWithDisplayNamePrice, groupedTieredPackagePrice) /* spotless:on */

    override fun toString(): String =
        when {
            unitPrice != null -> "NewSubscriptionPriceModel{unitPrice=$unitPrice}"
            packagePrice != null -> "NewSubscriptionPriceModel{packagePrice=$packagePrice}"
            matrixPrice != null -> "NewSubscriptionPriceModel{matrixPrice=$matrixPrice}"
            tieredPrice != null -> "NewSubscriptionPriceModel{tieredPrice=$tieredPrice}"
            tieredBpsPrice != null -> "NewSubscriptionPriceModel{tieredBpsPrice=$tieredBpsPrice}"
            bpsPrice != null -> "NewSubscriptionPriceModel{bpsPrice=$bpsPrice}"
            bulkBpsPrice != null -> "NewSubscriptionPriceModel{bulkBpsPrice=$bulkBpsPrice}"
            bulkPrice != null -> "NewSubscriptionPriceModel{bulkPrice=$bulkPrice}"
            thresholdTotalAmountPrice != null ->
                "NewSubscriptionPriceModel{thresholdTotalAmountPrice=$thresholdTotalAmountPrice}"
            tieredPackagePrice != null ->
                "NewSubscriptionPriceModel{tieredPackagePrice=$tieredPackagePrice}"
            tieredWithMinimumPrice != null ->
                "NewSubscriptionPriceModel{tieredWithMinimumPrice=$tieredWithMinimumPrice}"
            unitWithPercentPrice != null ->
                "NewSubscriptionPriceModel{unitWithPercentPrice=$unitWithPercentPrice}"
            packageWithAllocationPrice != null ->
                "NewSubscriptionPriceModel{packageWithAllocationPrice=$packageWithAllocationPrice}"
            tierWithProrationPrice != null ->
                "NewSubscriptionPriceModel{tierWithProrationPrice=$tierWithProrationPrice}"
            unitWithProrationPrice != null ->
                "NewSubscriptionPriceModel{unitWithProrationPrice=$unitWithProrationPrice}"
            groupedAllocationPrice != null ->
                "NewSubscriptionPriceModel{groupedAllocationPrice=$groupedAllocationPrice}"
            groupedWithProratedMinimumPrice != null ->
                "NewSubscriptionPriceModel{groupedWithProratedMinimumPrice=$groupedWithProratedMinimumPrice}"
            bulkWithProrationPrice != null ->
                "NewSubscriptionPriceModel{bulkWithProrationPrice=$bulkWithProrationPrice}"
            scalableMatrixWithUnitPricingPrice != null ->
                "NewSubscriptionPriceModel{scalableMatrixWithUnitPricingPrice=$scalableMatrixWithUnitPricingPrice}"
            scalableMatrixWithTieredPricingPrice != null ->
                "NewSubscriptionPriceModel{scalableMatrixWithTieredPricingPrice=$scalableMatrixWithTieredPricingPrice}"
            cumulativeGroupedBulkPrice != null ->
                "NewSubscriptionPriceModel{cumulativeGroupedBulkPrice=$cumulativeGroupedBulkPrice}"
            maxGroupTieredPackagePrice != null ->
                "NewSubscriptionPriceModel{maxGroupTieredPackagePrice=$maxGroupTieredPackagePrice}"
            groupedWithMeteredMinimumPrice != null ->
                "NewSubscriptionPriceModel{groupedWithMeteredMinimumPrice=$groupedWithMeteredMinimumPrice}"
            matrixWithDisplayNamePrice != null ->
                "NewSubscriptionPriceModel{matrixWithDisplayNamePrice=$matrixWithDisplayNamePrice}"
            groupedTieredPackagePrice != null ->
                "NewSubscriptionPriceModel{groupedTieredPackagePrice=$groupedTieredPackagePrice}"
            _json != null -> "NewSubscriptionPriceModel{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid NewSubscriptionPriceModel")
        }

    companion object {

        @JvmStatic
        fun ofUnitPrice(unitPrice: NewSubscriptionUnitPrice) =
            NewSubscriptionPriceModel(unitPrice = unitPrice)

        @JvmStatic
        fun ofPackagePrice(packagePrice: NewSubscriptionPackagePrice) =
            NewSubscriptionPriceModel(packagePrice = packagePrice)

        @JvmStatic
        fun ofMatrixPrice(matrixPrice: NewSubscriptionMatrixPrice) =
            NewSubscriptionPriceModel(matrixPrice = matrixPrice)

        @JvmStatic
        fun ofTieredPrice(tieredPrice: NewSubscriptionTieredPrice) =
            NewSubscriptionPriceModel(tieredPrice = tieredPrice)

        @JvmStatic
        fun ofTieredBpsPrice(tieredBpsPrice: NewSubscriptionTieredBpsPrice) =
            NewSubscriptionPriceModel(tieredBpsPrice = tieredBpsPrice)

        @JvmStatic
        fun ofBpsPrice(bpsPrice: NewSubscriptionBpsPrice) =
            NewSubscriptionPriceModel(bpsPrice = bpsPrice)

        @JvmStatic
        fun ofBulkBpsPrice(bulkBpsPrice: NewSubscriptionBulkBpsPrice) =
            NewSubscriptionPriceModel(bulkBpsPrice = bulkBpsPrice)

        @JvmStatic
        fun ofBulkPrice(bulkPrice: NewSubscriptionBulkPrice) =
            NewSubscriptionPriceModel(bulkPrice = bulkPrice)

        @JvmStatic
        fun ofThresholdTotalAmountPrice(
            thresholdTotalAmountPrice: NewSubscriptionThresholdTotalAmountPrice
        ) = NewSubscriptionPriceModel(thresholdTotalAmountPrice = thresholdTotalAmountPrice)

        @JvmStatic
        fun ofTieredPackagePrice(tieredPackagePrice: NewSubscriptionTieredPackagePrice) =
            NewSubscriptionPriceModel(tieredPackagePrice = tieredPackagePrice)

        @JvmStatic
        fun ofTieredWithMinimumPrice(
            tieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
        ) = NewSubscriptionPriceModel(tieredWithMinimumPrice = tieredWithMinimumPrice)

        @JvmStatic
        fun ofUnitWithPercentPrice(unitWithPercentPrice: NewSubscriptionUnitWithPercentPrice) =
            NewSubscriptionPriceModel(unitWithPercentPrice = unitWithPercentPrice)

        @JvmStatic
        fun ofPackageWithAllocationPrice(
            packageWithAllocationPrice: NewSubscriptionPackageWithAllocationPrice
        ) = NewSubscriptionPriceModel(packageWithAllocationPrice = packageWithAllocationPrice)

        @JvmStatic
        fun ofTierWithProrationPrice(
            tierWithProrationPrice: NewSubscriptionTierWithProrationPrice
        ) = NewSubscriptionPriceModel(tierWithProrationPrice = tierWithProrationPrice)

        @JvmStatic
        fun ofUnitWithProrationPrice(
            unitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
        ) = NewSubscriptionPriceModel(unitWithProrationPrice = unitWithProrationPrice)

        @JvmStatic
        fun ofGroupedAllocationPrice(
            groupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
        ) = NewSubscriptionPriceModel(groupedAllocationPrice = groupedAllocationPrice)

        @JvmStatic
        fun ofGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: NewSubscriptionGroupedWithProratedMinimumPrice
        ) =
            NewSubscriptionPriceModel(
                groupedWithProratedMinimumPrice = groupedWithProratedMinimumPrice
            )

        @JvmStatic
        fun ofBulkWithProrationPrice(
            bulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
        ) = NewSubscriptionPriceModel(bulkWithProrationPrice = bulkWithProrationPrice)

        @JvmStatic
        fun ofScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: NewSubscriptionScalableMatrixWithUnitPricingPrice
        ) =
            NewSubscriptionPriceModel(
                scalableMatrixWithUnitPricingPrice = scalableMatrixWithUnitPricingPrice
            )

        @JvmStatic
        fun ofScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice:
                NewSubscriptionScalableMatrixWithTieredPricingPrice
        ) =
            NewSubscriptionPriceModel(
                scalableMatrixWithTieredPricingPrice = scalableMatrixWithTieredPricingPrice
            )

        @JvmStatic
        fun ofCumulativeGroupedBulkPrice(
            cumulativeGroupedBulkPrice: NewSubscriptionCumulativeGroupedBulkPrice
        ) = NewSubscriptionPriceModel(cumulativeGroupedBulkPrice = cumulativeGroupedBulkPrice)

        @JvmStatic
        fun ofMaxGroupTieredPackagePrice(
            maxGroupTieredPackagePrice: NewSubscriptionMaxGroupTieredPackagePrice
        ) = NewSubscriptionPriceModel(maxGroupTieredPackagePrice = maxGroupTieredPackagePrice)

        @JvmStatic
        fun ofGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: NewSubscriptionGroupedWithMeteredMinimumPrice
        ) =
            NewSubscriptionPriceModel(
                groupedWithMeteredMinimumPrice = groupedWithMeteredMinimumPrice
            )

        @JvmStatic
        fun ofMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: NewSubscriptionMatrixWithDisplayNamePrice
        ) = NewSubscriptionPriceModel(matrixWithDisplayNamePrice = matrixWithDisplayNamePrice)

        @JvmStatic
        fun ofGroupedTieredPackagePrice(
            groupedTieredPackagePrice: NewSubscriptionGroupedTieredPackagePrice
        ) = NewSubscriptionPriceModel(groupedTieredPackagePrice = groupedTieredPackagePrice)
    }

    /**
     * An interface that defines how to map each variant of [NewSubscriptionPriceModel] to a value
     * of type [T].
     */
    interface Visitor<out T> {

        fun visitUnitPrice(unitPrice: NewSubscriptionUnitPrice): T

        fun visitPackagePrice(packagePrice: NewSubscriptionPackagePrice): T

        fun visitMatrixPrice(matrixPrice: NewSubscriptionMatrixPrice): T

        fun visitTieredPrice(tieredPrice: NewSubscriptionTieredPrice): T

        fun visitTieredBpsPrice(tieredBpsPrice: NewSubscriptionTieredBpsPrice): T

        fun visitBpsPrice(bpsPrice: NewSubscriptionBpsPrice): T

        fun visitBulkBpsPrice(bulkBpsPrice: NewSubscriptionBulkBpsPrice): T

        fun visitBulkPrice(bulkPrice: NewSubscriptionBulkPrice): T

        fun visitThresholdTotalAmountPrice(
            thresholdTotalAmountPrice: NewSubscriptionThresholdTotalAmountPrice
        ): T

        fun visitTieredPackagePrice(tieredPackagePrice: NewSubscriptionTieredPackagePrice): T

        fun visitTieredWithMinimumPrice(
            tieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
        ): T

        fun visitUnitWithPercentPrice(unitWithPercentPrice: NewSubscriptionUnitWithPercentPrice): T

        fun visitPackageWithAllocationPrice(
            packageWithAllocationPrice: NewSubscriptionPackageWithAllocationPrice
        ): T

        fun visitTierWithProrationPrice(
            tierWithProrationPrice: NewSubscriptionTierWithProrationPrice
        ): T

        fun visitUnitWithProrationPrice(
            unitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
        ): T

        fun visitGroupedAllocationPrice(
            groupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
        ): T

        fun visitGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: NewSubscriptionGroupedWithProratedMinimumPrice
        ): T

        fun visitBulkWithProrationPrice(
            bulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
        ): T

        fun visitScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: NewSubscriptionScalableMatrixWithUnitPricingPrice
        ): T

        fun visitScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice:
                NewSubscriptionScalableMatrixWithTieredPricingPrice
        ): T

        fun visitCumulativeGroupedBulkPrice(
            cumulativeGroupedBulkPrice: NewSubscriptionCumulativeGroupedBulkPrice
        ): T

        fun visitMaxGroupTieredPackagePrice(
            maxGroupTieredPackagePrice: NewSubscriptionMaxGroupTieredPackagePrice
        ): T

        fun visitGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: NewSubscriptionGroupedWithMeteredMinimumPrice
        ): T

        fun visitMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: NewSubscriptionMatrixWithDisplayNamePrice
        ): T

        fun visitGroupedTieredPackagePrice(
            groupedTieredPackagePrice: NewSubscriptionGroupedTieredPackagePrice
        ): T

        /**
         * Maps an unknown variant of [NewSubscriptionPriceModel] to a value of type [T].
         *
         * An instance of [NewSubscriptionPriceModel] can contain an unknown variant if it was
         * deserialized from data that doesn't match any known variant. For example, if the SDK is
         * on an older version than the API, then the API may respond with new variants that the SDK
         * is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown NewSubscriptionPriceModel: $json")
        }
    }

    internal class Deserializer :
        BaseDeserializer<NewSubscriptionPriceModel>(NewSubscriptionPriceModel::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): NewSubscriptionPriceModel {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(unitPrice = it, _json = json)
                        }
                }
                "package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(packagePrice = it, _json = json)
                        }
                }
                "matrix" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionMatrixPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(matrixPrice = it, _json = json)
                        }
                }
                "tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(tieredPrice = it, _json = json)
                        }
                }
                "tiered_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(tieredBpsPrice = it, _json = json)
                        }
                }
                "bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(bpsPrice = it, _json = json)
                        }
                }
                "bulk_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkBpsPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(bulkBpsPrice = it, _json = json)
                        }
                }
                "bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(bulkPrice = it, _json = json)
                        }
                }
                "threshold_total_amount" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionThresholdTotalAmountPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                thresholdTotalAmountPrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(tieredPackagePrice = it, _json = json)
                        }
                }
                "tiered_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTieredWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                tieredWithMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "unit_with_percent" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithPercentPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                unitWithPercentPrice = it,
                                _json = json,
                            )
                        }
                }
                "package_with_allocation" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionPackageWithAllocationPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                packageWithAllocationPrice = it,
                                _json = json,
                            )
                        }
                }
                "tiered_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionTierWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                tierWithProrationPrice = it,
                                _json = json,
                            )
                        }
                }
                "unit_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionUnitWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                unitWithProrationPrice = it,
                                _json = json,
                            )
                        }
                }
                "grouped_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionGroupedAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                groupedAllocationPrice = it,
                                _json = json,
                            )
                        }
                }
                "grouped_with_prorated_minimum" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionGroupedWithProratedMinimumPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                groupedWithProratedMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "bulk_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<NewSubscriptionBulkWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                bulkWithProrationPrice = it,
                                _json = json,
                            )
                        }
                }
                "scalable_matrix_with_unit_pricing" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionScalableMatrixWithUnitPricingPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                scalableMatrixWithUnitPricingPrice = it,
                                _json = json,
                            )
                        }
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionScalableMatrixWithTieredPricingPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                scalableMatrixWithTieredPricingPrice = it,
                                _json = json,
                            )
                        }
                }
                "cumulative_grouped_bulk" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionCumulativeGroupedBulkPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                cumulativeGroupedBulkPrice = it,
                                _json = json,
                            )
                        }
                }
                "max_group_tiered_package" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionMaxGroupTieredPackagePrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                maxGroupTieredPackagePrice = it,
                                _json = json,
                            )
                        }
                }
                "grouped_with_metered_minimum" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionGroupedWithMeteredMinimumPrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                groupedWithMeteredMinimumPrice = it,
                                _json = json,
                            )
                        }
                }
                "matrix_with_display_name" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionMatrixWithDisplayNamePrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                matrixWithDisplayNamePrice = it,
                                _json = json,
                            )
                        }
                }
                "grouped_tiered_package" -> {
                    tryDeserialize(
                            node,
                            jacksonTypeRef<NewSubscriptionGroupedTieredPackagePrice>(),
                        ) {
                            it.validate()
                        }
                        ?.let {
                            return NewSubscriptionPriceModel(
                                groupedTieredPackagePrice = it,
                                _json = json,
                            )
                        }
                }
            }

            return NewSubscriptionPriceModel(_json = json)
        }
    }

    internal class Serializer :
        BaseSerializer<NewSubscriptionPriceModel>(NewSubscriptionPriceModel::class) {

        override fun serialize(
            value: NewSubscriptionPriceModel,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unitPrice != null -> generator.writeObject(value.unitPrice)
                value.packagePrice != null -> generator.writeObject(value.packagePrice)
                value.matrixPrice != null -> generator.writeObject(value.matrixPrice)
                value.tieredPrice != null -> generator.writeObject(value.tieredPrice)
                value.tieredBpsPrice != null -> generator.writeObject(value.tieredBpsPrice)
                value.bpsPrice != null -> generator.writeObject(value.bpsPrice)
                value.bulkBpsPrice != null -> generator.writeObject(value.bulkBpsPrice)
                value.bulkPrice != null -> generator.writeObject(value.bulkPrice)
                value.thresholdTotalAmountPrice != null ->
                    generator.writeObject(value.thresholdTotalAmountPrice)
                value.tieredPackagePrice != null -> generator.writeObject(value.tieredPackagePrice)
                value.tieredWithMinimumPrice != null ->
                    generator.writeObject(value.tieredWithMinimumPrice)
                value.unitWithPercentPrice != null ->
                    generator.writeObject(value.unitWithPercentPrice)
                value.packageWithAllocationPrice != null ->
                    generator.writeObject(value.packageWithAllocationPrice)
                value.tierWithProrationPrice != null ->
                    generator.writeObject(value.tierWithProrationPrice)
                value.unitWithProrationPrice != null ->
                    generator.writeObject(value.unitWithProrationPrice)
                value.groupedAllocationPrice != null ->
                    generator.writeObject(value.groupedAllocationPrice)
                value.groupedWithProratedMinimumPrice != null ->
                    generator.writeObject(value.groupedWithProratedMinimumPrice)
                value.bulkWithProrationPrice != null ->
                    generator.writeObject(value.bulkWithProrationPrice)
                value.scalableMatrixWithUnitPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricingPrice)
                value.scalableMatrixWithTieredPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricingPrice)
                value.cumulativeGroupedBulkPrice != null ->
                    generator.writeObject(value.cumulativeGroupedBulkPrice)
                value.maxGroupTieredPackagePrice != null ->
                    generator.writeObject(value.maxGroupTieredPackagePrice)
                value.groupedWithMeteredMinimumPrice != null ->
                    generator.writeObject(value.groupedWithMeteredMinimumPrice)
                value.matrixWithDisplayNamePrice != null ->
                    generator.writeObject(value.matrixWithDisplayNamePrice)
                value.groupedTieredPackagePrice != null ->
                    generator.writeObject(value.groupedTieredPackagePrice)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid NewSubscriptionPriceModel")
            }
        }
    }

    @NoAutoDetect
    class NewSubscriptionUnitPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_config")
        @ExcludeMissing
        private val unitConfig: JsonField<UnitConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitConfig(): UnitConfigModel = unitConfig.getRequired("unit_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfigModel> = unitConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionUnitPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            unitConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewSubscriptionUnitPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .unitConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionUnitPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitConfig: JsonField<UnitConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionUnitPrice: NewSubscriptionUnitPrice) = apply {
                cadence = newSubscriptionUnitPrice.cadence
                itemId = newSubscriptionUnitPrice.itemId
                modelType = newSubscriptionUnitPrice.modelType
                name = newSubscriptionUnitPrice.name
                unitConfig = newSubscriptionUnitPrice.unitConfig
                billableMetricId = newSubscriptionUnitPrice.billableMetricId
                billedInAdvance = newSubscriptionUnitPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionUnitPrice.billingCycleConfiguration
                conversionRate = newSubscriptionUnitPrice.conversionRate
                currency = newSubscriptionUnitPrice.currency
                externalPriceId = newSubscriptionUnitPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionUnitPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionUnitPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newSubscriptionUnitPrice.invoicingCycleConfiguration
                metadata = newSubscriptionUnitPrice.metadata
                referenceId = newSubscriptionUnitPrice.referenceId
                additionalProperties = newSubscriptionUnitPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitConfig(unitConfig: UnitConfigModel) = unitConfig(JsonField.of(unitConfig))

            fun unitConfig(unitConfig: JsonField<UnitConfigModel>) = apply {
                this.unitConfig = unitConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionUnitPrice =
                NewSubscriptionUnitPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitConfig", unitConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT = of("unit")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT -> Value.UNIT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT -> Known.UNIT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionUnitPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitConfig == other.unitConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionUnitPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitConfig=$unitConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_config")
        @ExcludeMissing
        private val packageConfig: JsonField<PackageConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun packageConfig(): PackageConfigModel = packageConfig.getRequired("package_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfigModel> = packageConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            packageConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .packageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionPackagePrice: NewSubscriptionPackagePrice) = apply {
                cadence = newSubscriptionPackagePrice.cadence
                itemId = newSubscriptionPackagePrice.itemId
                modelType = newSubscriptionPackagePrice.modelType
                name = newSubscriptionPackagePrice.name
                packageConfig = newSubscriptionPackagePrice.packageConfig
                billableMetricId = newSubscriptionPackagePrice.billableMetricId
                billedInAdvance = newSubscriptionPackagePrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionPackagePrice.billingCycleConfiguration
                conversionRate = newSubscriptionPackagePrice.conversionRate
                currency = newSubscriptionPackagePrice.currency
                externalPriceId = newSubscriptionPackagePrice.externalPriceId
                fixedPriceQuantity = newSubscriptionPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionPackagePrice.invoicingCycleConfiguration
                metadata = newSubscriptionPackagePrice.metadata
                referenceId = newSubscriptionPackagePrice.referenceId
                additionalProperties =
                    newSubscriptionPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfigModel) =
                packageConfig(JsonField.of(packageConfig))

            fun packageConfig(packageConfig: JsonField<PackageConfigModel>) = apply {
                this.packageConfig = packageConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionPackagePrice =
                NewSubscriptionPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE = of("package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE -> Value.PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE -> Known.PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionPackagePrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, packageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionPackagePrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, packageConfig=$packageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionMatrixPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("matrix_config")
        @ExcludeMissing
        private val matrixConfig: JsonField<MatrixConfigModel> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun matrixConfig(): MatrixConfigModel = matrixConfig.getRequired("matrix_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfigModel> = matrixConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionMatrixPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            matrixConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionMatrixPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .matrixConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionMatrixPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var matrixConfig: JsonField<MatrixConfigModel>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionMatrixPrice: NewSubscriptionMatrixPrice) = apply {
                cadence = newSubscriptionMatrixPrice.cadence
                itemId = newSubscriptionMatrixPrice.itemId
                matrixConfig = newSubscriptionMatrixPrice.matrixConfig
                modelType = newSubscriptionMatrixPrice.modelType
                name = newSubscriptionMatrixPrice.name
                billableMetricId = newSubscriptionMatrixPrice.billableMetricId
                billedInAdvance = newSubscriptionMatrixPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionMatrixPrice.billingCycleConfiguration
                conversionRate = newSubscriptionMatrixPrice.conversionRate
                currency = newSubscriptionMatrixPrice.currency
                externalPriceId = newSubscriptionMatrixPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionMatrixPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionMatrixPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newSubscriptionMatrixPrice.invoicingCycleConfiguration
                metadata = newSubscriptionMatrixPrice.metadata
                referenceId = newSubscriptionMatrixPrice.referenceId
                additionalProperties =
                    newSubscriptionMatrixPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun matrixConfig(matrixConfig: MatrixConfigModel) =
                matrixConfig(JsonField.of(matrixConfig))

            fun matrixConfig(matrixConfig: JsonField<MatrixConfigModel>) = apply {
                this.matrixConfig = matrixConfig
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionMatrixPrice =
                NewSubscriptionMatrixPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX = of("matrix")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX -> Value.MATRIX
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX -> Known.MATRIX
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionMatrixPrice && cadence == other.cadence && itemId == other.itemId && matrixConfig == other.matrixConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, matrixConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionMatrixPrice{cadence=$cadence, itemId=$itemId, matrixConfig=$matrixConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_config")
        @ExcludeMissing
        private val tieredConfig: JsonField<TieredConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredConfig(): TieredConfigModel = tieredConfig.getRequired("tiered_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfigModel> = tieredConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionTieredPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            tieredConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionTieredPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionTieredPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredConfig: JsonField<TieredConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionTieredPrice: NewSubscriptionTieredPrice) = apply {
                cadence = newSubscriptionTieredPrice.cadence
                itemId = newSubscriptionTieredPrice.itemId
                modelType = newSubscriptionTieredPrice.modelType
                name = newSubscriptionTieredPrice.name
                tieredConfig = newSubscriptionTieredPrice.tieredConfig
                billableMetricId = newSubscriptionTieredPrice.billableMetricId
                billedInAdvance = newSubscriptionTieredPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionTieredPrice.billingCycleConfiguration
                conversionRate = newSubscriptionTieredPrice.conversionRate
                currency = newSubscriptionTieredPrice.currency
                externalPriceId = newSubscriptionTieredPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionTieredPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionTieredPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newSubscriptionTieredPrice.invoicingCycleConfiguration
                metadata = newSubscriptionTieredPrice.metadata
                referenceId = newSubscriptionTieredPrice.referenceId
                additionalProperties =
                    newSubscriptionTieredPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredConfig(tieredConfig: TieredConfigModel) =
                tieredConfig(JsonField.of(tieredConfig))

            fun tieredConfig(tieredConfig: JsonField<TieredConfigModel>) = apply {
                this.tieredConfig = tieredConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionTieredPrice =
                NewSubscriptionTieredPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredConfig", tieredConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED = of("tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED -> Value.TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED -> Known.TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionTieredPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredConfig == other.tieredConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionTieredPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredConfig=$tieredConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionTieredBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        private val tieredBpsConfig: JsonField<TieredBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredBpsConfig(): TieredBpsConfigModel =
            tieredBpsConfig.getRequired("tiered_bps_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfigModel> = tieredBpsConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionTieredBpsPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            tieredBpsConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionTieredBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredBpsConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionTieredBpsPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionTieredBpsPrice: NewSubscriptionTieredBpsPrice) =
                apply {
                    cadence = newSubscriptionTieredBpsPrice.cadence
                    itemId = newSubscriptionTieredBpsPrice.itemId
                    modelType = newSubscriptionTieredBpsPrice.modelType
                    name = newSubscriptionTieredBpsPrice.name
                    tieredBpsConfig = newSubscriptionTieredBpsPrice.tieredBpsConfig
                    billableMetricId = newSubscriptionTieredBpsPrice.billableMetricId
                    billedInAdvance = newSubscriptionTieredBpsPrice.billedInAdvance
                    billingCycleConfiguration =
                        newSubscriptionTieredBpsPrice.billingCycleConfiguration
                    conversionRate = newSubscriptionTieredBpsPrice.conversionRate
                    currency = newSubscriptionTieredBpsPrice.currency
                    externalPriceId = newSubscriptionTieredBpsPrice.externalPriceId
                    fixedPriceQuantity = newSubscriptionTieredBpsPrice.fixedPriceQuantity
                    invoiceGroupingKey = newSubscriptionTieredBpsPrice.invoiceGroupingKey
                    invoicingCycleConfiguration =
                        newSubscriptionTieredBpsPrice.invoicingCycleConfiguration
                    metadata = newSubscriptionTieredBpsPrice.metadata
                    referenceId = newSubscriptionTieredBpsPrice.referenceId
                    additionalProperties =
                        newSubscriptionTieredBpsPrice.additionalProperties.toMutableMap()
                }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfigModel) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfigModel>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionTieredBpsPrice =
                NewSubscriptionTieredBpsPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_BPS = of("tiered_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_BPS -> Value.TIERED_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_BPS -> Known.TIERED_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionTieredBpsPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredBpsConfig == other.tieredBpsConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredBpsConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionTieredBpsPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredBpsConfig=$tieredBpsConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bps_config")
        @ExcludeMissing
        private val bpsConfig: JsonField<BpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bpsConfig(): BpsConfigModel = bpsConfig.getRequired("bps_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfigModel> = bpsConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionBpsPrice = apply {
            if (validated) {
                return@apply
            }

            bpsConfig().validate()
            cadence()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewSubscriptionBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .bpsConfig()
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionBpsPrice]. */
        class Builder internal constructor() {

            private var bpsConfig: JsonField<BpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionBpsPrice: NewSubscriptionBpsPrice) = apply {
                bpsConfig = newSubscriptionBpsPrice.bpsConfig
                cadence = newSubscriptionBpsPrice.cadence
                itemId = newSubscriptionBpsPrice.itemId
                modelType = newSubscriptionBpsPrice.modelType
                name = newSubscriptionBpsPrice.name
                billableMetricId = newSubscriptionBpsPrice.billableMetricId
                billedInAdvance = newSubscriptionBpsPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionBpsPrice.billingCycleConfiguration
                conversionRate = newSubscriptionBpsPrice.conversionRate
                currency = newSubscriptionBpsPrice.currency
                externalPriceId = newSubscriptionBpsPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionBpsPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionBpsPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newSubscriptionBpsPrice.invoicingCycleConfiguration
                metadata = newSubscriptionBpsPrice.metadata
                referenceId = newSubscriptionBpsPrice.referenceId
                additionalProperties = newSubscriptionBpsPrice.additionalProperties.toMutableMap()
            }

            fun bpsConfig(bpsConfig: BpsConfigModel) = bpsConfig(JsonField.of(bpsConfig))

            fun bpsConfig(bpsConfig: JsonField<BpsConfigModel>) = apply {
                this.bpsConfig = bpsConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionBpsPrice =
                NewSubscriptionBpsPrice(
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BPS = of("bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BPS -> Value.BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BPS -> Known.BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionBpsPrice && bpsConfig == other.bpsConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bpsConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionBpsPrice{bpsConfig=$bpsConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionBulkBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        private val bulkBpsConfig: JsonField<BulkBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkBpsConfig(): BulkBpsConfigModel = bulkBpsConfig.getRequired("bulk_bps_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfigModel> = bulkBpsConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionBulkBpsPrice = apply {
            if (validated) {
                return@apply
            }

            bulkBpsConfig().validate()
            cadence()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionBulkBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkBpsConfig()
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionBulkBpsPrice]. */
        class Builder internal constructor() {

            private var bulkBpsConfig: JsonField<BulkBpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionBulkBpsPrice: NewSubscriptionBulkBpsPrice) = apply {
                bulkBpsConfig = newSubscriptionBulkBpsPrice.bulkBpsConfig
                cadence = newSubscriptionBulkBpsPrice.cadence
                itemId = newSubscriptionBulkBpsPrice.itemId
                modelType = newSubscriptionBulkBpsPrice.modelType
                name = newSubscriptionBulkBpsPrice.name
                billableMetricId = newSubscriptionBulkBpsPrice.billableMetricId
                billedInAdvance = newSubscriptionBulkBpsPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionBulkBpsPrice.billingCycleConfiguration
                conversionRate = newSubscriptionBulkBpsPrice.conversionRate
                currency = newSubscriptionBulkBpsPrice.currency
                externalPriceId = newSubscriptionBulkBpsPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionBulkBpsPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionBulkBpsPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionBulkBpsPrice.invoicingCycleConfiguration
                metadata = newSubscriptionBulkBpsPrice.metadata
                referenceId = newSubscriptionBulkBpsPrice.referenceId
                additionalProperties =
                    newSubscriptionBulkBpsPrice.additionalProperties.toMutableMap()
            }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfigModel) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfigModel>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionBulkBpsPrice =
                NewSubscriptionBulkBpsPrice(
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_BPS = of("bulk_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_BPS -> Value.BULK_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_BPS -> Known.BULK_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionBulkBpsPrice && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkBpsConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionBulkBpsPrice{bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_config")
        @ExcludeMissing
        private val bulkConfig: JsonField<BulkConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkConfig(): BulkConfigModel = bulkConfig.getRequired("bulk_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfigModel> = bulkConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionBulkPrice = apply {
            if (validated) {
                return@apply
            }

            bulkConfig().validate()
            cadence()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [NewSubscriptionBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkConfig()
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionBulkPrice]. */
        class Builder internal constructor() {

            private var bulkConfig: JsonField<BulkConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(newSubscriptionBulkPrice: NewSubscriptionBulkPrice) = apply {
                bulkConfig = newSubscriptionBulkPrice.bulkConfig
                cadence = newSubscriptionBulkPrice.cadence
                itemId = newSubscriptionBulkPrice.itemId
                modelType = newSubscriptionBulkPrice.modelType
                name = newSubscriptionBulkPrice.name
                billableMetricId = newSubscriptionBulkPrice.billableMetricId
                billedInAdvance = newSubscriptionBulkPrice.billedInAdvance
                billingCycleConfiguration = newSubscriptionBulkPrice.billingCycleConfiguration
                conversionRate = newSubscriptionBulkPrice.conversionRate
                currency = newSubscriptionBulkPrice.currency
                externalPriceId = newSubscriptionBulkPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionBulkPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionBulkPrice.invoiceGroupingKey
                invoicingCycleConfiguration = newSubscriptionBulkPrice.invoicingCycleConfiguration
                metadata = newSubscriptionBulkPrice.metadata
                referenceId = newSubscriptionBulkPrice.referenceId
                additionalProperties = newSubscriptionBulkPrice.additionalProperties.toMutableMap()
            }

            fun bulkConfig(bulkConfig: BulkConfigModel) = bulkConfig(JsonField.of(bulkConfig))

            fun bulkConfig(bulkConfig: JsonField<BulkConfigModel>) = apply {
                this.bulkConfig = bulkConfig
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionBulkPrice =
                NewSubscriptionBulkPrice(
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK = of("bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK -> Value.BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK -> Known.BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionBulkPrice && bulkConfig == other.bulkConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionBulkPrice{bulkConfig=$bulkConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionThresholdTotalAmountPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        private val thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun thresholdTotalAmountConfig(): CustomRatingFunctionConfigModel =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<CustomRatingFunctionConfigModel> =
            thresholdTotalAmountConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionThresholdTotalAmountPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            thresholdTotalAmountConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionThresholdTotalAmountPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .thresholdTotalAmountConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionThresholdTotalAmountPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionThresholdTotalAmountPrice: NewSubscriptionThresholdTotalAmountPrice
            ) = apply {
                cadence = newSubscriptionThresholdTotalAmountPrice.cadence
                itemId = newSubscriptionThresholdTotalAmountPrice.itemId
                modelType = newSubscriptionThresholdTotalAmountPrice.modelType
                name = newSubscriptionThresholdTotalAmountPrice.name
                thresholdTotalAmountConfig =
                    newSubscriptionThresholdTotalAmountPrice.thresholdTotalAmountConfig
                billableMetricId = newSubscriptionThresholdTotalAmountPrice.billableMetricId
                billedInAdvance = newSubscriptionThresholdTotalAmountPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionThresholdTotalAmountPrice.billingCycleConfiguration
                conversionRate = newSubscriptionThresholdTotalAmountPrice.conversionRate
                currency = newSubscriptionThresholdTotalAmountPrice.currency
                externalPriceId = newSubscriptionThresholdTotalAmountPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionThresholdTotalAmountPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionThresholdTotalAmountPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionThresholdTotalAmountPrice.invoicingCycleConfiguration
                metadata = newSubscriptionThresholdTotalAmountPrice.metadata
                referenceId = newSubscriptionThresholdTotalAmountPrice.referenceId
                additionalProperties =
                    newSubscriptionThresholdTotalAmountPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: CustomRatingFunctionConfigModel
            ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionThresholdTotalAmountPrice =
                NewSubscriptionThresholdTotalAmountPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                THRESHOLD_TOTAL_AMOUNT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                THRESHOLD_TOTAL_AMOUNT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionThresholdTotalAmountPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, thresholdTotalAmountConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionThresholdTotalAmountPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        private val tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredPackageConfig(): CustomRatingFunctionConfigModel =
            tieredPackageConfig.getRequired("tiered_package_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> = tieredPackageConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            tieredPackageConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredPackageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionTieredPackagePrice: NewSubscriptionTieredPackagePrice
            ) = apply {
                cadence = newSubscriptionTieredPackagePrice.cadence
                itemId = newSubscriptionTieredPackagePrice.itemId
                modelType = newSubscriptionTieredPackagePrice.modelType
                name = newSubscriptionTieredPackagePrice.name
                tieredPackageConfig = newSubscriptionTieredPackagePrice.tieredPackageConfig
                billableMetricId = newSubscriptionTieredPackagePrice.billableMetricId
                billedInAdvance = newSubscriptionTieredPackagePrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionTieredPackagePrice.billingCycleConfiguration
                conversionRate = newSubscriptionTieredPackagePrice.conversionRate
                currency = newSubscriptionTieredPackagePrice.currency
                externalPriceId = newSubscriptionTieredPackagePrice.externalPriceId
                fixedPriceQuantity = newSubscriptionTieredPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionTieredPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionTieredPackagePrice.invoicingCycleConfiguration
                metadata = newSubscriptionTieredPackagePrice.metadata
                referenceId = newSubscriptionTieredPackagePrice.referenceId
                additionalProperties =
                    newSubscriptionTieredPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredPackageConfig(tieredPackageConfig: CustomRatingFunctionConfigModel) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            fun tieredPackageConfig(
                tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredPackageConfig = tieredPackageConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionTieredPackagePrice =
                NewSubscriptionTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE = of("tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE -> Value.TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE -> Known.TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionTieredPackagePrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredPackageConfig == other.tieredPackageConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredPackageConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionTieredPackagePrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredPackageConfig=$tieredPackageConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionTieredWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        private val tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredWithMinimumConfig(): CustomRatingFunctionConfigModel =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithMinimumConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionTieredWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            tieredWithMinimumConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionTieredWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionTieredWithMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionTieredWithMinimumPrice: NewSubscriptionTieredWithMinimumPrice
            ) = apply {
                cadence = newSubscriptionTieredWithMinimumPrice.cadence
                itemId = newSubscriptionTieredWithMinimumPrice.itemId
                modelType = newSubscriptionTieredWithMinimumPrice.modelType
                name = newSubscriptionTieredWithMinimumPrice.name
                tieredWithMinimumConfig =
                    newSubscriptionTieredWithMinimumPrice.tieredWithMinimumConfig
                billableMetricId = newSubscriptionTieredWithMinimumPrice.billableMetricId
                billedInAdvance = newSubscriptionTieredWithMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionTieredWithMinimumPrice.billingCycleConfiguration
                conversionRate = newSubscriptionTieredWithMinimumPrice.conversionRate
                currency = newSubscriptionTieredWithMinimumPrice.currency
                externalPriceId = newSubscriptionTieredWithMinimumPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionTieredWithMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionTieredWithMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionTieredWithMinimumPrice.invoicingCycleConfiguration
                metadata = newSubscriptionTieredWithMinimumPrice.metadata
                referenceId = newSubscriptionTieredWithMinimumPrice.referenceId
                additionalProperties =
                    newSubscriptionTieredWithMinimumPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: CustomRatingFunctionConfigModel) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionTieredWithMinimumPrice =
                NewSubscriptionTieredWithMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionTieredWithMinimumPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithMinimumConfig == other.tieredWithMinimumConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredWithMinimumConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionTieredWithMinimumPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredWithMinimumConfig=$tieredWithMinimumConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionUnitWithPercentPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        private val unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitWithPercentConfig(): CustomRatingFunctionConfigModel =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithPercentConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionUnitWithPercentPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            unitWithPercentConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionUnitWithPercentPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .unitWithPercentConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionUnitWithPercentPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionUnitWithPercentPrice: NewSubscriptionUnitWithPercentPrice
            ) = apply {
                cadence = newSubscriptionUnitWithPercentPrice.cadence
                itemId = newSubscriptionUnitWithPercentPrice.itemId
                modelType = newSubscriptionUnitWithPercentPrice.modelType
                name = newSubscriptionUnitWithPercentPrice.name
                unitWithPercentConfig = newSubscriptionUnitWithPercentPrice.unitWithPercentConfig
                billableMetricId = newSubscriptionUnitWithPercentPrice.billableMetricId
                billedInAdvance = newSubscriptionUnitWithPercentPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionUnitWithPercentPrice.billingCycleConfiguration
                conversionRate = newSubscriptionUnitWithPercentPrice.conversionRate
                currency = newSubscriptionUnitWithPercentPrice.currency
                externalPriceId = newSubscriptionUnitWithPercentPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionUnitWithPercentPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionUnitWithPercentPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionUnitWithPercentPrice.invoicingCycleConfiguration
                metadata = newSubscriptionUnitWithPercentPrice.metadata
                referenceId = newSubscriptionUnitWithPercentPrice.referenceId
                additionalProperties =
                    newSubscriptionUnitWithPercentPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitWithPercentConfig(unitWithPercentConfig: CustomRatingFunctionConfigModel) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            fun unitWithPercentConfig(
                unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithPercentConfig = unitWithPercentConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionUnitWithPercentPrice =
                NewSubscriptionUnitWithPercentPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PERCENT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PERCENT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionUnitWithPercentPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithPercentConfig == other.unitWithPercentConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitWithPercentConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionUnitWithPercentPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitWithPercentConfig=$unitWithPercentConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionPackageWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        private val packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun packageWithAllocationConfig(): CustomRatingFunctionConfigModel =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            packageWithAllocationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionPackageWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            packageWithAllocationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionPackageWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .packageWithAllocationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionPackageWithAllocationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionPackageWithAllocationPrice: NewSubscriptionPackageWithAllocationPrice
            ) = apply {
                cadence = newSubscriptionPackageWithAllocationPrice.cadence
                itemId = newSubscriptionPackageWithAllocationPrice.itemId
                modelType = newSubscriptionPackageWithAllocationPrice.modelType
                name = newSubscriptionPackageWithAllocationPrice.name
                packageWithAllocationConfig =
                    newSubscriptionPackageWithAllocationPrice.packageWithAllocationConfig
                billableMetricId = newSubscriptionPackageWithAllocationPrice.billableMetricId
                billedInAdvance = newSubscriptionPackageWithAllocationPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionPackageWithAllocationPrice.billingCycleConfiguration
                conversionRate = newSubscriptionPackageWithAllocationPrice.conversionRate
                currency = newSubscriptionPackageWithAllocationPrice.currency
                externalPriceId = newSubscriptionPackageWithAllocationPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionPackageWithAllocationPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionPackageWithAllocationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionPackageWithAllocationPrice.invoicingCycleConfiguration
                metadata = newSubscriptionPackageWithAllocationPrice.metadata
                referenceId = newSubscriptionPackageWithAllocationPrice.referenceId
                additionalProperties =
                    newSubscriptionPackageWithAllocationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: CustomRatingFunctionConfigModel
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionPackageWithAllocationPrice =
                NewSubscriptionPackageWithAllocationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionPackageWithAllocationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, packageWithAllocationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionPackageWithAllocationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionTierWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        private val tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun tieredWithProrationConfig(): CustomRatingFunctionConfigModel =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithProrationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionTierWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            tieredWithProrationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionTierWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .tieredWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionTierWithProrationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionTierWithProrationPrice: NewSubscriptionTierWithProrationPrice
            ) = apply {
                cadence = newSubscriptionTierWithProrationPrice.cadence
                itemId = newSubscriptionTierWithProrationPrice.itemId
                modelType = newSubscriptionTierWithProrationPrice.modelType
                name = newSubscriptionTierWithProrationPrice.name
                tieredWithProrationConfig =
                    newSubscriptionTierWithProrationPrice.tieredWithProrationConfig
                billableMetricId = newSubscriptionTierWithProrationPrice.billableMetricId
                billedInAdvance = newSubscriptionTierWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionTierWithProrationPrice.billingCycleConfiguration
                conversionRate = newSubscriptionTierWithProrationPrice.conversionRate
                currency = newSubscriptionTierWithProrationPrice.currency
                externalPriceId = newSubscriptionTierWithProrationPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionTierWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionTierWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionTierWithProrationPrice.invoicingCycleConfiguration
                metadata = newSubscriptionTierWithProrationPrice.metadata
                referenceId = newSubscriptionTierWithProrationPrice.referenceId
                additionalProperties =
                    newSubscriptionTierWithProrationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: CustomRatingFunctionConfigModel
            ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionTierWithProrationPrice =
                NewSubscriptionTierWithProrationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionTierWithProrationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && tieredWithProrationConfig == other.tieredWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, tieredWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionTierWithProrationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, tieredWithProrationConfig=$tieredWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionUnitWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        private val unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun unitWithProrationConfig(): CustomRatingFunctionConfigModel =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithProrationConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionUnitWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            unitWithProrationConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionUnitWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .unitWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionUnitWithProrationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionUnitWithProrationPrice: NewSubscriptionUnitWithProrationPrice
            ) = apply {
                cadence = newSubscriptionUnitWithProrationPrice.cadence
                itemId = newSubscriptionUnitWithProrationPrice.itemId
                modelType = newSubscriptionUnitWithProrationPrice.modelType
                name = newSubscriptionUnitWithProrationPrice.name
                unitWithProrationConfig =
                    newSubscriptionUnitWithProrationPrice.unitWithProrationConfig
                billableMetricId = newSubscriptionUnitWithProrationPrice.billableMetricId
                billedInAdvance = newSubscriptionUnitWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionUnitWithProrationPrice.billingCycleConfiguration
                conversionRate = newSubscriptionUnitWithProrationPrice.conversionRate
                currency = newSubscriptionUnitWithProrationPrice.currency
                externalPriceId = newSubscriptionUnitWithProrationPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionUnitWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionUnitWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionUnitWithProrationPrice.invoicingCycleConfiguration
                metadata = newSubscriptionUnitWithProrationPrice.metadata
                referenceId = newSubscriptionUnitWithProrationPrice.referenceId
                additionalProperties =
                    newSubscriptionUnitWithProrationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun unitWithProrationConfig(unitWithProrationConfig: CustomRatingFunctionConfigModel) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionUnitWithProrationPrice =
                NewSubscriptionUnitWithProrationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionUnitWithProrationPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && unitWithProrationConfig == other.unitWithProrationConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, unitWithProrationConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionUnitWithProrationPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, unitWithProrationConfig=$unitWithProrationConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionGroupedAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        private val groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun groupedAllocationConfig(): CustomRatingFunctionConfigModel =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedAllocationConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionGroupedAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            groupedAllocationConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionGroupedAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .groupedAllocationConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionGroupedAllocationPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionGroupedAllocationPrice: NewSubscriptionGroupedAllocationPrice
            ) = apply {
                cadence = newSubscriptionGroupedAllocationPrice.cadence
                groupedAllocationConfig =
                    newSubscriptionGroupedAllocationPrice.groupedAllocationConfig
                itemId = newSubscriptionGroupedAllocationPrice.itemId
                modelType = newSubscriptionGroupedAllocationPrice.modelType
                name = newSubscriptionGroupedAllocationPrice.name
                billableMetricId = newSubscriptionGroupedAllocationPrice.billableMetricId
                billedInAdvance = newSubscriptionGroupedAllocationPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionGroupedAllocationPrice.billingCycleConfiguration
                conversionRate = newSubscriptionGroupedAllocationPrice.conversionRate
                currency = newSubscriptionGroupedAllocationPrice.currency
                externalPriceId = newSubscriptionGroupedAllocationPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionGroupedAllocationPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionGroupedAllocationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionGroupedAllocationPrice.invoicingCycleConfiguration
                metadata = newSubscriptionGroupedAllocationPrice.metadata
                referenceId = newSubscriptionGroupedAllocationPrice.referenceId
                additionalProperties =
                    newSubscriptionGroupedAllocationPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun groupedAllocationConfig(groupedAllocationConfig: CustomRatingFunctionConfigModel) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionGroupedAllocationPrice =
                NewSubscriptionGroupedAllocationPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionGroupedAllocationPrice && cadence == other.cadence && groupedAllocationConfig == other.groupedAllocationConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, groupedAllocationConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionGroupedAllocationPrice{cadence=$cadence, groupedAllocationConfig=$groupedAllocationConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionGroupedWithProratedMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        private val groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun groupedWithProratedMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithProratedMinimumConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionGroupedWithProratedMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            groupedWithProratedMinimumConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionGroupedWithProratedMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .groupedWithProratedMinimumConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionGroupedWithProratedMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionGroupedWithProratedMinimumPrice:
                    NewSubscriptionGroupedWithProratedMinimumPrice
            ) = apply {
                cadence = newSubscriptionGroupedWithProratedMinimumPrice.cadence
                groupedWithProratedMinimumConfig =
                    newSubscriptionGroupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                itemId = newSubscriptionGroupedWithProratedMinimumPrice.itemId
                modelType = newSubscriptionGroupedWithProratedMinimumPrice.modelType
                name = newSubscriptionGroupedWithProratedMinimumPrice.name
                billableMetricId = newSubscriptionGroupedWithProratedMinimumPrice.billableMetricId
                billedInAdvance = newSubscriptionGroupedWithProratedMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionGroupedWithProratedMinimumPrice.billingCycleConfiguration
                conversionRate = newSubscriptionGroupedWithProratedMinimumPrice.conversionRate
                currency = newSubscriptionGroupedWithProratedMinimumPrice.currency
                externalPriceId = newSubscriptionGroupedWithProratedMinimumPrice.externalPriceId
                fixedPriceQuantity =
                    newSubscriptionGroupedWithProratedMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newSubscriptionGroupedWithProratedMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionGroupedWithProratedMinimumPrice.invoicingCycleConfiguration
                metadata = newSubscriptionGroupedWithProratedMinimumPrice.metadata
                referenceId = newSubscriptionGroupedWithProratedMinimumPrice.referenceId
                additionalProperties =
                    newSubscriptionGroupedWithProratedMinimumPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionGroupedWithProratedMinimumPrice =
                NewSubscriptionGroupedWithProratedMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_PRORATED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_PRORATED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionGroupedWithProratedMinimumPrice && cadence == other.cadence && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, groupedWithProratedMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionGroupedWithProratedMinimumPrice{cadence=$cadence, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionBulkWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        private val bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun bulkWithProrationConfig(): CustomRatingFunctionConfigModel =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            bulkWithProrationConfig

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionBulkWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            bulkWithProrationConfig().validate()
            cadence()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionBulkWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .bulkWithProrationConfig()
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionBulkWithProrationPrice]. */
        class Builder internal constructor() {

            private var bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionBulkWithProrationPrice: NewSubscriptionBulkWithProrationPrice
            ) = apply {
                bulkWithProrationConfig =
                    newSubscriptionBulkWithProrationPrice.bulkWithProrationConfig
                cadence = newSubscriptionBulkWithProrationPrice.cadence
                itemId = newSubscriptionBulkWithProrationPrice.itemId
                modelType = newSubscriptionBulkWithProrationPrice.modelType
                name = newSubscriptionBulkWithProrationPrice.name
                billableMetricId = newSubscriptionBulkWithProrationPrice.billableMetricId
                billedInAdvance = newSubscriptionBulkWithProrationPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionBulkWithProrationPrice.billingCycleConfiguration
                conversionRate = newSubscriptionBulkWithProrationPrice.conversionRate
                currency = newSubscriptionBulkWithProrationPrice.currency
                externalPriceId = newSubscriptionBulkWithProrationPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionBulkWithProrationPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionBulkWithProrationPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionBulkWithProrationPrice.invoicingCycleConfiguration
                metadata = newSubscriptionBulkWithProrationPrice.metadata
                referenceId = newSubscriptionBulkWithProrationPrice.referenceId
                additionalProperties =
                    newSubscriptionBulkWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun bulkWithProrationConfig(bulkWithProrationConfig: CustomRatingFunctionConfigModel) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionBulkWithProrationPrice =
                NewSubscriptionBulkWithProrationPrice(
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionBulkWithProrationPrice && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(bulkWithProrationConfig, cadence, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionBulkWithProrationPrice{bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionScalableMatrixWithUnitPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun scalableMatrixWithUnitPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithUnitPricingConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionScalableMatrixWithUnitPricingPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            scalableMatrixWithUnitPricingConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionScalableMatrixWithUnitPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionScalableMatrixWithUnitPricingPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionScalableMatrixWithUnitPricingPrice:
                    NewSubscriptionScalableMatrixWithUnitPricingPrice
            ) = apply {
                cadence = newSubscriptionScalableMatrixWithUnitPricingPrice.cadence
                itemId = newSubscriptionScalableMatrixWithUnitPricingPrice.itemId
                modelType = newSubscriptionScalableMatrixWithUnitPricingPrice.modelType
                name = newSubscriptionScalableMatrixWithUnitPricingPrice.name
                scalableMatrixWithUnitPricingConfig =
                    newSubscriptionScalableMatrixWithUnitPricingPrice
                        .scalableMatrixWithUnitPricingConfig
                billableMetricId =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.billableMetricId
                billedInAdvance = newSubscriptionScalableMatrixWithUnitPricingPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.billingCycleConfiguration
                conversionRate = newSubscriptionScalableMatrixWithUnitPricingPrice.conversionRate
                currency = newSubscriptionScalableMatrixWithUnitPricingPrice.currency
                externalPriceId = newSubscriptionScalableMatrixWithUnitPricingPrice.externalPriceId
                fixedPriceQuantity =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.invoicingCycleConfiguration
                metadata = newSubscriptionScalableMatrixWithUnitPricingPrice.metadata
                referenceId = newSubscriptionScalableMatrixWithUnitPricingPrice.referenceId
                additionalProperties =
                    newSubscriptionScalableMatrixWithUnitPricingPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionScalableMatrixWithUnitPricingPrice =
                NewSubscriptionScalableMatrixWithUnitPricingPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_UNIT_PRICING = of("scalable_matrix_with_unit_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_UNIT_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_UNIT_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Value.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Known.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionScalableMatrixWithUnitPricingPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, scalableMatrixWithUnitPricingConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionScalableMatrixWithUnitPricingPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionScalableMatrixWithTieredPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        fun scalableMatrixWithTieredPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithTieredPricingConfig

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionScalableMatrixWithTieredPricingPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            modelType()
            name()
            scalableMatrixWithTieredPricingConfig().validate()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionScalableMatrixWithTieredPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .modelType()
             * .name()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionScalableMatrixWithTieredPricingPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionScalableMatrixWithTieredPricingPrice:
                    NewSubscriptionScalableMatrixWithTieredPricingPrice
            ) = apply {
                cadence = newSubscriptionScalableMatrixWithTieredPricingPrice.cadence
                itemId = newSubscriptionScalableMatrixWithTieredPricingPrice.itemId
                modelType = newSubscriptionScalableMatrixWithTieredPricingPrice.modelType
                name = newSubscriptionScalableMatrixWithTieredPricingPrice.name
                scalableMatrixWithTieredPricingConfig =
                    newSubscriptionScalableMatrixWithTieredPricingPrice
                        .scalableMatrixWithTieredPricingConfig
                billableMetricId =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.billableMetricId
                billedInAdvance =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.billingCycleConfiguration
                conversionRate = newSubscriptionScalableMatrixWithTieredPricingPrice.conversionRate
                currency = newSubscriptionScalableMatrixWithTieredPricingPrice.currency
                externalPriceId =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.externalPriceId
                fixedPriceQuantity =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.invoicingCycleConfiguration
                metadata = newSubscriptionScalableMatrixWithTieredPricingPrice.metadata
                referenceId = newSubscriptionScalableMatrixWithTieredPricingPrice.referenceId
                additionalProperties =
                    newSubscriptionScalableMatrixWithTieredPricingPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionScalableMatrixWithTieredPricingPrice =
                NewSubscriptionScalableMatrixWithTieredPricingPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_TIERED_PRICING = of("scalable_matrix_with_tiered_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_TIERED_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_TIERED_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Value.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Known.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionScalableMatrixWithTieredPricingPrice && cadence == other.cadence && itemId == other.itemId && modelType == other.modelType && name == other.name && scalableMatrixWithTieredPricingConfig == other.scalableMatrixWithTieredPricingConfig && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, modelType, name, scalableMatrixWithTieredPricingConfig, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionScalableMatrixWithTieredPricingPrice{cadence=$cadence, itemId=$itemId, modelType=$modelType, name=$name, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionCumulativeGroupedBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        private val cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun cumulativeGroupedBulkConfig(): CustomRatingFunctionConfigModel =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CustomRatingFunctionConfigModel> =
            cumulativeGroupedBulkConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionCumulativeGroupedBulkPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            cumulativeGroupedBulkConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionCumulativeGroupedBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .cumulativeGroupedBulkConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionCumulativeGroupedBulkPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionCumulativeGroupedBulkPrice: NewSubscriptionCumulativeGroupedBulkPrice
            ) = apply {
                cadence = newSubscriptionCumulativeGroupedBulkPrice.cadence
                cumulativeGroupedBulkConfig =
                    newSubscriptionCumulativeGroupedBulkPrice.cumulativeGroupedBulkConfig
                itemId = newSubscriptionCumulativeGroupedBulkPrice.itemId
                modelType = newSubscriptionCumulativeGroupedBulkPrice.modelType
                name = newSubscriptionCumulativeGroupedBulkPrice.name
                billableMetricId = newSubscriptionCumulativeGroupedBulkPrice.billableMetricId
                billedInAdvance = newSubscriptionCumulativeGroupedBulkPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionCumulativeGroupedBulkPrice.billingCycleConfiguration
                conversionRate = newSubscriptionCumulativeGroupedBulkPrice.conversionRate
                currency = newSubscriptionCumulativeGroupedBulkPrice.currency
                externalPriceId = newSubscriptionCumulativeGroupedBulkPrice.externalPriceId
                fixedPriceQuantity = newSubscriptionCumulativeGroupedBulkPrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionCumulativeGroupedBulkPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionCumulativeGroupedBulkPrice.invoicingCycleConfiguration
                metadata = newSubscriptionCumulativeGroupedBulkPrice.metadata
                referenceId = newSubscriptionCumulativeGroupedBulkPrice.referenceId
                additionalProperties =
                    newSubscriptionCumulativeGroupedBulkPrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CustomRatingFunctionConfigModel
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionCumulativeGroupedBulkPrice =
                NewSubscriptionCumulativeGroupedBulkPrice(
                    checkRequired("cadence", cadence),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val CUMULATIVE_GROUPED_BULK = of("cumulative_grouped_bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                CUMULATIVE_GROUPED_BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                CUMULATIVE_GROUPED_BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Value.CUMULATIVE_GROUPED_BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Known.CUMULATIVE_GROUPED_BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionCumulativeGroupedBulkPrice && cadence == other.cadence && cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, cumulativeGroupedBulkConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionCumulativeGroupedBulkPrice{cadence=$cadence, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionMaxGroupTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        private val maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun maxGroupTieredPackageConfig(): CustomRatingFunctionConfigModel =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            maxGroupTieredPackageConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionMaxGroupTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            maxGroupTieredPackageConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionMaxGroupTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .maxGroupTieredPackageConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionMaxGroupTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionMaxGroupTieredPackagePrice: NewSubscriptionMaxGroupTieredPackagePrice
            ) = apply {
                cadence = newSubscriptionMaxGroupTieredPackagePrice.cadence
                itemId = newSubscriptionMaxGroupTieredPackagePrice.itemId
                maxGroupTieredPackageConfig =
                    newSubscriptionMaxGroupTieredPackagePrice.maxGroupTieredPackageConfig
                modelType = newSubscriptionMaxGroupTieredPackagePrice.modelType
                name = newSubscriptionMaxGroupTieredPackagePrice.name
                billableMetricId = newSubscriptionMaxGroupTieredPackagePrice.billableMetricId
                billedInAdvance = newSubscriptionMaxGroupTieredPackagePrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionMaxGroupTieredPackagePrice.billingCycleConfiguration
                conversionRate = newSubscriptionMaxGroupTieredPackagePrice.conversionRate
                currency = newSubscriptionMaxGroupTieredPackagePrice.currency
                externalPriceId = newSubscriptionMaxGroupTieredPackagePrice.externalPriceId
                fixedPriceQuantity = newSubscriptionMaxGroupTieredPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionMaxGroupTieredPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionMaxGroupTieredPackagePrice.invoicingCycleConfiguration
                metadata = newSubscriptionMaxGroupTieredPackagePrice.metadata
                referenceId = newSubscriptionMaxGroupTieredPackagePrice.referenceId
                additionalProperties =
                    newSubscriptionMaxGroupTieredPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionMaxGroupTieredPackagePrice =
                NewSubscriptionMaxGroupTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MAX_GROUP_TIERED_PACKAGE = of("max_group_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MAX_GROUP_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MAX_GROUP_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Value.MAX_GROUP_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Known.MAX_GROUP_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionMaxGroupTieredPackagePrice && cadence == other.cadence && itemId == other.itemId && maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, maxGroupTieredPackageConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionMaxGroupTieredPackagePrice{cadence=$cadence, itemId=$itemId, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionGroupedWithMeteredMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        private val groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun groupedWithMeteredMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithMeteredMinimumConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionGroupedWithMeteredMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            groupedWithMeteredMinimumConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionGroupedWithMeteredMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .groupedWithMeteredMinimumConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionGroupedWithMeteredMinimumPrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionGroupedWithMeteredMinimumPrice:
                    NewSubscriptionGroupedWithMeteredMinimumPrice
            ) = apply {
                cadence = newSubscriptionGroupedWithMeteredMinimumPrice.cadence
                groupedWithMeteredMinimumConfig =
                    newSubscriptionGroupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                itemId = newSubscriptionGroupedWithMeteredMinimumPrice.itemId
                modelType = newSubscriptionGroupedWithMeteredMinimumPrice.modelType
                name = newSubscriptionGroupedWithMeteredMinimumPrice.name
                billableMetricId = newSubscriptionGroupedWithMeteredMinimumPrice.billableMetricId
                billedInAdvance = newSubscriptionGroupedWithMeteredMinimumPrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionGroupedWithMeteredMinimumPrice.billingCycleConfiguration
                conversionRate = newSubscriptionGroupedWithMeteredMinimumPrice.conversionRate
                currency = newSubscriptionGroupedWithMeteredMinimumPrice.currency
                externalPriceId = newSubscriptionGroupedWithMeteredMinimumPrice.externalPriceId
                fixedPriceQuantity =
                    newSubscriptionGroupedWithMeteredMinimumPrice.fixedPriceQuantity
                invoiceGroupingKey =
                    newSubscriptionGroupedWithMeteredMinimumPrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionGroupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                metadata = newSubscriptionGroupedWithMeteredMinimumPrice.metadata
                referenceId = newSubscriptionGroupedWithMeteredMinimumPrice.referenceId
                additionalProperties =
                    newSubscriptionGroupedWithMeteredMinimumPrice.additionalProperties
                        .toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionGroupedWithMeteredMinimumPrice =
                NewSubscriptionGroupedWithMeteredMinimumPrice(
                    checkRequired("cadence", cadence),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_METERED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_METERED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionGroupedWithMeteredMinimumPrice && cadence == other.cadence && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, groupedWithMeteredMinimumConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionGroupedWithMeteredMinimumPrice{cadence=$cadence, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionMatrixWithDisplayNamePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        private val matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun matrixWithDisplayNameConfig(): CustomRatingFunctionConfigModel =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<CustomRatingFunctionConfigModel> =
            matrixWithDisplayNameConfig

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionMatrixWithDisplayNamePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            itemId()
            matrixWithDisplayNameConfig().validate()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionMatrixWithDisplayNamePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .itemId()
             * .matrixWithDisplayNameConfig()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionMatrixWithDisplayNamePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var itemId: JsonField<String>? = null
            private var matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionMatrixWithDisplayNamePrice: NewSubscriptionMatrixWithDisplayNamePrice
            ) = apply {
                cadence = newSubscriptionMatrixWithDisplayNamePrice.cadence
                itemId = newSubscriptionMatrixWithDisplayNamePrice.itemId
                matrixWithDisplayNameConfig =
                    newSubscriptionMatrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                modelType = newSubscriptionMatrixWithDisplayNamePrice.modelType
                name = newSubscriptionMatrixWithDisplayNamePrice.name
                billableMetricId = newSubscriptionMatrixWithDisplayNamePrice.billableMetricId
                billedInAdvance = newSubscriptionMatrixWithDisplayNamePrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionMatrixWithDisplayNamePrice.billingCycleConfiguration
                conversionRate = newSubscriptionMatrixWithDisplayNamePrice.conversionRate
                currency = newSubscriptionMatrixWithDisplayNamePrice.currency
                externalPriceId = newSubscriptionMatrixWithDisplayNamePrice.externalPriceId
                fixedPriceQuantity = newSubscriptionMatrixWithDisplayNamePrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionMatrixWithDisplayNamePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionMatrixWithDisplayNamePrice.invoicingCycleConfiguration
                metadata = newSubscriptionMatrixWithDisplayNamePrice.metadata
                referenceId = newSubscriptionMatrixWithDisplayNamePrice.referenceId
                additionalProperties =
                    newSubscriptionMatrixWithDisplayNamePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: CustomRatingFunctionConfigModel
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionMatrixWithDisplayNamePrice =
                NewSubscriptionMatrixWithDisplayNamePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("itemId", itemId),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_DISPLAY_NAME
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_DISPLAY_NAME,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionMatrixWithDisplayNamePrice && cadence == other.cadence && itemId == other.itemId && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, itemId, matrixWithDisplayNameConfig, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionMatrixWithDisplayNamePrice{cadence=$cadence, itemId=$itemId, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class NewSubscriptionGroupedTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        private val groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("item_id")
        @ExcludeMissing
        private val itemId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        private val billableMetricId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        private val billedInAdvance: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        private val invoiceGroupingKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("reference_id")
        @ExcludeMissing
        private val referenceId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /** The cadence to bill for this price on. */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun groupedTieredPackageConfig(): CustomRatingFunctionConfigModel =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        /** The id of the item the price will be associated with. */
        fun itemId(): String = itemId.getRequired("item_id")

        fun modelType(): ModelType = modelType.getRequired("model_type")

        /** The name of the price. */
        fun name(): String = name.getRequired("name")

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        fun billableMetricId(): Optional<String> =
            Optional.ofNullable(billableMetricId.getNullable("billable_metric_id"))

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        fun billedInAdvance(): Optional<Boolean> =
            Optional.ofNullable(billedInAdvance.getNullable("billed_in_advance"))

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        fun billingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                billingCycleConfiguration.getNullable("billing_cycle_configuration")
            )

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        fun currency(): Optional<String> = Optional.ofNullable(currency.getNullable("currency"))

        /** An alias for the price. */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /** The property used to group this price on an invoice */
        fun invoiceGroupingKey(): Optional<String> =
            Optional.ofNullable(invoiceGroupingKey.getNullable("invoice_grouping_key"))

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        fun invoicingCycleConfiguration(): Optional<NewBillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        fun metadata(): Optional<Metadata> = Optional.ofNullable(metadata.getNullable("metadata"))

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        fun referenceId(): Optional<String> =
            Optional.ofNullable(referenceId.getNullable("reference_id"))

        /** The cadence to bill for this price on. */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedTieredPackageConfig

        /** The id of the item the price will be associated with. */
        @JsonProperty("item_id") @ExcludeMissing fun _itemId(): JsonField<String> = itemId

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /** The name of the price. */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /** The id of the billable metric for the price. Only needed if the price is usage-based. */
        @JsonProperty("billable_metric_id")
        @ExcludeMissing
        fun _billableMetricId(): JsonField<String> = billableMetricId

        /**
         * If the Price represents a fixed cost, the price will be billed in-advance if this is
         * true, and in-arrears if this is false.
         */
        @JsonProperty("billed_in_advance")
        @ExcludeMissing
        fun _billedInAdvance(): JsonField<Boolean> = billedInAdvance

        /** For custom cadence: specifies the duration of the billing period in days or months. */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            billingCycleConfiguration

        /** The per unit conversion rate of the price currency to the invoicing currency. */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * An ISO 4217 currency string, or custom pricing unit identifier, in which this price is
         * billed.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /** An alias for the price. */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /** If the Price represents a fixed cost, this represents the quantity of units applied. */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /** The property used to group this price on an invoice */
        @JsonProperty("invoice_grouping_key")
        @ExcludeMissing
        fun _invoiceGroupingKey(): JsonField<String> = invoiceGroupingKey

        /**
         * Within each billing cycle, specifies the cadence at which invoices are produced. If
         * unspecified, a single invoice is produced per billing cycle.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<NewBillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * A transient ID that can be used to reference this price when adding adjustments in the
         * same API call.
         */
        @JsonProperty("reference_id")
        @ExcludeMissing
        fun _referenceId(): JsonField<String> = referenceId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): NewSubscriptionGroupedTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            cadence()
            groupedTieredPackageConfig().validate()
            itemId()
            modelType()
            name()
            billableMetricId()
            billedInAdvance()
            billingCycleConfiguration().ifPresent { it.validate() }
            conversionRate()
            currency()
            externalPriceId()
            fixedPriceQuantity()
            invoiceGroupingKey()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            metadata().ifPresent { it.validate() }
            referenceId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [NewSubscriptionGroupedTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .cadence()
             * .groupedTieredPackageConfig()
             * .itemId()
             * .modelType()
             * .name()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [NewSubscriptionGroupedTieredPackagePrice]. */
        class Builder internal constructor() {

            private var cadence: JsonField<Cadence>? = null
            private var groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var itemId: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var billableMetricId: JsonField<String> = JsonMissing.of()
            private var billedInAdvance: JsonField<Boolean> = JsonMissing.of()
            private var billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var conversionRate: JsonField<Double> = JsonMissing.of()
            private var currency: JsonField<String> = JsonMissing.of()
            private var externalPriceId: JsonField<String> = JsonMissing.of()
            private var fixedPriceQuantity: JsonField<Double> = JsonMissing.of()
            private var invoiceGroupingKey: JsonField<String> = JsonMissing.of()
            private var invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel> =
                JsonMissing.of()
            private var metadata: JsonField<Metadata> = JsonMissing.of()
            private var referenceId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                newSubscriptionGroupedTieredPackagePrice: NewSubscriptionGroupedTieredPackagePrice
            ) = apply {
                cadence = newSubscriptionGroupedTieredPackagePrice.cadence
                groupedTieredPackageConfig =
                    newSubscriptionGroupedTieredPackagePrice.groupedTieredPackageConfig
                itemId = newSubscriptionGroupedTieredPackagePrice.itemId
                modelType = newSubscriptionGroupedTieredPackagePrice.modelType
                name = newSubscriptionGroupedTieredPackagePrice.name
                billableMetricId = newSubscriptionGroupedTieredPackagePrice.billableMetricId
                billedInAdvance = newSubscriptionGroupedTieredPackagePrice.billedInAdvance
                billingCycleConfiguration =
                    newSubscriptionGroupedTieredPackagePrice.billingCycleConfiguration
                conversionRate = newSubscriptionGroupedTieredPackagePrice.conversionRate
                currency = newSubscriptionGroupedTieredPackagePrice.currency
                externalPriceId = newSubscriptionGroupedTieredPackagePrice.externalPriceId
                fixedPriceQuantity = newSubscriptionGroupedTieredPackagePrice.fixedPriceQuantity
                invoiceGroupingKey = newSubscriptionGroupedTieredPackagePrice.invoiceGroupingKey
                invoicingCycleConfiguration =
                    newSubscriptionGroupedTieredPackagePrice.invoicingCycleConfiguration
                metadata = newSubscriptionGroupedTieredPackagePrice.metadata
                referenceId = newSubscriptionGroupedTieredPackagePrice.referenceId
                additionalProperties =
                    newSubscriptionGroupedTieredPackagePrice.additionalProperties.toMutableMap()
            }

            /** The cadence to bill for this price on. */
            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /** The cadence to bill for this price on. */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: String) = itemId(JsonField.of(itemId))

            /** The id of the item the price will be associated with. */
            fun itemId(itemId: JsonField<String>) = apply { this.itemId = itemId }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            /** The name of the price. */
            fun name(name: String) = name(JsonField.of(name))

            /** The name of the price. */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: String?) =
                billableMetricId(JsonField.ofNullable(billableMetricId))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: Optional<String>) =
                billableMetricId(billableMetricId.orElse(null))

            /**
             * The id of the billable metric for the price. Only needed if the price is usage-based.
             */
            fun billableMetricId(billableMetricId: JsonField<String>) = apply {
                this.billableMetricId = billableMetricId
            }

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean?) =
                billedInAdvance(JsonField.ofNullable(billedInAdvance))

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: Boolean) =
                billedInAdvance(billedInAdvance as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun billedInAdvance(billedInAdvance: Optional<Boolean>) =
                billedInAdvance(billedInAdvance.orElse(null) as Boolean?)

            /**
             * If the Price represents a fixed cost, the price will be billed in-advance if this is
             * true, and in-arrears if this is false.
             */
            fun billedInAdvance(billedInAdvance: JsonField<Boolean>) = apply {
                this.billedInAdvance = billedInAdvance
            }

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = billingCycleConfiguration(JsonField.ofNullable(billingCycleConfiguration))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = billingCycleConfiguration(billingCycleConfiguration.orElse(null))

            /**
             * For custom cadence: specifies the duration of the billing period in days or months.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            /** The per unit conversion rate of the price currency to the invoicing currency. */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: String?) = currency(JsonField.ofNullable(currency))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: Optional<String>) = currency(currency.orElse(null))

            /**
             * An ISO 4217 currency string, or custom pricing unit identifier, in which this price
             * is billed.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            /** An alias for the price. */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            /**
             * If the Price represents a fixed cost, this represents the quantity of units applied.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: String?) =
                invoiceGroupingKey(JsonField.ofNullable(invoiceGroupingKey))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: Optional<String>) =
                invoiceGroupingKey(invoiceGroupingKey.orElse(null))

            /** The property used to group this price on an invoice */
            fun invoiceGroupingKey(invoiceGroupingKey: JsonField<String>) = apply {
                this.invoiceGroupingKey = invoiceGroupingKey
            }

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: NewBillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<NewBillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            /**
             * Within each billing cycle, specifies the cadence at which invoices are produced. If
             * unspecified, a single invoice is produced per billing cycle.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<NewBillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata?) = metadata(JsonField.ofNullable(metadata))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: Optional<Metadata>) = metadata(metadata.orElse(null))

            /**
             * User-specified key/value pairs for the resource. Individual keys can be removed by
             * setting the value to `null`, and the entire metadata mapping can be cleared by
             * setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: String?) = referenceId(JsonField.ofNullable(referenceId))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: Optional<String>) = referenceId(referenceId.orElse(null))

            /**
             * A transient ID that can be used to reference this price when adding adjustments in
             * the same API call.
             */
            fun referenceId(referenceId: JsonField<String>) = apply {
                this.referenceId = referenceId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): NewSubscriptionGroupedTieredPackagePrice =
                NewSubscriptionGroupedTieredPackagePrice(
                    checkRequired("cadence", cadence),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("itemId", itemId),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    billableMetricId,
                    billedInAdvance,
                    billingCycleConfiguration,
                    conversionRate,
                    currency,
                    externalPriceId,
                    fixedPriceQuantity,
                    invoiceGroupingKey,
                    invoicingCycleConfiguration,
                    metadata,
                    referenceId,
                    additionalProperties.toImmutable(),
                )
        }

        /** The cadence to bill for this price on. */
        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ANNUAL = of("annual")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ANNUAL,
                SEMI_ANNUAL,
                MONTHLY,
                QUARTERLY,
                ONE_TIME,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ANNUAL -> Value.ANNUAL
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    ONE_TIME -> Value.ONE_TIME
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ANNUAL -> Known.ANNUAL
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    ONE_TIME -> Known.ONE_TIME
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User-specified key/value pairs for the resource. Individual keys can be removed by
         * setting the value to `null`, and the entire metadata mapping can be cleared by setting
         * `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is NewSubscriptionGroupedTieredPackagePrice && cadence == other.cadence && groupedTieredPackageConfig == other.groupedTieredPackageConfig && itemId == other.itemId && modelType == other.modelType && name == other.name && billableMetricId == other.billableMetricId && billedInAdvance == other.billedInAdvance && billingCycleConfiguration == other.billingCycleConfiguration && conversionRate == other.conversionRate && currency == other.currency && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoiceGroupingKey == other.invoiceGroupingKey && invoicingCycleConfiguration == other.invoicingCycleConfiguration && metadata == other.metadata && referenceId == other.referenceId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(cadence, groupedTieredPackageConfig, itemId, modelType, name, billableMetricId, billedInAdvance, billingCycleConfiguration, conversionRate, currency, externalPriceId, fixedPriceQuantity, invoiceGroupingKey, invoicingCycleConfiguration, metadata, referenceId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "NewSubscriptionGroupedTieredPackagePrice{cadence=$cadence, groupedTieredPackageConfig=$groupedTieredPackageConfig, itemId=$itemId, modelType=$modelType, name=$name, billableMetricId=$billableMetricId, billedInAdvance=$billedInAdvance, billingCycleConfiguration=$billingCycleConfiguration, conversionRate=$conversionRate, currency=$currency, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoiceGroupingKey=$invoiceGroupingKey, invoicingCycleConfiguration=$invoicingCycleConfiguration, metadata=$metadata, referenceId=$referenceId, additionalProperties=$additionalProperties}"
    }
}
