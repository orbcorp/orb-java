// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * The Price resource represents a price that can be billed on a subscription, resulting in a charge
 * on an invoice in the form of an invoice line item. Prices take a quantity and determine an amount
 * to bill.
 *
 * Orb supports a few different pricing models out of the box. Each of these models is serialized
 * differently in a given Price object. The model_type field determines the key for the
 * configuration object that is present.
 *
 * ## Unit pricing
 *
 * With unit pricing, each unit costs a fixed amount.
 *
 * ```json
 * {
 *     ...
 *     "model_type": "unit",
 *     "unit_config": {
 *         "unit_amount": "0.50"
 *     }
 *     ...
 * }
 * ```
 *
 * ## Tiered pricing
 *
 * In tiered pricing, the cost of a given unit depends on the tier range that it falls into, where
 * each tier range is defined by an upper and lower bound. For example, the first ten units may cost
 * $0.50 each and all units thereafter may cost $0.10 each.
 *
 * ```json
 * {
 *     ...
 *     "model_type": "tiered",
 *     "tiered_config": {
 *         "tiers": [
 *             {
 *                 "first_unit": 1,
 *                 "last_unit": 10,
 *                 "unit_amount": "0.50"
 *             },
 *             {
 *                 "first_unit": 11,
 *                 "last_unit": null,
 *                 "unit_amount": "0.10"
 *             }
 *         ]
 *     }
 *     ...
 * ```
 *
 * ## Bulk pricing
 *
 * Bulk pricing applies when the number of units determine the cost of all units. For example, if
 * you've bought less than 10 units, they may each be $0.50 for a total of $5.00. Once you've bought
 * more than 10 units, all units may now be priced at $0.40 (i.e. 101 units total would be $40.40).
 *
 * ```json
 * {
 *     ...
 *     "model_type": "bulk",
 *     "bulk_config": {
 *         "tiers": [
 *             {
 *                 "maximum_units": 10,
 *                 "unit_amount": "0.50"
 *             },
 *             {
 *                 "maximum_units": 1000,
 *                 "unit_amount": "0.40"
 *             }
 *         ]
 *     }
 *     ...
 * }
 * ```
 *
 * ## Package pricing
 *
 * Package pricing defines the size or granularity of a unit for billing purposes. For example, if
 * the package size is set to 5, then 4 units will be billed as 5 and 6 units will be billed at 10.
 *
 * ```json
 * {
 *     ...
 *     "model_type": "package",
 *     "package_config": {
 *         "package_amount": "0.80",
 *         "package_size": 10
 *     }
 *     ...
 * }
 * ```
 *
 * ## BPS pricing
 *
 * BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a percent (the
 * number of basis points to charge), as well as a cap per event to assess. For example, this would
 * allow you to assess a fee of 0.25% on every payment you process, with a maximum charge of $25 per
 * payment.
 *
 * ```json
 * {
 *     ...
 *     "model_type": "bps",
 *     "bps_config": {
 *        "bps": 125,
 *        "per_unit_maximum": "11.00"
 *     }
 *     ...
 *  }
 * ```
 *
 * ## Bulk BPS pricing
 *
 * Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the total quantity
 * across all events. Similar to bulk pricing, the BPS parameters of a given event depends on the
 * tier range that the billing period falls into. Each tier range is defined by an upper bound. For
 * example, after $1.5M of payment volume is reached, each individual payment may have a lower cap
 * or a smaller take-rate.
 *
 * ```json
 *     ...
 *     "model_type": "bulk_bps",
 *     "bulk_bps_config": {
 *         "tiers": [
 *            {
 *                 "maximum_amount": "1000000.00",
 *                 "bps": 125,
 *                 "per_unit_maximum": "19.00"
 *            },
 *           {
 *                 "maximum_amount": null,
 *                 "bps": 115,
 *                 "per_unit_maximum": "4.00"
 *             }
 *         ]
 *     }
 *     ...
 * }
 * ```
 *
 * ## Tiered BPS pricing
 *
 * Tiered BPS pricing specifies BPS parameters in a graduated manner, where an event's applicable
 * parameter is a function of its marginal addition to the period total. Similar to tiered pricing,
 * the BPS parameters of a given event depends on the tier range that it falls into, where each tier
 * range is defined by an upper and lower bound. For example, the first few payments may have a 0.8
 * BPS take-rate and all payments after a specific volume may incur a take-rate of 0.5 BPS each.
 *
 * ```json
 *     ...
 *     "model_type": "tiered_bps",
 *     "tiered_bps_config": {
 *         "tiers": [
 *            {
 *                 "minimum_amount": "0",
 *                 "maximum_amount": "1000000.00",
 *                 "bps": 125,
 *                 "per_unit_maximum": "19.00"
 *            },
 *           {
 *                 "minimum_amount": "1000000.00",
 *                 "maximum_amount": null,
 *                 "bps": 115,
 *                 "per_unit_maximum": "4.00"
 *             }
 *         ]
 *     }
 *     ...
 * }
 * ```
 *
 * ## Matrix pricing
 *
 * Matrix pricing defines a set of unit prices in a one or two-dimensional matrix. `dimensions`
 * defines the two event property values evaluated in this pricing model. In a one-dimensional
 * matrix, the second value is `null`. Every configuration has a list of `matrix_values` which give
 * the unit prices for specified property values. In a one-dimensional matrix, the matrix values
 * will have `dimension_values` where the second value of the pair is null. If an event does not
 * match any of the dimension values in the matrix, it will resort to the `default_unit_amount`.
 *
 * ```json
 * {
 *     "model_type": "matrix"
 *     "matrix_config": {
 *         "default_unit_amount": "3.00",
 *         "dimensions": [
 *             "cluster_name",
 *             "region"
 *         ],
 *         "matrix_values": [
 *             {
 *                 "dimension_values": [
 *                     "alpha",
 *                     "west"
 *                 ],
 *                 "unit_amount": "2.00"
 *             },
 *             ...
 *         ]
 *     }
 * }
 * ```
 *
 * ## Fixed fees
 *
 * Fixed fees are prices that are applied independent of usage quantities, and follow unit pricing.
 * They also have an additional parameter `fixed_price_quantity`. If the Price represents a fixed
 * cost, this represents the quantity of units applied.
 *
 * ```json
 * {
 *     ...
 *     "id": "price_id",
 *     "model_type": "unit",
 *     "unit_config": {
 *        "unit_amount": "2.00"
 *     },
 *     "fixed_price_quantity": 3.0
 *     ...
 * }
 * ```
 */
@JsonDeserialize(using = Price.Deserializer::class)
@JsonSerialize(using = Price.Serializer::class)
class Price
private constructor(
    private val unitPrice: UnitPrice? = null,
    private val packagePrice: PackagePrice? = null,
    private val matrixPrice: MatrixPrice? = null,
    private val tieredPrice: TieredPrice? = null,
    private val tieredBpsPrice: TieredBpsPrice? = null,
    private val bpsPrice: BpsPrice? = null,
    private val bulkBpsPrice: BulkBpsPrice? = null,
    private val bulkPrice: BulkPrice? = null,
    private val thresholdTotalAmountPrice: ThresholdTotalAmountPrice? = null,
    private val tieredPackagePrice: TieredPackagePrice? = null,
    private val groupedTieredPrice: GroupedTieredPrice? = null,
    private val tieredWithMinimumPrice: TieredWithMinimumPrice? = null,
    private val tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice? = null,
    private val packageWithAllocationPrice: PackageWithAllocationPrice? = null,
    private val unitWithPercentPrice: UnitWithPercentPrice? = null,
    private val matrixWithAllocationPrice: MatrixWithAllocationPrice? = null,
    private val tieredWithProrationPrice: TieredWithProrationPrice? = null,
    private val unitWithProrationPrice: UnitWithProrationPrice? = null,
    private val groupedAllocationPrice: GroupedAllocationPrice? = null,
    private val groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice? = null,
    private val groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice? = null,
    private val matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice? = null,
    private val bulkWithProrationPrice: BulkWithProrationPrice? = null,
    private val groupedTieredPackagePrice: GroupedTieredPackagePrice? = null,
    private val _json: JsonValue? = null,
) {

    fun unitPrice(): Optional<UnitPrice> = Optional.ofNullable(unitPrice)

    fun packagePrice(): Optional<PackagePrice> = Optional.ofNullable(packagePrice)

    fun matrixPrice(): Optional<MatrixPrice> = Optional.ofNullable(matrixPrice)

    fun tieredPrice(): Optional<TieredPrice> = Optional.ofNullable(tieredPrice)

    fun tieredBpsPrice(): Optional<TieredBpsPrice> = Optional.ofNullable(tieredBpsPrice)

    fun bpsPrice(): Optional<BpsPrice> = Optional.ofNullable(bpsPrice)

    fun bulkBpsPrice(): Optional<BulkBpsPrice> = Optional.ofNullable(bulkBpsPrice)

    fun bulkPrice(): Optional<BulkPrice> = Optional.ofNullable(bulkPrice)

    fun thresholdTotalAmountPrice(): Optional<ThresholdTotalAmountPrice> =
        Optional.ofNullable(thresholdTotalAmountPrice)

    fun tieredPackagePrice(): Optional<TieredPackagePrice> = Optional.ofNullable(tieredPackagePrice)

    fun groupedTieredPrice(): Optional<GroupedTieredPrice> = Optional.ofNullable(groupedTieredPrice)

    fun tieredWithMinimumPrice(): Optional<TieredWithMinimumPrice> =
        Optional.ofNullable(tieredWithMinimumPrice)

    fun tieredPackageWithMinimumPrice(): Optional<TieredPackageWithMinimumPrice> =
        Optional.ofNullable(tieredPackageWithMinimumPrice)

    fun packageWithAllocationPrice(): Optional<PackageWithAllocationPrice> =
        Optional.ofNullable(packageWithAllocationPrice)

    fun unitWithPercentPrice(): Optional<UnitWithPercentPrice> =
        Optional.ofNullable(unitWithPercentPrice)

    fun matrixWithAllocationPrice(): Optional<MatrixWithAllocationPrice> =
        Optional.ofNullable(matrixWithAllocationPrice)

    fun tieredWithProrationPrice(): Optional<TieredWithProrationPrice> =
        Optional.ofNullable(tieredWithProrationPrice)

    fun unitWithProrationPrice(): Optional<UnitWithProrationPrice> =
        Optional.ofNullable(unitWithProrationPrice)

    fun groupedAllocationPrice(): Optional<GroupedAllocationPrice> =
        Optional.ofNullable(groupedAllocationPrice)

    fun groupedWithProratedMinimumPrice(): Optional<GroupedWithProratedMinimumPrice> =
        Optional.ofNullable(groupedWithProratedMinimumPrice)

    fun groupedWithMeteredMinimumPrice(): Optional<GroupedWithMeteredMinimumPrice> =
        Optional.ofNullable(groupedWithMeteredMinimumPrice)

    fun matrixWithDisplayNamePrice(): Optional<MatrixWithDisplayNamePrice> =
        Optional.ofNullable(matrixWithDisplayNamePrice)

    fun bulkWithProrationPrice(): Optional<BulkWithProrationPrice> =
        Optional.ofNullable(bulkWithProrationPrice)

    fun groupedTieredPackagePrice(): Optional<GroupedTieredPackagePrice> =
        Optional.ofNullable(groupedTieredPackagePrice)

    fun isUnitPrice(): Boolean = unitPrice != null

    fun isPackagePrice(): Boolean = packagePrice != null

    fun isMatrixPrice(): Boolean = matrixPrice != null

    fun isTieredPrice(): Boolean = tieredPrice != null

    fun isTieredBpsPrice(): Boolean = tieredBpsPrice != null

    fun isBpsPrice(): Boolean = bpsPrice != null

    fun isBulkBpsPrice(): Boolean = bulkBpsPrice != null

    fun isBulkPrice(): Boolean = bulkPrice != null

    fun isThresholdTotalAmountPrice(): Boolean = thresholdTotalAmountPrice != null

    fun isTieredPackagePrice(): Boolean = tieredPackagePrice != null

    fun isGroupedTieredPrice(): Boolean = groupedTieredPrice != null

    fun isTieredWithMinimumPrice(): Boolean = tieredWithMinimumPrice != null

    fun isTieredPackageWithMinimumPrice(): Boolean = tieredPackageWithMinimumPrice != null

    fun isPackageWithAllocationPrice(): Boolean = packageWithAllocationPrice != null

    fun isUnitWithPercentPrice(): Boolean = unitWithPercentPrice != null

    fun isMatrixWithAllocationPrice(): Boolean = matrixWithAllocationPrice != null

    fun isTieredWithProrationPrice(): Boolean = tieredWithProrationPrice != null

    fun isUnitWithProrationPrice(): Boolean = unitWithProrationPrice != null

    fun isGroupedAllocationPrice(): Boolean = groupedAllocationPrice != null

    fun isGroupedWithProratedMinimumPrice(): Boolean = groupedWithProratedMinimumPrice != null

    fun isGroupedWithMeteredMinimumPrice(): Boolean = groupedWithMeteredMinimumPrice != null

    fun isMatrixWithDisplayNamePrice(): Boolean = matrixWithDisplayNamePrice != null

    fun isBulkWithProrationPrice(): Boolean = bulkWithProrationPrice != null

    fun isGroupedTieredPackagePrice(): Boolean = groupedTieredPackagePrice != null

    fun asUnitPrice(): UnitPrice = unitPrice.getOrThrow("unitPrice")

    fun asPackagePrice(): PackagePrice = packagePrice.getOrThrow("packagePrice")

    fun asMatrixPrice(): MatrixPrice = matrixPrice.getOrThrow("matrixPrice")

    fun asTieredPrice(): TieredPrice = tieredPrice.getOrThrow("tieredPrice")

    fun asTieredBpsPrice(): TieredBpsPrice = tieredBpsPrice.getOrThrow("tieredBpsPrice")

    fun asBpsPrice(): BpsPrice = bpsPrice.getOrThrow("bpsPrice")

    fun asBulkBpsPrice(): BulkBpsPrice = bulkBpsPrice.getOrThrow("bulkBpsPrice")

    fun asBulkPrice(): BulkPrice = bulkPrice.getOrThrow("bulkPrice")

    fun asThresholdTotalAmountPrice(): ThresholdTotalAmountPrice =
        thresholdTotalAmountPrice.getOrThrow("thresholdTotalAmountPrice")

    fun asTieredPackagePrice(): TieredPackagePrice =
        tieredPackagePrice.getOrThrow("tieredPackagePrice")

    fun asGroupedTieredPrice(): GroupedTieredPrice =
        groupedTieredPrice.getOrThrow("groupedTieredPrice")

    fun asTieredWithMinimumPrice(): TieredWithMinimumPrice =
        tieredWithMinimumPrice.getOrThrow("tieredWithMinimumPrice")

    fun asTieredPackageWithMinimumPrice(): TieredPackageWithMinimumPrice =
        tieredPackageWithMinimumPrice.getOrThrow("tieredPackageWithMinimumPrice")

    fun asPackageWithAllocationPrice(): PackageWithAllocationPrice =
        packageWithAllocationPrice.getOrThrow("packageWithAllocationPrice")

    fun asUnitWithPercentPrice(): UnitWithPercentPrice =
        unitWithPercentPrice.getOrThrow("unitWithPercentPrice")

    fun asMatrixWithAllocationPrice(): MatrixWithAllocationPrice =
        matrixWithAllocationPrice.getOrThrow("matrixWithAllocationPrice")

    fun asTieredWithProrationPrice(): TieredWithProrationPrice =
        tieredWithProrationPrice.getOrThrow("tieredWithProrationPrice")

    fun asUnitWithProrationPrice(): UnitWithProrationPrice =
        unitWithProrationPrice.getOrThrow("unitWithProrationPrice")

    fun asGroupedAllocationPrice(): GroupedAllocationPrice =
        groupedAllocationPrice.getOrThrow("groupedAllocationPrice")

    fun asGroupedWithProratedMinimumPrice(): GroupedWithProratedMinimumPrice =
        groupedWithProratedMinimumPrice.getOrThrow("groupedWithProratedMinimumPrice")

    fun asGroupedWithMeteredMinimumPrice(): GroupedWithMeteredMinimumPrice =
        groupedWithMeteredMinimumPrice.getOrThrow("groupedWithMeteredMinimumPrice")

    fun asMatrixWithDisplayNamePrice(): MatrixWithDisplayNamePrice =
        matrixWithDisplayNamePrice.getOrThrow("matrixWithDisplayNamePrice")

    fun asBulkWithProrationPrice(): BulkWithProrationPrice =
        bulkWithProrationPrice.getOrThrow("bulkWithProrationPrice")

    fun asGroupedTieredPackagePrice(): GroupedTieredPackagePrice =
        groupedTieredPackagePrice.getOrThrow("groupedTieredPackagePrice")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T {
        return when {
            unitPrice != null -> visitor.visitUnitPrice(unitPrice)
            packagePrice != null -> visitor.visitPackagePrice(packagePrice)
            matrixPrice != null -> visitor.visitMatrixPrice(matrixPrice)
            tieredPrice != null -> visitor.visitTieredPrice(tieredPrice)
            tieredBpsPrice != null -> visitor.visitTieredBpsPrice(tieredBpsPrice)
            bpsPrice != null -> visitor.visitBpsPrice(bpsPrice)
            bulkBpsPrice != null -> visitor.visitBulkBpsPrice(bulkBpsPrice)
            bulkPrice != null -> visitor.visitBulkPrice(bulkPrice)
            thresholdTotalAmountPrice != null ->
                visitor.visitThresholdTotalAmountPrice(thresholdTotalAmountPrice)
            tieredPackagePrice != null -> visitor.visitTieredPackagePrice(tieredPackagePrice)
            groupedTieredPrice != null -> visitor.visitGroupedTieredPrice(groupedTieredPrice)
            tieredWithMinimumPrice != null ->
                visitor.visitTieredWithMinimumPrice(tieredWithMinimumPrice)
            tieredPackageWithMinimumPrice != null ->
                visitor.visitTieredPackageWithMinimumPrice(tieredPackageWithMinimumPrice)
            packageWithAllocationPrice != null ->
                visitor.visitPackageWithAllocationPrice(packageWithAllocationPrice)
            unitWithPercentPrice != null -> visitor.visitUnitWithPercentPrice(unitWithPercentPrice)
            matrixWithAllocationPrice != null ->
                visitor.visitMatrixWithAllocationPrice(matrixWithAllocationPrice)
            tieredWithProrationPrice != null ->
                visitor.visitTieredWithProrationPrice(tieredWithProrationPrice)
            unitWithProrationPrice != null ->
                visitor.visitUnitWithProrationPrice(unitWithProrationPrice)
            groupedAllocationPrice != null ->
                visitor.visitGroupedAllocationPrice(groupedAllocationPrice)
            groupedWithProratedMinimumPrice != null ->
                visitor.visitGroupedWithProratedMinimumPrice(groupedWithProratedMinimumPrice)
            groupedWithMeteredMinimumPrice != null ->
                visitor.visitGroupedWithMeteredMinimumPrice(groupedWithMeteredMinimumPrice)
            matrixWithDisplayNamePrice != null ->
                visitor.visitMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice)
            bulkWithProrationPrice != null ->
                visitor.visitBulkWithProrationPrice(bulkWithProrationPrice)
            groupedTieredPackagePrice != null ->
                visitor.visitGroupedTieredPackagePrice(groupedTieredPackagePrice)
            else -> visitor.unknown(_json)
        }
    }

    private var validated: Boolean = false

    fun validate(): Price = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnitPrice(unitPrice: UnitPrice) {
                    unitPrice.validate()
                }

                override fun visitPackagePrice(packagePrice: PackagePrice) {
                    packagePrice.validate()
                }

                override fun visitMatrixPrice(matrixPrice: MatrixPrice) {
                    matrixPrice.validate()
                }

                override fun visitTieredPrice(tieredPrice: TieredPrice) {
                    tieredPrice.validate()
                }

                override fun visitTieredBpsPrice(tieredBpsPrice: TieredBpsPrice) {
                    tieredBpsPrice.validate()
                }

                override fun visitBpsPrice(bpsPrice: BpsPrice) {
                    bpsPrice.validate()
                }

                override fun visitBulkBpsPrice(bulkBpsPrice: BulkBpsPrice) {
                    bulkBpsPrice.validate()
                }

                override fun visitBulkPrice(bulkPrice: BulkPrice) {
                    bulkPrice.validate()
                }

                override fun visitThresholdTotalAmountPrice(
                    thresholdTotalAmountPrice: ThresholdTotalAmountPrice
                ) {
                    thresholdTotalAmountPrice.validate()
                }

                override fun visitTieredPackagePrice(tieredPackagePrice: TieredPackagePrice) {
                    tieredPackagePrice.validate()
                }

                override fun visitGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice) {
                    groupedTieredPrice.validate()
                }

                override fun visitTieredWithMinimumPrice(
                    tieredWithMinimumPrice: TieredWithMinimumPrice
                ) {
                    tieredWithMinimumPrice.validate()
                }

                override fun visitTieredPackageWithMinimumPrice(
                    tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
                ) {
                    tieredPackageWithMinimumPrice.validate()
                }

                override fun visitPackageWithAllocationPrice(
                    packageWithAllocationPrice: PackageWithAllocationPrice
                ) {
                    packageWithAllocationPrice.validate()
                }

                override fun visitUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice) {
                    unitWithPercentPrice.validate()
                }

                override fun visitMatrixWithAllocationPrice(
                    matrixWithAllocationPrice: MatrixWithAllocationPrice
                ) {
                    matrixWithAllocationPrice.validate()
                }

                override fun visitTieredWithProrationPrice(
                    tieredWithProrationPrice: TieredWithProrationPrice
                ) {
                    tieredWithProrationPrice.validate()
                }

                override fun visitUnitWithProrationPrice(
                    unitWithProrationPrice: UnitWithProrationPrice
                ) {
                    unitWithProrationPrice.validate()
                }

                override fun visitGroupedAllocationPrice(
                    groupedAllocationPrice: GroupedAllocationPrice
                ) {
                    groupedAllocationPrice.validate()
                }

                override fun visitGroupedWithProratedMinimumPrice(
                    groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
                ) {
                    groupedWithProratedMinimumPrice.validate()
                }

                override fun visitGroupedWithMeteredMinimumPrice(
                    groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
                ) {
                    groupedWithMeteredMinimumPrice.validate()
                }

                override fun visitMatrixWithDisplayNamePrice(
                    matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice
                ) {
                    matrixWithDisplayNamePrice.validate()
                }

                override fun visitBulkWithProrationPrice(
                    bulkWithProrationPrice: BulkWithProrationPrice
                ) {
                    bulkWithProrationPrice.validate()
                }

                override fun visitGroupedTieredPackagePrice(
                    groupedTieredPackagePrice: GroupedTieredPackagePrice
                ) {
                    groupedTieredPackagePrice.validate()
                }
            }
        )
        validated = true
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is Price && unitPrice == other.unitPrice && packagePrice == other.packagePrice && matrixPrice == other.matrixPrice && tieredPrice == other.tieredPrice && tieredBpsPrice == other.tieredBpsPrice && bpsPrice == other.bpsPrice && bulkBpsPrice == other.bulkBpsPrice && bulkPrice == other.bulkPrice && thresholdTotalAmountPrice == other.thresholdTotalAmountPrice && tieredPackagePrice == other.tieredPackagePrice && groupedTieredPrice == other.groupedTieredPrice && tieredWithMinimumPrice == other.tieredWithMinimumPrice && tieredPackageWithMinimumPrice == other.tieredPackageWithMinimumPrice && packageWithAllocationPrice == other.packageWithAllocationPrice && unitWithPercentPrice == other.unitWithPercentPrice && matrixWithAllocationPrice == other.matrixWithAllocationPrice && tieredWithProrationPrice == other.tieredWithProrationPrice && unitWithProrationPrice == other.unitWithProrationPrice && groupedAllocationPrice == other.groupedAllocationPrice && groupedWithProratedMinimumPrice == other.groupedWithProratedMinimumPrice && groupedWithMeteredMinimumPrice == other.groupedWithMeteredMinimumPrice && matrixWithDisplayNamePrice == other.matrixWithDisplayNamePrice && bulkWithProrationPrice == other.bulkWithProrationPrice && groupedTieredPackagePrice == other.groupedTieredPackagePrice /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unitPrice, packagePrice, matrixPrice, tieredPrice, tieredBpsPrice, bpsPrice, bulkBpsPrice, bulkPrice, thresholdTotalAmountPrice, tieredPackagePrice, groupedTieredPrice, tieredWithMinimumPrice, tieredPackageWithMinimumPrice, packageWithAllocationPrice, unitWithPercentPrice, matrixWithAllocationPrice, tieredWithProrationPrice, unitWithProrationPrice, groupedAllocationPrice, groupedWithProratedMinimumPrice, groupedWithMeteredMinimumPrice, matrixWithDisplayNamePrice, bulkWithProrationPrice, groupedTieredPackagePrice) /* spotless:on */

    override fun toString(): String =
        when {
            unitPrice != null -> "Price{unitPrice=$unitPrice}"
            packagePrice != null -> "Price{packagePrice=$packagePrice}"
            matrixPrice != null -> "Price{matrixPrice=$matrixPrice}"
            tieredPrice != null -> "Price{tieredPrice=$tieredPrice}"
            tieredBpsPrice != null -> "Price{tieredBpsPrice=$tieredBpsPrice}"
            bpsPrice != null -> "Price{bpsPrice=$bpsPrice}"
            bulkBpsPrice != null -> "Price{bulkBpsPrice=$bulkBpsPrice}"
            bulkPrice != null -> "Price{bulkPrice=$bulkPrice}"
            thresholdTotalAmountPrice != null ->
                "Price{thresholdTotalAmountPrice=$thresholdTotalAmountPrice}"
            tieredPackagePrice != null -> "Price{tieredPackagePrice=$tieredPackagePrice}"
            groupedTieredPrice != null -> "Price{groupedTieredPrice=$groupedTieredPrice}"
            tieredWithMinimumPrice != null ->
                "Price{tieredWithMinimumPrice=$tieredWithMinimumPrice}"
            tieredPackageWithMinimumPrice != null ->
                "Price{tieredPackageWithMinimumPrice=$tieredPackageWithMinimumPrice}"
            packageWithAllocationPrice != null ->
                "Price{packageWithAllocationPrice=$packageWithAllocationPrice}"
            unitWithPercentPrice != null -> "Price{unitWithPercentPrice=$unitWithPercentPrice}"
            matrixWithAllocationPrice != null ->
                "Price{matrixWithAllocationPrice=$matrixWithAllocationPrice}"
            tieredWithProrationPrice != null ->
                "Price{tieredWithProrationPrice=$tieredWithProrationPrice}"
            unitWithProrationPrice != null ->
                "Price{unitWithProrationPrice=$unitWithProrationPrice}"
            groupedAllocationPrice != null ->
                "Price{groupedAllocationPrice=$groupedAllocationPrice}"
            groupedWithProratedMinimumPrice != null ->
                "Price{groupedWithProratedMinimumPrice=$groupedWithProratedMinimumPrice}"
            groupedWithMeteredMinimumPrice != null ->
                "Price{groupedWithMeteredMinimumPrice=$groupedWithMeteredMinimumPrice}"
            matrixWithDisplayNamePrice != null ->
                "Price{matrixWithDisplayNamePrice=$matrixWithDisplayNamePrice}"
            bulkWithProrationPrice != null ->
                "Price{bulkWithProrationPrice=$bulkWithProrationPrice}"
            groupedTieredPackagePrice != null ->
                "Price{groupedTieredPackagePrice=$groupedTieredPackagePrice}"
            _json != null -> "Price{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid Price")
        }

    companion object {

        @JvmStatic fun ofUnitPrice(unitPrice: UnitPrice) = Price(unitPrice = unitPrice)

        @JvmStatic
        fun ofPackagePrice(packagePrice: PackagePrice) = Price(packagePrice = packagePrice)

        @JvmStatic fun ofMatrixPrice(matrixPrice: MatrixPrice) = Price(matrixPrice = matrixPrice)

        @JvmStatic fun ofTieredPrice(tieredPrice: TieredPrice) = Price(tieredPrice = tieredPrice)

        @JvmStatic
        fun ofTieredBpsPrice(tieredBpsPrice: TieredBpsPrice) =
            Price(tieredBpsPrice = tieredBpsPrice)

        @JvmStatic fun ofBpsPrice(bpsPrice: BpsPrice) = Price(bpsPrice = bpsPrice)

        @JvmStatic
        fun ofBulkBpsPrice(bulkBpsPrice: BulkBpsPrice) = Price(bulkBpsPrice = bulkBpsPrice)

        @JvmStatic fun ofBulkPrice(bulkPrice: BulkPrice) = Price(bulkPrice = bulkPrice)

        @JvmStatic
        fun ofThresholdTotalAmountPrice(thresholdTotalAmountPrice: ThresholdTotalAmountPrice) =
            Price(thresholdTotalAmountPrice = thresholdTotalAmountPrice)

        @JvmStatic
        fun ofTieredPackagePrice(tieredPackagePrice: TieredPackagePrice) =
            Price(tieredPackagePrice = tieredPackagePrice)

        @JvmStatic
        fun ofGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice) =
            Price(groupedTieredPrice = groupedTieredPrice)

        @JvmStatic
        fun ofTieredWithMinimumPrice(tieredWithMinimumPrice: TieredWithMinimumPrice) =
            Price(tieredWithMinimumPrice = tieredWithMinimumPrice)

        @JvmStatic
        fun ofTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
        ) = Price(tieredPackageWithMinimumPrice = tieredPackageWithMinimumPrice)

        @JvmStatic
        fun ofPackageWithAllocationPrice(packageWithAllocationPrice: PackageWithAllocationPrice) =
            Price(packageWithAllocationPrice = packageWithAllocationPrice)

        @JvmStatic
        fun ofUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice) =
            Price(unitWithPercentPrice = unitWithPercentPrice)

        @JvmStatic
        fun ofMatrixWithAllocationPrice(matrixWithAllocationPrice: MatrixWithAllocationPrice) =
            Price(matrixWithAllocationPrice = matrixWithAllocationPrice)

        @JvmStatic
        fun ofTieredWithProrationPrice(tieredWithProrationPrice: TieredWithProrationPrice) =
            Price(tieredWithProrationPrice = tieredWithProrationPrice)

        @JvmStatic
        fun ofUnitWithProrationPrice(unitWithProrationPrice: UnitWithProrationPrice) =
            Price(unitWithProrationPrice = unitWithProrationPrice)

        @JvmStatic
        fun ofGroupedAllocationPrice(groupedAllocationPrice: GroupedAllocationPrice) =
            Price(groupedAllocationPrice = groupedAllocationPrice)

        @JvmStatic
        fun ofGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
        ) = Price(groupedWithProratedMinimumPrice = groupedWithProratedMinimumPrice)

        @JvmStatic
        fun ofGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
        ) = Price(groupedWithMeteredMinimumPrice = groupedWithMeteredMinimumPrice)

        @JvmStatic
        fun ofMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice) =
            Price(matrixWithDisplayNamePrice = matrixWithDisplayNamePrice)

        @JvmStatic
        fun ofBulkWithProrationPrice(bulkWithProrationPrice: BulkWithProrationPrice) =
            Price(bulkWithProrationPrice = bulkWithProrationPrice)

        @JvmStatic
        fun ofGroupedTieredPackagePrice(groupedTieredPackagePrice: GroupedTieredPackagePrice) =
            Price(groupedTieredPackagePrice = groupedTieredPackagePrice)
    }

    interface Visitor<out T> {

        fun visitUnitPrice(unitPrice: UnitPrice): T

        fun visitPackagePrice(packagePrice: PackagePrice): T

        fun visitMatrixPrice(matrixPrice: MatrixPrice): T

        fun visitTieredPrice(tieredPrice: TieredPrice): T

        fun visitTieredBpsPrice(tieredBpsPrice: TieredBpsPrice): T

        fun visitBpsPrice(bpsPrice: BpsPrice): T

        fun visitBulkBpsPrice(bulkBpsPrice: BulkBpsPrice): T

        fun visitBulkPrice(bulkPrice: BulkPrice): T

        fun visitThresholdTotalAmountPrice(thresholdTotalAmountPrice: ThresholdTotalAmountPrice): T

        fun visitTieredPackagePrice(tieredPackagePrice: TieredPackagePrice): T

        fun visitGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice): T

        fun visitTieredWithMinimumPrice(tieredWithMinimumPrice: TieredWithMinimumPrice): T

        fun visitTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
        ): T

        fun visitPackageWithAllocationPrice(
            packageWithAllocationPrice: PackageWithAllocationPrice
        ): T

        fun visitUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice): T

        fun visitMatrixWithAllocationPrice(matrixWithAllocationPrice: MatrixWithAllocationPrice): T

        fun visitTieredWithProrationPrice(tieredWithProrationPrice: TieredWithProrationPrice): T

        fun visitUnitWithProrationPrice(unitWithProrationPrice: UnitWithProrationPrice): T

        fun visitGroupedAllocationPrice(groupedAllocationPrice: GroupedAllocationPrice): T

        fun visitGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
        ): T

        fun visitGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
        ): T

        fun visitMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice
        ): T

        fun visitBulkWithProrationPrice(bulkWithProrationPrice: BulkWithProrationPrice): T

        fun visitGroupedTieredPackagePrice(groupedTieredPackagePrice: GroupedTieredPackagePrice): T

        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown Price: $json")
        }
    }

    class Deserializer : BaseDeserializer<Price>(Price::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): Price {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitPrice>()) { it.validate() }
                        ?.let {
                            return Price(unitPrice = it, _json = json)
                        }
                }
                "package" -> {
                    tryDeserialize(node, jacksonTypeRef<PackagePrice>()) { it.validate() }
                        ?.let {
                            return Price(packagePrice = it, _json = json)
                        }
                }
                "matrix" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixPrice>()) { it.validate() }
                        ?.let {
                            return Price(matrixPrice = it, _json = json)
                        }
                }
                "tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredPrice = it, _json = json)
                        }
                }
                "tiered_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredBpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredBpsPrice = it, _json = json)
                        }
                }
                "bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(bpsPrice = it, _json = json)
                        }
                }
                "bulk_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkBpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulkBpsPrice = it, _json = json)
                        }
                }
                "bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulkPrice = it, _json = json)
                        }
                }
                "threshold_total_amount" -> {
                    tryDeserialize(node, jacksonTypeRef<ThresholdTotalAmountPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(thresholdTotalAmountPrice = it, _json = json)
                        }
                }
                "tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackagePrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredPackagePrice = it, _json = json)
                        }
                }
                "grouped_tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPrice>()) { it.validate() }
                        ?.let {
                            return Price(groupedTieredPrice = it, _json = json)
                        }
                }
                "tiered_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithMinimumPrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredWithMinimumPrice = it, _json = json)
                        }
                }
                "tiered_package_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackageWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(tieredPackageWithMinimumPrice = it, _json = json)
                        }
                }
                "package_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<PackageWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(packageWithAllocationPrice = it, _json = json)
                        }
                }
                "unit_with_percent" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithPercentPrice>()) { it.validate() }
                        ?.let {
                            return Price(unitWithPercentPrice = it, _json = json)
                        }
                }
                "matrix_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(matrixWithAllocationPrice = it, _json = json)
                        }
                }
                "tiered_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(tieredWithProrationPrice = it, _json = json)
                        }
                }
                "unit_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return Price(unitWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedAllocationPrice>()) { it.validate() }
                        ?.let {
                            return Price(groupedAllocationPrice = it, _json = json)
                        }
                }
                "grouped_with_prorated_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithProratedMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedWithProratedMinimumPrice = it, _json = json)
                        }
                }
                "grouped_with_metered_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithMeteredMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedWithMeteredMinimumPrice = it, _json = json)
                        }
                }
                "matrix_with_display_name" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithDisplayNamePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(matrixWithDisplayNamePrice = it, _json = json)
                        }
                }
                "bulk_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulkWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedTieredPackagePrice = it, _json = json)
                        }
                }
            }

            return Price(_json = json)
        }
    }

    class Serializer : BaseSerializer<Price>(Price::class) {

        override fun serialize(
            value: Price,
            generator: JsonGenerator,
            provider: SerializerProvider
        ) {
            when {
                value.unitPrice != null -> generator.writeObject(value.unitPrice)
                value.packagePrice != null -> generator.writeObject(value.packagePrice)
                value.matrixPrice != null -> generator.writeObject(value.matrixPrice)
                value.tieredPrice != null -> generator.writeObject(value.tieredPrice)
                value.tieredBpsPrice != null -> generator.writeObject(value.tieredBpsPrice)
                value.bpsPrice != null -> generator.writeObject(value.bpsPrice)
                value.bulkBpsPrice != null -> generator.writeObject(value.bulkBpsPrice)
                value.bulkPrice != null -> generator.writeObject(value.bulkPrice)
                value.thresholdTotalAmountPrice != null ->
                    generator.writeObject(value.thresholdTotalAmountPrice)
                value.tieredPackagePrice != null -> generator.writeObject(value.tieredPackagePrice)
                value.groupedTieredPrice != null -> generator.writeObject(value.groupedTieredPrice)
                value.tieredWithMinimumPrice != null ->
                    generator.writeObject(value.tieredWithMinimumPrice)
                value.tieredPackageWithMinimumPrice != null ->
                    generator.writeObject(value.tieredPackageWithMinimumPrice)
                value.packageWithAllocationPrice != null ->
                    generator.writeObject(value.packageWithAllocationPrice)
                value.unitWithPercentPrice != null ->
                    generator.writeObject(value.unitWithPercentPrice)
                value.matrixWithAllocationPrice != null ->
                    generator.writeObject(value.matrixWithAllocationPrice)
                value.tieredWithProrationPrice != null ->
                    generator.writeObject(value.tieredWithProrationPrice)
                value.unitWithProrationPrice != null ->
                    generator.writeObject(value.unitWithProrationPrice)
                value.groupedAllocationPrice != null ->
                    generator.writeObject(value.groupedAllocationPrice)
                value.groupedWithProratedMinimumPrice != null ->
                    generator.writeObject(value.groupedWithProratedMinimumPrice)
                value.groupedWithMeteredMinimumPrice != null ->
                    generator.writeObject(value.groupedWithMeteredMinimumPrice)
                value.matrixWithDisplayNamePrice != null ->
                    generator.writeObject(value.matrixWithDisplayNamePrice)
                value.bulkWithProrationPrice != null ->
                    generator.writeObject(value.bulkWithProrationPrice)
                value.groupedTieredPackagePrice != null ->
                    generator.writeObject(value.groupedTieredPackagePrice)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid Price")
            }
        }
    }

    @NoAutoDetect
    class UnitPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_config")
        @ExcludeMissing
        private val unitConfig: JsonField<UnitConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfig> = unitConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitConfig: JsonField<UnitConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitPrice: UnitPrice) = apply {
                id = unitPrice.id
                billableMetric = unitPrice.billableMetric
                billingCycleConfiguration = unitPrice.billingCycleConfiguration
                cadence = unitPrice.cadence
                conversionRate = unitPrice.conversionRate
                createdAt = unitPrice.createdAt
                creditAllocation = unitPrice.creditAllocation
                currency = unitPrice.currency
                discount = unitPrice.discount
                externalPriceId = unitPrice.externalPriceId
                fixedPriceQuantity = unitPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitPrice.invoicingCycleConfiguration
                item = unitPrice.item
                maximum = unitPrice.maximum
                maximumAmount = unitPrice.maximumAmount
                metadata = unitPrice.metadata
                minimum = unitPrice.minimum
                minimumAmount = unitPrice.minimumAmount
                modelType = unitPrice.modelType
                name = unitPrice.name
                planPhaseOrder = unitPrice.planPhaseOrder
                priceType = unitPrice.priceType
                unitConfig = unitPrice.unitConfig
                additionalProperties = unitPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

            fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                this.unitConfig = unitConfig
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitPrice =
                UnitPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitConfig", unitConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT = of("unit")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                UNIT,
            }

            enum class Value {
                UNIT,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    UNIT -> Value.UNIT
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    UNIT -> Known.UNIT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitConfig
        @JsonCreator
        private constructor(
            @JsonProperty("unit_amount")
            @ExcludeMissing
            private val unitAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Rate per unit of usage */
            fun unitAmount(): String = unitAmount.getRequired("unit_amount")

            /** Rate per unit of usage */
            @JsonProperty("unit_amount")
            @ExcludeMissing
            fun _unitAmount(): JsonField<String> = unitAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitConfig = apply {
                if (validated) {
                    return@apply
                }

                unitAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var unitAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitConfig: UnitConfig) = apply {
                    unitAmount = unitConfig.unitAmount
                    additionalProperties = unitConfig.additionalProperties.toMutableMap()
                }

                /** Rate per unit of usage */
                fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                /** Rate per unit of usage */
                fun unitAmount(unitAmount: JsonField<String>) = apply {
                    this.unitAmount = unitAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitConfig =
                    UnitConfig(
                        checkRequired("unitAmount", unitAmount),
                        additionalProperties.toImmutable()
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitConfig && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(unitAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitConfig == other.unitConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitConfig=$unitConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_config")
        @ExcludeMissing
        private val packageConfig: JsonField<PackageConfig> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfig> = packageConfig

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageConfig().validate()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packagePrice: PackagePrice) = apply {
                id = packagePrice.id
                billableMetric = packagePrice.billableMetric
                billingCycleConfiguration = packagePrice.billingCycleConfiguration
                cadence = packagePrice.cadence
                conversionRate = packagePrice.conversionRate
                createdAt = packagePrice.createdAt
                creditAllocation = packagePrice.creditAllocation
                currency = packagePrice.currency
                discount = packagePrice.discount
                externalPriceId = packagePrice.externalPriceId
                fixedPriceQuantity = packagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = packagePrice.invoicingCycleConfiguration
                item = packagePrice.item
                maximum = packagePrice.maximum
                maximumAmount = packagePrice.maximumAmount
                metadata = packagePrice.metadata
                minimum = packagePrice.minimum
                minimumAmount = packagePrice.minimumAmount
                modelType = packagePrice.modelType
                name = packagePrice.name
                packageConfig = packagePrice.packageConfig
                planPhaseOrder = packagePrice.planPhaseOrder
                priceType = packagePrice.priceType
                additionalProperties = packagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfig) =
                packageConfig(JsonField.of(packageConfig))

            fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                this.packageConfig = packageConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackagePrice =
                PackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE = of("package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                PACKAGE,
            }

            enum class Value {
                PACKAGE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    PACKAGE -> Value.PACKAGE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    PACKAGE -> Known.PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class PackageConfig
        @JsonCreator
        private constructor(
            @JsonProperty("package_amount")
            @ExcludeMissing
            private val packageAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_size")
            @ExcludeMissing
            private val packageSize: JsonField<Long> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** A currency amount to rate usage by */
            fun packageAmount(): String = packageAmount.getRequired("package_amount")

            /**
             * An integer amount to represent package size. For example, 1000 here would divide
             * usage by 1000 before multiplying by package_amount in rating
             */
            fun packageSize(): Long = packageSize.getRequired("package_size")

            /** A currency amount to rate usage by */
            @JsonProperty("package_amount")
            @ExcludeMissing
            fun _packageAmount(): JsonField<String> = packageAmount

            /**
             * An integer amount to represent package size. For example, 1000 here would divide
             * usage by 1000 before multiplying by package_amount in rating
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<Long> = packageSize

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): PackageConfig = apply {
                if (validated) {
                    return@apply
                }

                packageAmount()
                packageSize()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var packageAmount: JsonField<String>? = null
                private var packageSize: JsonField<Long>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(packageConfig: PackageConfig) = apply {
                    packageAmount = packageConfig.packageAmount
                    packageSize = packageConfig.packageSize
                    additionalProperties = packageConfig.additionalProperties.toMutableMap()
                }

                /** A currency amount to rate usage by */
                fun packageAmount(packageAmount: String) =
                    packageAmount(JsonField.of(packageAmount))

                /** A currency amount to rate usage by */
                fun packageAmount(packageAmount: JsonField<String>) = apply {
                    this.packageAmount = packageAmount
                }

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(packageSize: JsonField<Long>) = apply {
                    this.packageSize = packageSize
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): PackageConfig =
                    PackageConfig(
                        checkRequired("packageAmount", packageAmount),
                        checkRequired("packageSize", packageSize),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PackageConfig && packageAmount == other.packageAmount && packageSize == other.packageSize && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(packageAmount, packageSize, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageConfig, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageConfig=$packageConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_config")
        @ExcludeMissing
        private val matrixConfig: JsonField<MatrixConfig> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfig> = matrixConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixConfig: JsonField<MatrixConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixPrice: MatrixPrice) = apply {
                id = matrixPrice.id
                billableMetric = matrixPrice.billableMetric
                billingCycleConfiguration = matrixPrice.billingCycleConfiguration
                cadence = matrixPrice.cadence
                conversionRate = matrixPrice.conversionRate
                createdAt = matrixPrice.createdAt
                creditAllocation = matrixPrice.creditAllocation
                currency = matrixPrice.currency
                discount = matrixPrice.discount
                externalPriceId = matrixPrice.externalPriceId
                fixedPriceQuantity = matrixPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixPrice.invoicingCycleConfiguration
                item = matrixPrice.item
                matrixConfig = matrixPrice.matrixConfig
                maximum = matrixPrice.maximum
                maximumAmount = matrixPrice.maximumAmount
                metadata = matrixPrice.metadata
                minimum = matrixPrice.minimum
                minimumAmount = matrixPrice.minimumAmount
                modelType = matrixPrice.modelType
                name = matrixPrice.name
                planPhaseOrder = matrixPrice.planPhaseOrder
                priceType = matrixPrice.priceType
                additionalProperties = matrixPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixConfig(matrixConfig: MatrixConfig) = matrixConfig(JsonField.of(matrixConfig))

            fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                this.matrixConfig = matrixConfig
            }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixPrice =
                MatrixPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixConfig
        @JsonCreator
        private constructor(
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            private val defaultUnitAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensions")
            @ExcludeMissing
            private val dimensions: JsonField<List<String?>> = JsonMissing.of(),
            @JsonProperty("matrix_values")
            @ExcludeMissing
            private val matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Default per unit rate for any usage not bucketed into a specified matrix_value */
            fun defaultUnitAmount(): String = defaultUnitAmount.getRequired("default_unit_amount")

            /** One or two event property values to evaluate matrix groups by */
            fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

            /** Matrix values for specified matrix grouping keys */
            fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

            /** Default per unit rate for any usage not bucketed into a specified matrix_value */
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            fun _defaultUnitAmount(): JsonField<String> = defaultUnitAmount

            /** One or two event property values to evaluate matrix groups by */
            @JsonProperty("dimensions")
            @ExcludeMissing
            fun _dimensions(): JsonField<List<String?>> = dimensions

            /** Matrix values for specified matrix grouping keys */
            @JsonProperty("matrix_values")
            @ExcludeMissing
            fun _matrixValues(): JsonField<List<MatrixValue>> = matrixValues

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixConfig = apply {
                if (validated) {
                    return@apply
                }

                defaultUnitAmount()
                dimensions()
                matrixValues().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var defaultUnitAmount: JsonField<String>? = null
                private var dimensions: JsonField<MutableList<String?>>? = null
                private var matrixValues: JsonField<MutableList<MatrixValue>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixConfig: MatrixConfig) = apply {
                    defaultUnitAmount = matrixConfig.defaultUnitAmount
                    dimensions = matrixConfig.dimensions.map { it.toMutableList() }
                    matrixValues = matrixConfig.matrixValues.map { it.toMutableList() }
                    additionalProperties = matrixConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: String) =
                    defaultUnitAmount(JsonField.of(defaultUnitAmount))

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                    this.defaultUnitAmount = defaultUnitAmount
                }

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                    this.dimensions = dimensions.map { it.toMutableList() }
                }

                /** One or two event property values to evaluate matrix groups by */
                fun addDimension(dimension: String) = apply {
                    dimensions =
                        (dimensions ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(dimension)
                        }
                }

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: List<MatrixValue>) =
                    matrixValues(JsonField.of(matrixValues))

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                    this.matrixValues = matrixValues.map { it.toMutableList() }
                }

                /** Matrix values for specified matrix grouping keys */
                fun addMatrixValue(matrixValue: MatrixValue) = apply {
                    matrixValues =
                        (matrixValues ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(matrixValue)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixConfig =
                    MatrixConfig(
                        checkRequired("defaultUnitAmount", defaultUnitAmount),
                        checkRequired("dimensions", dimensions).map { it.toImmutable() },
                        checkRequired("matrixValues", matrixValues).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class MatrixValue
            @JsonCreator
            private constructor(
                @JsonProperty("dimension_values")
                @ExcludeMissing
                private val dimensionValues: JsonField<List<String?>> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 */
                fun dimensionValues(): List<String?> =
                    dimensionValues.getRequired("dimension_values")

                /** Unit price for the specified dimension_values */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 */
                @JsonProperty("dimension_values")
                @ExcludeMissing
                fun _dimensionValues(): JsonField<List<String?>> = dimensionValues

                /** Unit price for the specified dimension_values */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): MatrixValue = apply {
                    if (validated) {
                        return@apply
                    }

                    dimensionValues()
                    unitAmount()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var dimensionValues: JsonField<MutableList<String?>>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixValue: MatrixValue) = apply {
                        dimensionValues = matrixValue.dimensionValues.map { it.toMutableList() }
                        unitAmount = matrixValue.unitAmount
                        additionalProperties = matrixValue.additionalProperties.toMutableMap()
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: List<String?>) =
                        dimensionValues(JsonField.of(dimensionValues))

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                        this.dimensionValues = dimensionValues.map { it.toMutableList() }
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun addDimensionValue(dimensionValue: String) = apply {
                        dimensionValues =
                            (dimensionValues ?: JsonField.of(mutableListOf())).apply {
                                asKnown()
                                    .orElseThrow {
                                        IllegalStateException(
                                            "Field was set to non-list type: ${javaClass.simpleName}"
                                        )
                                    }
                                    .add(dimensionValue)
                            }
                    }

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixValue =
                        MatrixValue(
                            checkRequired("dimensionValues", dimensionValues).map {
                                it.toImmutable()
                            },
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixValue && dimensionValues == other.dimensionValues && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(dimensionValues, unitAmount, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixValue{dimensionValues=$dimensionValues, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixConfig && defaultUnitAmount == other.defaultUnitAmount && dimensions == other.dimensions && matrixValues == other.matrixValues && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(defaultUnitAmount, dimensions, matrixValues, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixConfig{defaultUnitAmount=$defaultUnitAmount, dimensions=$dimensions, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX = of("matrix")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                MATRIX,
            }

            enum class Value {
                MATRIX,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    MATRIX -> Value.MATRIX
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    MATRIX -> Known.MATRIX
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixConfig == other.matrixConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixConfig=$matrixConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_config")
        @ExcludeMissing
        private val tieredConfig: JsonField<TieredConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfig> = tieredConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredConfig: JsonField<TieredConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPrice: TieredPrice) = apply {
                id = tieredPrice.id
                billableMetric = tieredPrice.billableMetric
                billingCycleConfiguration = tieredPrice.billingCycleConfiguration
                cadence = tieredPrice.cadence
                conversionRate = tieredPrice.conversionRate
                createdAt = tieredPrice.createdAt
                creditAllocation = tieredPrice.creditAllocation
                currency = tieredPrice.currency
                discount = tieredPrice.discount
                externalPriceId = tieredPrice.externalPriceId
                fixedPriceQuantity = tieredPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPrice.invoicingCycleConfiguration
                item = tieredPrice.item
                maximum = tieredPrice.maximum
                maximumAmount = tieredPrice.maximumAmount
                metadata = tieredPrice.metadata
                minimum = tieredPrice.minimum
                minimumAmount = tieredPrice.minimumAmount
                modelType = tieredPrice.modelType
                name = tieredPrice.name
                planPhaseOrder = tieredPrice.planPhaseOrder
                priceType = tieredPrice.priceType
                tieredConfig = tieredPrice.tieredConfig
                additionalProperties = tieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredConfig(tieredConfig: TieredConfig) = tieredConfig(JsonField.of(tieredConfig))

            fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                this.tieredConfig = tieredConfig
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPrice =
                TieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredConfig", tieredConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED = of("tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED,
            }

            enum class Value {
                TIERED,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED -> Value.TIERED
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED -> Known.TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Tiers for rating based on total usage quantities into the specified tier */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /** Tiers for rating based on total usage quantities into the specified tier */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredConfig: TieredConfig) = apply {
                    tiers = tieredConfig.tiers.map { it.toMutableList() }
                    additionalProperties = tieredConfig.additionalProperties.toMutableMap()
                }

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredConfig =
                    TieredConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable()
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("first_unit")
                @ExcludeMissing
                private val firstUnit: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("last_unit")
                @ExcludeMissing
                private val lastUnit: JsonField<Double> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Inclusive tier starting value */
                fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                /** Amount per unit */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /** Exclusive tier ending value. If null, this is treated as the last tier */
                fun lastUnit(): Optional<Double> =
                    Optional.ofNullable(lastUnit.getNullable("last_unit"))

                /** Inclusive tier starting value */
                @JsonProperty("first_unit")
                @ExcludeMissing
                fun _firstUnit(): JsonField<Double> = firstUnit

                /** Amount per unit */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /** Exclusive tier ending value. If null, this is treated as the last tier */
                @JsonProperty("last_unit")
                @ExcludeMissing
                fun _lastUnit(): JsonField<Double> = lastUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    firstUnit()
                    unitAmount()
                    lastUnit()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var firstUnit: JsonField<Double>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var lastUnit: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        firstUnit = tier.firstUnit
                        unitAmount = tier.unitAmount
                        lastUnit = tier.lastUnit
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Inclusive tier starting value */
                    fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                    /** Inclusive tier starting value */
                    fun firstUnit(firstUnit: JsonField<Double>) = apply {
                        this.firstUnit = firstUnit
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Amount per unit */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(lastUnit: Double?) = lastUnit(JsonField.ofNullable(lastUnit))

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(lastUnit: Double) = lastUnit(lastUnit as Double?)

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                    fun lastUnit(lastUnit: Optional<Double>) =
                        lastUnit(lastUnit.orElse(null) as Double?)

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(lastUnit: JsonField<Double>) = apply { this.lastUnit = lastUnit }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("firstUnit", firstUnit),
                            checkRequired("unitAmount", unitAmount),
                            lastUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && firstUnit == other.firstUnit && unitAmount == other.unitAmount && lastUnit == other.lastUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(firstUnit, unitAmount, lastUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{firstUnit=$firstUnit, unitAmount=$unitAmount, lastUnit=$lastUnit, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredConfig == other.tieredConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredConfig=$tieredConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        private val tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredBpsConfig(): TieredBpsConfig = tieredBpsConfig.getRequired("tiered_bps_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfig> = tieredBpsConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredBpsConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredBpsPrice: TieredBpsPrice) = apply {
                id = tieredBpsPrice.id
                billableMetric = tieredBpsPrice.billableMetric
                billingCycleConfiguration = tieredBpsPrice.billingCycleConfiguration
                cadence = tieredBpsPrice.cadence
                conversionRate = tieredBpsPrice.conversionRate
                createdAt = tieredBpsPrice.createdAt
                creditAllocation = tieredBpsPrice.creditAllocation
                currency = tieredBpsPrice.currency
                discount = tieredBpsPrice.discount
                externalPriceId = tieredBpsPrice.externalPriceId
                fixedPriceQuantity = tieredBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredBpsPrice.invoicingCycleConfiguration
                item = tieredBpsPrice.item
                maximum = tieredBpsPrice.maximum
                maximumAmount = tieredBpsPrice.maximumAmount
                metadata = tieredBpsPrice.metadata
                minimum = tieredBpsPrice.minimum
                minimumAmount = tieredBpsPrice.minimumAmount
                modelType = tieredBpsPrice.modelType
                name = tieredBpsPrice.name
                planPhaseOrder = tieredBpsPrice.planPhaseOrder
                priceType = tieredBpsPrice.priceType
                tieredBpsConfig = tieredBpsPrice.tieredBpsConfig
                additionalProperties = tieredBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredBpsPrice =
                TieredBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_BPS = of("tiered_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED_BPS,
            }

            enum class Value {
                TIERED_BPS,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED_BPS -> Value.TIERED_BPS
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED_BPS -> Known.TIERED_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredBpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified tiers
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified tiers
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredBpsConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                    tiers = tieredBpsConfig.tiers.map { it.toMutableList() }
                    additionalProperties = tieredBpsConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredBpsConfig =
                    TieredBpsConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable()
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("bps")
                @ExcludeMissing
                private val bps: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                private val minimumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                private val maximumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Per-event basis point rate */
                fun bps(): Double = bps.getRequired("bps")

                /** Inclusive tier starting value */
                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /** Exclusive tier ending value */
                fun maximumAmount(): Optional<String> =
                    Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                /** Per unit maximum to charge */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /** Per-event basis point rate */
                @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

                /** Inclusive tier starting value */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun _minimumAmount(): JsonField<String> = minimumAmount

                /** Exclusive tier ending value */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun _maximumAmount(): JsonField<String> = maximumAmount

                /** Per unit maximum to charge */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    bps()
                    minimumAmount()
                    maximumAmount()
                    perUnitMaximum()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: JsonField<Double>? = null
                    private var minimumAmount: JsonField<String>? = null
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        bps = tier.bps
                        minimumAmount = tier.minimumAmount
                        maximumAmount = tier.maximumAmount
                        perUnitMaximum = tier.perUnitMaximum
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Per-event basis point rate */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /** Per-event basis point rate */
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Inclusive tier starting value */
                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    /** Inclusive tier starting value */
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** Exclusive tier ending value */
                    fun maximumAmount(maximumAmount: String?) =
                        maximumAmount(JsonField.ofNullable(maximumAmount))

                    /** Exclusive tier ending value */
                    fun maximumAmount(maximumAmount: Optional<String>) =
                        maximumAmount(maximumAmount.orElse(null))

                    /** Exclusive tier ending value */
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(perUnitMaximum: String?) =
                        perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                        perUnitMaximum(perUnitMaximum.orElse(null))

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("bps", bps),
                            checkRequired("minimumAmount", minimumAmount),
                            maximumAmount,
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && bps == other.bps && minimumAmount == other.minimumAmount && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(bps, minimumAmount, maximumAmount, perUnitMaximum, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{bps=$bps, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredBpsConfig == other.tieredBpsConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredBpsConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredBpsConfig=$tieredBpsConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bps_config")
        @ExcludeMissing
        private val bpsConfig: JsonField<BpsConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfig> = bpsConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bpsConfig: JsonField<BpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bpsPrice: BpsPrice) = apply {
                id = bpsPrice.id
                billableMetric = bpsPrice.billableMetric
                billingCycleConfiguration = bpsPrice.billingCycleConfiguration
                bpsConfig = bpsPrice.bpsConfig
                cadence = bpsPrice.cadence
                conversionRate = bpsPrice.conversionRate
                createdAt = bpsPrice.createdAt
                creditAllocation = bpsPrice.creditAllocation
                currency = bpsPrice.currency
                discount = bpsPrice.discount
                externalPriceId = bpsPrice.externalPriceId
                fixedPriceQuantity = bpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bpsPrice.invoicingCycleConfiguration
                item = bpsPrice.item
                maximum = bpsPrice.maximum
                maximumAmount = bpsPrice.maximumAmount
                metadata = bpsPrice.metadata
                minimum = bpsPrice.minimum
                minimumAmount = bpsPrice.minimumAmount
                modelType = bpsPrice.modelType
                name = bpsPrice.name
                planPhaseOrder = bpsPrice.planPhaseOrder
                priceType = bpsPrice.priceType
                additionalProperties = bpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

            fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply { this.bpsConfig = bpsConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BpsPrice =
                BpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("bps")
            @ExcludeMissing
            private val bps: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("per_unit_maximum")
            @ExcludeMissing
            private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Basis point take rate per event */
            fun bps(): Double = bps.getRequired("bps")

            /** Optional currency amount maximum to cap spend per event */
            fun perUnitMaximum(): Optional<String> =
                Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

            /** Basis point take rate per event */
            @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

            /** Optional currency amount maximum to cap spend per event */
            @JsonProperty("per_unit_maximum")
            @ExcludeMissing
            fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BpsConfig = apply {
                if (validated) {
                    return@apply
                }

                bps()
                perUnitMaximum()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var bps: JsonField<Double>? = null
                private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bpsConfig: BpsConfig) = apply {
                    bps = bpsConfig.bps
                    perUnitMaximum = bpsConfig.perUnitMaximum
                    additionalProperties = bpsConfig.additionalProperties.toMutableMap()
                }

                /** Basis point take rate per event */
                fun bps(bps: Double) = bps(JsonField.of(bps))

                /** Basis point take rate per event */
                fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(perUnitMaximum: String?) =
                    perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                    perUnitMaximum(perUnitMaximum.orElse(null))

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                    this.perUnitMaximum = perUnitMaximum
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BpsConfig =
                    BpsConfig(
                        checkRequired("bps", bps),
                        perUnitMaximum,
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BpsConfig && bps == other.bps && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bps, perUnitMaximum, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BPS = of("bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                BPS,
            }

            enum class Value {
                BPS,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    BPS -> Value.BPS
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    BPS -> Known.BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bpsConfig == other.bpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bpsConfig=$bpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        private val bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfig> = bulkBpsConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkBpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkBpsConfig: JsonField<BulkBpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkBpsPrice: BulkBpsPrice) = apply {
                id = bulkBpsPrice.id
                billableMetric = bulkBpsPrice.billableMetric
                billingCycleConfiguration = bulkBpsPrice.billingCycleConfiguration
                bulkBpsConfig = bulkBpsPrice.bulkBpsConfig
                cadence = bulkBpsPrice.cadence
                conversionRate = bulkBpsPrice.conversionRate
                createdAt = bulkBpsPrice.createdAt
                creditAllocation = bulkBpsPrice.creditAllocation
                currency = bulkBpsPrice.currency
                discount = bulkBpsPrice.discount
                externalPriceId = bulkBpsPrice.externalPriceId
                fixedPriceQuantity = bulkBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkBpsPrice.invoicingCycleConfiguration
                item = bulkBpsPrice.item
                maximum = bulkBpsPrice.maximum
                maximumAmount = bulkBpsPrice.maximumAmount
                metadata = bulkBpsPrice.metadata
                minimum = bulkBpsPrice.minimum
                minimumAmount = bulkBpsPrice.minimumAmount
                modelType = bulkBpsPrice.modelType
                name = bulkBpsPrice.name
                planPhaseOrder = bulkBpsPrice.planPhaseOrder
                priceType = bulkBpsPrice.priceType
                additionalProperties = bulkBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkBpsPrice =
                BulkBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkBpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
             * based on total volume
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
             * based on total volume
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkBpsConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                    tiers = bulkBpsConfig.tiers.map { it.toMutableList() }
                    additionalProperties = bulkBpsConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkBpsConfig =
                    BulkBpsConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable()
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("bps")
                @ExcludeMissing
                private val bps: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                private val maximumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Basis points to rate on */
                fun bps(): Double = bps.getRequired("bps")

                /** Upper bound for tier */
                fun maximumAmount(): Optional<String> =
                    Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                /** The maximum amount to charge for any one event */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /** Basis points to rate on */
                @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

                /** Upper bound for tier */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun _maximumAmount(): JsonField<String> = maximumAmount

                /** The maximum amount to charge for any one event */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    bps()
                    maximumAmount()
                    perUnitMaximum()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var bps: JsonField<Double>? = null
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        bps = tier.bps
                        maximumAmount = tier.maximumAmount
                        perUnitMaximum = tier.perUnitMaximum
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Basis points to rate on */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /** Basis points to rate on */
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Upper bound for tier */
                    fun maximumAmount(maximumAmount: String?) =
                        maximumAmount(JsonField.ofNullable(maximumAmount))

                    /** Upper bound for tier */
                    fun maximumAmount(maximumAmount: Optional<String>) =
                        maximumAmount(maximumAmount.orElse(null))

                    /** Upper bound for tier */
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(perUnitMaximum: String?) =
                        perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                        perUnitMaximum(perUnitMaximum.orElse(null))

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("bps", bps),
                            maximumAmount,
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && bps == other.bps && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(bps, maximumAmount, perUnitMaximum, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{bps=$bps, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_BPS = of("bulk_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                BULK_BPS,
            }

            enum class Value {
                BULK_BPS,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    BULK_BPS -> Value.BULK_BPS
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    BULK_BPS -> Known.BULK_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkBpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_config")
        @ExcludeMissing
        private val bulkConfig: JsonField<BulkConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfig> = bulkConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkConfig: JsonField<BulkConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkPrice: BulkPrice) = apply {
                id = bulkPrice.id
                billableMetric = bulkPrice.billableMetric
                billingCycleConfiguration = bulkPrice.billingCycleConfiguration
                bulkConfig = bulkPrice.bulkConfig
                cadence = bulkPrice.cadence
                conversionRate = bulkPrice.conversionRate
                createdAt = bulkPrice.createdAt
                creditAllocation = bulkPrice.creditAllocation
                currency = bulkPrice.currency
                discount = bulkPrice.discount
                externalPriceId = bulkPrice.externalPriceId
                fixedPriceQuantity = bulkPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkPrice.invoicingCycleConfiguration
                item = bulkPrice.item
                maximum = bulkPrice.maximum
                maximumAmount = bulkPrice.maximumAmount
                metadata = bulkPrice.metadata
                minimum = bulkPrice.minimum
                minimumAmount = bulkPrice.minimumAmount
                modelType = bulkPrice.modelType
                name = bulkPrice.name
                planPhaseOrder = bulkPrice.planPhaseOrder
                priceType = bulkPrice.priceType
                additionalProperties = bulkPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

            fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                this.bulkConfig = bulkConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkPrice =
                BulkPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Bulk tiers for rating based on total usage volume */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /** Bulk tiers for rating based on total usage volume */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkConfig: BulkConfig) = apply {
                    tiers = bulkConfig.tiers.map { it.toMutableList() }
                    additionalProperties = bulkConfig.additionalProperties.toMutableMap()
                }

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /** Bulk tiers for rating based on total usage volume */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkConfig =
                    BulkConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable()
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("maximum_units")
                @ExcludeMissing
                private val maximumUnits: JsonField<Double> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /** Amount per unit */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /** Upper bound for this tier */
                fun maximumUnits(): Optional<Double> =
                    Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                /** Amount per unit */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /** Upper bound for this tier */
                @JsonProperty("maximum_units")
                @ExcludeMissing
                fun _maximumUnits(): JsonField<Double> = maximumUnits

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    unitAmount()
                    maximumUnits()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var unitAmount: JsonField<String>? = null
                    private var maximumUnits: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        unitAmount = tier.unitAmount
                        maximumUnits = tier.maximumUnits
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Amount per unit */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** Upper bound for this tier */
                    fun maximumUnits(maximumUnits: Double?) =
                        maximumUnits(JsonField.ofNullable(maximumUnits))

                    /** Upper bound for this tier */
                    fun maximumUnits(maximumUnits: Double) = maximumUnits(maximumUnits as Double?)

                    /** Upper bound for this tier */
                    @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
                    fun maximumUnits(maximumUnits: Optional<Double>) =
                        maximumUnits(maximumUnits.orElse(null) as Double?)

                    /** Upper bound for this tier */
                    fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                        this.maximumUnits = maximumUnits
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("unitAmount", unitAmount),
                            maximumUnits,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && unitAmount == other.unitAmount && maximumUnits == other.maximumUnits && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(unitAmount, maximumUnits, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{unitAmount=$unitAmount, maximumUnits=$maximumUnits, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK = of("bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                BULK,
            }

            enum class Value {
                BULK,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    BULK -> Value.BULK
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    BULK -> Known.BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkConfig == other.bulkConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkConfig=$bulkConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ThresholdTotalAmountPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<ThresholdTotalAmountConfig> =
            thresholdTotalAmountConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ThresholdTotalAmountPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            thresholdTotalAmountConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(thresholdTotalAmountPrice: ThresholdTotalAmountPrice) = apply {
                id = thresholdTotalAmountPrice.id
                billableMetric = thresholdTotalAmountPrice.billableMetric
                billingCycleConfiguration = thresholdTotalAmountPrice.billingCycleConfiguration
                cadence = thresholdTotalAmountPrice.cadence
                conversionRate = thresholdTotalAmountPrice.conversionRate
                createdAt = thresholdTotalAmountPrice.createdAt
                creditAllocation = thresholdTotalAmountPrice.creditAllocation
                currency = thresholdTotalAmountPrice.currency
                discount = thresholdTotalAmountPrice.discount
                externalPriceId = thresholdTotalAmountPrice.externalPriceId
                fixedPriceQuantity = thresholdTotalAmountPrice.fixedPriceQuantity
                invoicingCycleConfiguration = thresholdTotalAmountPrice.invoicingCycleConfiguration
                item = thresholdTotalAmountPrice.item
                maximum = thresholdTotalAmountPrice.maximum
                maximumAmount = thresholdTotalAmountPrice.maximumAmount
                metadata = thresholdTotalAmountPrice.metadata
                minimum = thresholdTotalAmountPrice.minimum
                minimumAmount = thresholdTotalAmountPrice.minimumAmount
                modelType = thresholdTotalAmountPrice.modelType
                name = thresholdTotalAmountPrice.name
                planPhaseOrder = thresholdTotalAmountPrice.planPhaseOrder
                priceType = thresholdTotalAmountPrice.priceType
                thresholdTotalAmountConfig = thresholdTotalAmountPrice.thresholdTotalAmountConfig
                additionalProperties = thresholdTotalAmountPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun thresholdTotalAmountConfig(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ThresholdTotalAmountPrice =
                ThresholdTotalAmountPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                THRESHOLD_TOTAL_AMOUNT,
            }

            enum class Value {
                THRESHOLD_TOTAL_AMOUNT,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class ThresholdTotalAmountConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): ThresholdTotalAmountConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) = apply {
                    additionalProperties =
                        thresholdTotalAmountConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): ThresholdTotalAmountConfig =
                    ThresholdTotalAmountConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ThresholdTotalAmountConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ThresholdTotalAmountPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, thresholdTotalAmountConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ThresholdTotalAmountPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        private val tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredPackageConfig(): TieredPackageConfig =
            tieredPackageConfig.getRequired("tiered_package_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<TieredPackageConfig> = tieredPackageConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageConfig: JsonField<TieredPackageConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackagePrice: TieredPackagePrice) = apply {
                id = tieredPackagePrice.id
                billableMetric = tieredPackagePrice.billableMetric
                billingCycleConfiguration = tieredPackagePrice.billingCycleConfiguration
                cadence = tieredPackagePrice.cadence
                conversionRate = tieredPackagePrice.conversionRate
                createdAt = tieredPackagePrice.createdAt
                creditAllocation = tieredPackagePrice.creditAllocation
                currency = tieredPackagePrice.currency
                discount = tieredPackagePrice.discount
                externalPriceId = tieredPackagePrice.externalPriceId
                fixedPriceQuantity = tieredPackagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackagePrice.invoicingCycleConfiguration
                item = tieredPackagePrice.item
                maximum = tieredPackagePrice.maximum
                maximumAmount = tieredPackagePrice.maximumAmount
                metadata = tieredPackagePrice.metadata
                minimum = tieredPackagePrice.minimum
                minimumAmount = tieredPackagePrice.minimumAmount
                modelType = tieredPackagePrice.modelType
                name = tieredPackagePrice.name
                planPhaseOrder = tieredPackagePrice.planPhaseOrder
                priceType = tieredPackagePrice.priceType
                tieredPackageConfig = tieredPackagePrice.tieredPackageConfig
                additionalProperties = tieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) = apply {
                this.tieredPackageConfig = tieredPackageConfig
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackagePrice =
                TieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE = of("tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED_PACKAGE,
            }

            enum class Value {
                TIERED_PACKAGE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE -> Value.TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE -> Known.TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredPackageConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                    additionalProperties = tieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredPackageConfig =
                    TieredPackageConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageConfig == other.tieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageConfig=$tieredPackageConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        private val groupedTieredConfig: JsonField<GroupedTieredConfig> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedTieredConfig(): GroupedTieredConfig =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<GroupedTieredConfig> = groupedTieredConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredConfig: JsonField<GroupedTieredConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPrice: GroupedTieredPrice) = apply {
                id = groupedTieredPrice.id
                billableMetric = groupedTieredPrice.billableMetric
                billingCycleConfiguration = groupedTieredPrice.billingCycleConfiguration
                cadence = groupedTieredPrice.cadence
                conversionRate = groupedTieredPrice.conversionRate
                createdAt = groupedTieredPrice.createdAt
                creditAllocation = groupedTieredPrice.creditAllocation
                currency = groupedTieredPrice.currency
                discount = groupedTieredPrice.discount
                externalPriceId = groupedTieredPrice.externalPriceId
                fixedPriceQuantity = groupedTieredPrice.fixedPriceQuantity
                groupedTieredConfig = groupedTieredPrice.groupedTieredConfig
                invoicingCycleConfiguration = groupedTieredPrice.invoicingCycleConfiguration
                item = groupedTieredPrice.item
                maximum = groupedTieredPrice.maximum
                maximumAmount = groupedTieredPrice.maximumAmount
                metadata = groupedTieredPrice.metadata
                minimum = groupedTieredPrice.minimum
                minimumAmount = groupedTieredPrice.minimumAmount
                modelType = groupedTieredPrice.modelType
                name = groupedTieredPrice.name
                planPhaseOrder = groupedTieredPrice.planPhaseOrder
                priceType = groupedTieredPrice.priceType
                additionalProperties = groupedTieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredConfig(groupedTieredConfig: GroupedTieredConfig) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            fun groupedTieredConfig(groupedTieredConfig: JsonField<GroupedTieredConfig>) = apply {
                this.groupedTieredConfig = groupedTieredConfig
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPrice =
                GroupedTieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedTieredConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedTieredConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredConfig: GroupedTieredConfig) = apply {
                    additionalProperties = groupedTieredConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedTieredConfig =
                    GroupedTieredConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED = of("grouped_tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                GROUPED_TIERED,
            }

            enum class Value {
                GROUPED_TIERED,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    GROUPED_TIERED -> Value.GROUPED_TIERED
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    GROUPED_TIERED -> Known.GROUPED_TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredConfig == other.groupedTieredConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredConfig=$groupedTieredConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<TieredWithMinimumConfig> = tieredWithMinimumConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithMinimumConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithMinimumPrice: TieredWithMinimumPrice) = apply {
                id = tieredWithMinimumPrice.id
                billableMetric = tieredWithMinimumPrice.billableMetric
                billingCycleConfiguration = tieredWithMinimumPrice.billingCycleConfiguration
                cadence = tieredWithMinimumPrice.cadence
                conversionRate = tieredWithMinimumPrice.conversionRate
                createdAt = tieredWithMinimumPrice.createdAt
                creditAllocation = tieredWithMinimumPrice.creditAllocation
                currency = tieredWithMinimumPrice.currency
                discount = tieredWithMinimumPrice.discount
                externalPriceId = tieredWithMinimumPrice.externalPriceId
                fixedPriceQuantity = tieredWithMinimumPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithMinimumPrice.invoicingCycleConfiguration
                item = tieredWithMinimumPrice.item
                maximum = tieredWithMinimumPrice.maximum
                maximumAmount = tieredWithMinimumPrice.maximumAmount
                metadata = tieredWithMinimumPrice.metadata
                minimum = tieredWithMinimumPrice.minimum
                minimumAmount = tieredWithMinimumPrice.minimumAmount
                modelType = tieredWithMinimumPrice.modelType
                name = tieredWithMinimumPrice.name
                planPhaseOrder = tieredWithMinimumPrice.planPhaseOrder
                priceType = tieredWithMinimumPrice.priceType
                tieredWithMinimumConfig = tieredWithMinimumPrice.tieredWithMinimumConfig
                additionalProperties = tieredWithMinimumPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithMinimumPrice =
                TieredWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED_WITH_MINIMUM,
            }

            enum class Value {
                TIERED_WITH_MINIMUM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredWithMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                    additionalProperties =
                        tieredWithMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredWithMinimumConfig =
                    TieredWithMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithMinimumConfig == other.tieredWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithMinimumConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithMinimumConfig=$tieredWithMinimumConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackageWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        private val tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredPackageWithMinimumConfig(): TieredPackageWithMinimumConfig =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<TieredPackageWithMinimumConfig> =
            tieredPackageWithMinimumConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackageWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageWithMinimumConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>? =
                null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice) =
                apply {
                    id = tieredPackageWithMinimumPrice.id
                    billableMetric = tieredPackageWithMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        tieredPackageWithMinimumPrice.billingCycleConfiguration
                    cadence = tieredPackageWithMinimumPrice.cadence
                    conversionRate = tieredPackageWithMinimumPrice.conversionRate
                    createdAt = tieredPackageWithMinimumPrice.createdAt
                    creditAllocation = tieredPackageWithMinimumPrice.creditAllocation
                    currency = tieredPackageWithMinimumPrice.currency
                    discount = tieredPackageWithMinimumPrice.discount
                    externalPriceId = tieredPackageWithMinimumPrice.externalPriceId
                    fixedPriceQuantity = tieredPackageWithMinimumPrice.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        tieredPackageWithMinimumPrice.invoicingCycleConfiguration
                    item = tieredPackageWithMinimumPrice.item
                    maximum = tieredPackageWithMinimumPrice.maximum
                    maximumAmount = tieredPackageWithMinimumPrice.maximumAmount
                    metadata = tieredPackageWithMinimumPrice.metadata
                    minimum = tieredPackageWithMinimumPrice.minimum
                    minimumAmount = tieredPackageWithMinimumPrice.minimumAmount
                    modelType = tieredPackageWithMinimumPrice.modelType
                    name = tieredPackageWithMinimumPrice.name
                    planPhaseOrder = tieredPackageWithMinimumPrice.planPhaseOrder
                    priceType = tieredPackageWithMinimumPrice.priceType
                    tieredPackageWithMinimumConfig =
                        tieredPackageWithMinimumPrice.tieredPackageWithMinimumConfig
                    additionalProperties =
                        tieredPackageWithMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackageWithMinimumPrice =
                TieredPackageWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE_WITH_MINIMUM = of("tiered_package_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED_PACKAGE_WITH_MINIMUM,
            }

            enum class Value {
                TIERED_PACKAGE_WITH_MINIMUM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Value.TIERED_PACKAGE_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Known.TIERED_PACKAGE_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredPackageWithMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredPackageWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig) =
                    apply {
                        additionalProperties =
                            tieredPackageWithMinimumConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredPackageWithMinimumConfig =
                    TieredPackageWithMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackageWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageWithMinimumConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackageWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackageWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> =
            JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun packageWithAllocationConfig(): PackageWithAllocationConfig =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<PackageWithAllocationConfig> =
            packageWithAllocationConfig

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackageWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageWithAllocationConfig().validate()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packageWithAllocationPrice: PackageWithAllocationPrice) = apply {
                id = packageWithAllocationPrice.id
                billableMetric = packageWithAllocationPrice.billableMetric
                billingCycleConfiguration = packageWithAllocationPrice.billingCycleConfiguration
                cadence = packageWithAllocationPrice.cadence
                conversionRate = packageWithAllocationPrice.conversionRate
                createdAt = packageWithAllocationPrice.createdAt
                creditAllocation = packageWithAllocationPrice.creditAllocation
                currency = packageWithAllocationPrice.currency
                discount = packageWithAllocationPrice.discount
                externalPriceId = packageWithAllocationPrice.externalPriceId
                fixedPriceQuantity = packageWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = packageWithAllocationPrice.invoicingCycleConfiguration
                item = packageWithAllocationPrice.item
                maximum = packageWithAllocationPrice.maximum
                maximumAmount = packageWithAllocationPrice.maximumAmount
                metadata = packageWithAllocationPrice.metadata
                minimum = packageWithAllocationPrice.minimum
                minimumAmount = packageWithAllocationPrice.minimumAmount
                modelType = packageWithAllocationPrice.modelType
                name = packageWithAllocationPrice.name
                packageWithAllocationConfig = packageWithAllocationPrice.packageWithAllocationConfig
                planPhaseOrder = packageWithAllocationPrice.planPhaseOrder
                priceType = packageWithAllocationPrice.priceType
                additionalProperties =
                    packageWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: PackageWithAllocationConfig
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackageWithAllocationPrice =
                PackageWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                PACKAGE_WITH_ALLOCATION,
            }

            enum class Value {
                PACKAGE_WITH_ALLOCATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class PackageWithAllocationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): PackageWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                    apply {
                        additionalProperties =
                            packageWithAllocationConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): PackageWithAllocationConfig =
                    PackageWithAllocationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PackageWithAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackageWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageWithAllocationConfig, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackageWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithPercentPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        private val unitWithPercentConfig: JsonField<UnitWithPercentConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitWithPercentConfig(): UnitWithPercentConfig =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<UnitWithPercentConfig> = unitWithPercentConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithPercentPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithPercentConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithPercentConfig: JsonField<UnitWithPercentConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithPercentPrice: UnitWithPercentPrice) = apply {
                id = unitWithPercentPrice.id
                billableMetric = unitWithPercentPrice.billableMetric
                billingCycleConfiguration = unitWithPercentPrice.billingCycleConfiguration
                cadence = unitWithPercentPrice.cadence
                conversionRate = unitWithPercentPrice.conversionRate
                createdAt = unitWithPercentPrice.createdAt
                creditAllocation = unitWithPercentPrice.creditAllocation
                currency = unitWithPercentPrice.currency
                discount = unitWithPercentPrice.discount
                externalPriceId = unitWithPercentPrice.externalPriceId
                fixedPriceQuantity = unitWithPercentPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithPercentPrice.invoicingCycleConfiguration
                item = unitWithPercentPrice.item
                maximum = unitWithPercentPrice.maximum
                maximumAmount = unitWithPercentPrice.maximumAmount
                metadata = unitWithPercentPrice.metadata
                minimum = unitWithPercentPrice.minimum
                minimumAmount = unitWithPercentPrice.minimumAmount
                modelType = unitWithPercentPrice.modelType
                name = unitWithPercentPrice.name
                planPhaseOrder = unitWithPercentPrice.planPhaseOrder
                priceType = unitWithPercentPrice.priceType
                unitWithPercentConfig = unitWithPercentPrice.unitWithPercentConfig
                additionalProperties = unitWithPercentPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                apply {
                    this.unitWithPercentConfig = unitWithPercentConfig
                }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithPercentPrice =
                UnitWithPercentPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                UNIT_WITH_PERCENT,
            }

            enum class Value {
                UNIT_WITH_PERCENT,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitWithPercentConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitWithPercentConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                    additionalProperties = unitWithPercentConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitWithPercentConfig =
                    UnitWithPercentConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithPercentConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithPercentConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithPercentPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithPercentConfig == other.unitWithPercentConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithPercentConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithPercentPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithPercentConfig=$unitWithPercentConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun matrixWithAllocationConfig(): MatrixWithAllocationConfig =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfig> =
            matrixWithAllocationConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithAllocationConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithAllocationPrice: MatrixWithAllocationPrice) = apply {
                id = matrixWithAllocationPrice.id
                billableMetric = matrixWithAllocationPrice.billableMetric
                billingCycleConfiguration = matrixWithAllocationPrice.billingCycleConfiguration
                cadence = matrixWithAllocationPrice.cadence
                conversionRate = matrixWithAllocationPrice.conversionRate
                createdAt = matrixWithAllocationPrice.createdAt
                creditAllocation = matrixWithAllocationPrice.creditAllocation
                currency = matrixWithAllocationPrice.currency
                discount = matrixWithAllocationPrice.discount
                externalPriceId = matrixWithAllocationPrice.externalPriceId
                fixedPriceQuantity = matrixWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithAllocationPrice.invoicingCycleConfiguration
                item = matrixWithAllocationPrice.item
                matrixWithAllocationConfig = matrixWithAllocationPrice.matrixWithAllocationConfig
                maximum = matrixWithAllocationPrice.maximum
                maximumAmount = matrixWithAllocationPrice.maximumAmount
                metadata = matrixWithAllocationPrice.metadata
                minimum = matrixWithAllocationPrice.minimum
                minimumAmount = matrixWithAllocationPrice.minimumAmount
                modelType = matrixWithAllocationPrice.modelType
                name = matrixWithAllocationPrice.name
                planPhaseOrder = matrixWithAllocationPrice.planPhaseOrder
                priceType = matrixWithAllocationPrice.priceType
                additionalProperties = matrixWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixWithAllocationConfig(matrixWithAllocationConfig: MatrixWithAllocationConfig) =
                matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithAllocationPrice =
                MatrixWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixWithAllocationConfig
        @JsonCreator
        private constructor(
            @JsonProperty("allocation")
            @ExcludeMissing
            private val allocation: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            private val defaultUnitAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensions")
            @ExcludeMissing
            private val dimensions: JsonField<List<String?>> = JsonMissing.of(),
            @JsonProperty("matrix_values")
            @ExcludeMissing
            private val matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /** Allocation to be used to calculate the price */
            fun allocation(): Double = allocation.getRequired("allocation")

            /** Default per unit rate for any usage not bucketed into a specified matrix_value */
            fun defaultUnitAmount(): String = defaultUnitAmount.getRequired("default_unit_amount")

            /** One or two event property values to evaluate matrix groups by */
            fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

            /** Matrix values for specified matrix grouping keys */
            fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

            /** Allocation to be used to calculate the price */
            @JsonProperty("allocation")
            @ExcludeMissing
            fun _allocation(): JsonField<Double> = allocation

            /** Default per unit rate for any usage not bucketed into a specified matrix_value */
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            fun _defaultUnitAmount(): JsonField<String> = defaultUnitAmount

            /** One or two event property values to evaluate matrix groups by */
            @JsonProperty("dimensions")
            @ExcludeMissing
            fun _dimensions(): JsonField<List<String?>> = dimensions

            /** Matrix values for specified matrix grouping keys */
            @JsonProperty("matrix_values")
            @ExcludeMissing
            fun _matrixValues(): JsonField<List<MatrixValue>> = matrixValues

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                allocation()
                defaultUnitAmount()
                dimensions()
                matrixValues().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allocation: JsonField<Double>? = null
                private var defaultUnitAmount: JsonField<String>? = null
                private var dimensions: JsonField<MutableList<String?>>? = null
                private var matrixValues: JsonField<MutableList<MatrixValue>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixWithAllocationConfig: MatrixWithAllocationConfig) = apply {
                    allocation = matrixWithAllocationConfig.allocation
                    defaultUnitAmount = matrixWithAllocationConfig.defaultUnitAmount
                    dimensions = matrixWithAllocationConfig.dimensions.map { it.toMutableList() }
                    matrixValues =
                        matrixWithAllocationConfig.matrixValues.map { it.toMutableList() }
                    additionalProperties =
                        matrixWithAllocationConfig.additionalProperties.toMutableMap()
                }

                /** Allocation to be used to calculate the price */
                fun allocation(allocation: Double) = allocation(JsonField.of(allocation))

                /** Allocation to be used to calculate the price */
                fun allocation(allocation: JsonField<Double>) = apply {
                    this.allocation = allocation
                }

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: String) =
                    defaultUnitAmount(JsonField.of(defaultUnitAmount))

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                    this.defaultUnitAmount = defaultUnitAmount
                }

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                    this.dimensions = dimensions.map { it.toMutableList() }
                }

                /** One or two event property values to evaluate matrix groups by */
                fun addDimension(dimension: String) = apply {
                    dimensions =
                        (dimensions ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(dimension)
                        }
                }

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: List<MatrixValue>) =
                    matrixValues(JsonField.of(matrixValues))

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                    this.matrixValues = matrixValues.map { it.toMutableList() }
                }

                /** Matrix values for specified matrix grouping keys */
                fun addMatrixValue(matrixValue: MatrixValue) = apply {
                    matrixValues =
                        (matrixValues ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(matrixValue)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixWithAllocationConfig =
                    MatrixWithAllocationConfig(
                        checkRequired("allocation", allocation),
                        checkRequired("defaultUnitAmount", defaultUnitAmount),
                        checkRequired("dimensions", dimensions).map { it.toImmutable() },
                        checkRequired("matrixValues", matrixValues).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class MatrixValue
            @JsonCreator
            private constructor(
                @JsonProperty("dimension_values")
                @ExcludeMissing
                private val dimensionValues: JsonField<List<String?>> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 */
                fun dimensionValues(): List<String?> =
                    dimensionValues.getRequired("dimension_values")

                /** Unit price for the specified dimension_values */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 */
                @JsonProperty("dimension_values")
                @ExcludeMissing
                fun _dimensionValues(): JsonField<List<String?>> = dimensionValues

                /** Unit price for the specified dimension_values */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): MatrixValue = apply {
                    if (validated) {
                        return@apply
                    }

                    dimensionValues()
                    unitAmount()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    @JvmStatic fun builder() = Builder()
                }

                class Builder {

                    private var dimensionValues: JsonField<MutableList<String?>>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixValue: MatrixValue) = apply {
                        dimensionValues = matrixValue.dimensionValues.map { it.toMutableList() }
                        unitAmount = matrixValue.unitAmount
                        additionalProperties = matrixValue.additionalProperties.toMutableMap()
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: List<String?>) =
                        dimensionValues(JsonField.of(dimensionValues))

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                        this.dimensionValues = dimensionValues.map { it.toMutableList() }
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun addDimensionValue(dimensionValue: String) = apply {
                        dimensionValues =
                            (dimensionValues ?: JsonField.of(mutableListOf())).apply {
                                asKnown()
                                    .orElseThrow {
                                        IllegalStateException(
                                            "Field was set to non-list type: ${javaClass.simpleName}"
                                        )
                                    }
                                    .add(dimensionValue)
                            }
                    }

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixValue =
                        MatrixValue(
                            checkRequired("dimensionValues", dimensionValues).map {
                                it.toImmutable()
                            },
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixValue && dimensionValues == other.dimensionValues && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(dimensionValues, unitAmount, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixValue{dimensionValues=$dimensionValues, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixWithAllocationConfig && allocation == other.allocation && defaultUnitAmount == other.defaultUnitAmount && dimensions == other.dimensions && matrixValues == other.matrixValues && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allocation, defaultUnitAmount, dimensions, matrixValues, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithAllocationConfig{allocation=$allocation, defaultUnitAmount=$defaultUnitAmount, dimensions=$dimensions, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_ALLOCATION = of("matrix_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                MATRIX_WITH_ALLOCATION,
            }

            enum class Value {
                MATRIX_WITH_ALLOCATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Value.MATRIX_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Known.MATRIX_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithAllocationConfig == other.matrixWithAllocationConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithAllocationConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithAllocationConfig=$matrixWithAllocationConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredWithProrationConfig(): TieredWithProrationConfig =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<TieredWithProrationConfig> =
            tieredWithProrationConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithProrationConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithProrationPrice: TieredWithProrationPrice) = apply {
                id = tieredWithProrationPrice.id
                billableMetric = tieredWithProrationPrice.billableMetric
                billingCycleConfiguration = tieredWithProrationPrice.billingCycleConfiguration
                cadence = tieredWithProrationPrice.cadence
                conversionRate = tieredWithProrationPrice.conversionRate
                createdAt = tieredWithProrationPrice.createdAt
                creditAllocation = tieredWithProrationPrice.creditAllocation
                currency = tieredWithProrationPrice.currency
                discount = tieredWithProrationPrice.discount
                externalPriceId = tieredWithProrationPrice.externalPriceId
                fixedPriceQuantity = tieredWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithProrationPrice.invoicingCycleConfiguration
                item = tieredWithProrationPrice.item
                maximum = tieredWithProrationPrice.maximum
                maximumAmount = tieredWithProrationPrice.maximumAmount
                metadata = tieredWithProrationPrice.metadata
                minimum = tieredWithProrationPrice.minimum
                minimumAmount = tieredWithProrationPrice.minimumAmount
                modelType = tieredWithProrationPrice.modelType
                name = tieredWithProrationPrice.name
                planPhaseOrder = tieredWithProrationPrice.planPhaseOrder
                priceType = tieredWithProrationPrice.priceType
                tieredWithProrationConfig = tieredWithProrationPrice.tieredWithProrationConfig
                additionalProperties = tieredWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithProrationConfig(tieredWithProrationConfig: TieredWithProrationConfig) =
                tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithProrationPrice =
                TieredWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                TIERED_WITH_PRORATION,
            }

            enum class Value {
                TIERED_WITH_PRORATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) = apply {
                    additionalProperties =
                        tieredWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredWithProrationConfig =
                    TieredWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithProrationConfig == other.tieredWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithProrationConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithProrationConfig=$tieredWithProrationConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        private val unitWithProrationConfig: JsonField<UnitWithProrationConfig> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitWithProrationConfig(): UnitWithProrationConfig =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<UnitWithProrationConfig> = unitWithProrationConfig

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithProrationConfig().validate()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithProrationConfig: JsonField<UnitWithProrationConfig>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithProrationPrice: UnitWithProrationPrice) = apply {
                id = unitWithProrationPrice.id
                billableMetric = unitWithProrationPrice.billableMetric
                billingCycleConfiguration = unitWithProrationPrice.billingCycleConfiguration
                cadence = unitWithProrationPrice.cadence
                conversionRate = unitWithProrationPrice.conversionRate
                createdAt = unitWithProrationPrice.createdAt
                creditAllocation = unitWithProrationPrice.creditAllocation
                currency = unitWithProrationPrice.currency
                discount = unitWithProrationPrice.discount
                externalPriceId = unitWithProrationPrice.externalPriceId
                fixedPriceQuantity = unitWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithProrationPrice.invoicingCycleConfiguration
                item = unitWithProrationPrice.item
                maximum = unitWithProrationPrice.maximum
                maximumAmount = unitWithProrationPrice.maximumAmount
                metadata = unitWithProrationPrice.metadata
                minimum = unitWithProrationPrice.minimum
                minimumAmount = unitWithProrationPrice.minimumAmount
                modelType = unitWithProrationPrice.modelType
                name = unitWithProrationPrice.name
                planPhaseOrder = unitWithProrationPrice.planPhaseOrder
                priceType = unitWithProrationPrice.priceType
                unitWithProrationConfig = unitWithProrationPrice.unitWithProrationConfig
                additionalProperties = unitWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<UnitWithProrationConfig>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithProrationPrice =
                UnitWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                UNIT_WITH_PRORATION,
            }

            enum class Value {
                UNIT_WITH_PRORATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                    additionalProperties =
                        unitWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitWithProrationConfig =
                    UnitWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithProrationConfig == other.unitWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithProrationConfig, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithProrationConfig=$unitWithProrationConfig, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        private val groupedAllocationConfig: JsonField<GroupedAllocationConfig> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedAllocationConfig(): GroupedAllocationConfig =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<GroupedAllocationConfig> = groupedAllocationConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedAllocationConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedAllocationConfig: JsonField<GroupedAllocationConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedAllocationPrice: GroupedAllocationPrice) = apply {
                id = groupedAllocationPrice.id
                billableMetric = groupedAllocationPrice.billableMetric
                billingCycleConfiguration = groupedAllocationPrice.billingCycleConfiguration
                cadence = groupedAllocationPrice.cadence
                conversionRate = groupedAllocationPrice.conversionRate
                createdAt = groupedAllocationPrice.createdAt
                creditAllocation = groupedAllocationPrice.creditAllocation
                currency = groupedAllocationPrice.currency
                discount = groupedAllocationPrice.discount
                externalPriceId = groupedAllocationPrice.externalPriceId
                fixedPriceQuantity = groupedAllocationPrice.fixedPriceQuantity
                groupedAllocationConfig = groupedAllocationPrice.groupedAllocationConfig
                invoicingCycleConfiguration = groupedAllocationPrice.invoicingCycleConfiguration
                item = groupedAllocationPrice.item
                maximum = groupedAllocationPrice.maximum
                maximumAmount = groupedAllocationPrice.maximumAmount
                metadata = groupedAllocationPrice.metadata
                minimum = groupedAllocationPrice.minimum
                minimumAmount = groupedAllocationPrice.minimumAmount
                modelType = groupedAllocationPrice.modelType
                name = groupedAllocationPrice.name
                planPhaseOrder = groupedAllocationPrice.planPhaseOrder
                priceType = groupedAllocationPrice.priceType
                additionalProperties = groupedAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<GroupedAllocationConfig>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedAllocationPrice =
                GroupedAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedAllocationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                    additionalProperties =
                        groupedAllocationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedAllocationConfig =
                    GroupedAllocationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedAllocationConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                GROUPED_ALLOCATION,
            }

            enum class Value {
                GROUPED_ALLOCATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedAllocationConfig == other.groupedAllocationConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedAllocationConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithProratedMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        private val groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<GroupedWithProratedMinimumConfig> =
            groupedWithProratedMinimumConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithProratedMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithProratedMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice) =
                apply {
                    id = groupedWithProratedMinimumPrice.id
                    billableMetric = groupedWithProratedMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithProratedMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithProratedMinimumPrice.cadence
                    conversionRate = groupedWithProratedMinimumPrice.conversionRate
                    createdAt = groupedWithProratedMinimumPrice.createdAt
                    creditAllocation = groupedWithProratedMinimumPrice.creditAllocation
                    currency = groupedWithProratedMinimumPrice.currency
                    discount = groupedWithProratedMinimumPrice.discount
                    externalPriceId = groupedWithProratedMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithProratedMinimumPrice.fixedPriceQuantity
                    groupedWithProratedMinimumConfig =
                        groupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithProratedMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithProratedMinimumPrice.item
                    maximum = groupedWithProratedMinimumPrice.maximum
                    maximumAmount = groupedWithProratedMinimumPrice.maximumAmount
                    metadata = groupedWithProratedMinimumPrice.metadata
                    minimum = groupedWithProratedMinimumPrice.minimum
                    minimumAmount = groupedWithProratedMinimumPrice.minimumAmount
                    modelType = groupedWithProratedMinimumPrice.modelType
                    name = groupedWithProratedMinimumPrice.name
                    planPhaseOrder = groupedWithProratedMinimumPrice.planPhaseOrder
                    priceType = groupedWithProratedMinimumPrice.priceType
                    additionalProperties =
                        groupedWithProratedMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithProratedMinimumPrice =
                GroupedWithProratedMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedWithProratedMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedWithProratedMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithProratedMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedWithProratedMinimumConfig =
                    GroupedWithProratedMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithProratedMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                GROUPED_WITH_PRORATED_MINIMUM,
            }

            enum class Value {
                GROUPED_WITH_PRORATED_MINIMUM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithProratedMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithProratedMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithProratedMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithMeteredMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<GroupedWithMeteredMinimumConfig> =
            groupedWithMeteredMinimumConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithMeteredMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMeteredMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<GroupedWithMeteredMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice) =
                apply {
                    id = groupedWithMeteredMinimumPrice.id
                    billableMetric = groupedWithMeteredMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithMeteredMinimumPrice.cadence
                    conversionRate = groupedWithMeteredMinimumPrice.conversionRate
                    createdAt = groupedWithMeteredMinimumPrice.createdAt
                    creditAllocation = groupedWithMeteredMinimumPrice.creditAllocation
                    currency = groupedWithMeteredMinimumPrice.currency
                    discount = groupedWithMeteredMinimumPrice.discount
                    externalPriceId = groupedWithMeteredMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithMeteredMinimumPrice.fixedPriceQuantity
                    groupedWithMeteredMinimumConfig =
                        groupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithMeteredMinimumPrice.item
                    maximum = groupedWithMeteredMinimumPrice.maximum
                    maximumAmount = groupedWithMeteredMinimumPrice.maximumAmount
                    metadata = groupedWithMeteredMinimumPrice.metadata
                    minimum = groupedWithMeteredMinimumPrice.minimum
                    minimumAmount = groupedWithMeteredMinimumPrice.minimumAmount
                    modelType = groupedWithMeteredMinimumPrice.modelType
                    name = groupedWithMeteredMinimumPrice.name
                    planPhaseOrder = groupedWithMeteredMinimumPrice.planPhaseOrder
                    priceType = groupedWithMeteredMinimumPrice.priceType
                    additionalProperties =
                        groupedWithMeteredMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithMeteredMinimumPrice =
                GroupedWithMeteredMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedWithMeteredMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedWithMeteredMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithMeteredMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedWithMeteredMinimumConfig =
                    GroupedWithMeteredMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithMeteredMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                GROUPED_WITH_METERED_MINIMUM,
            }

            enum class Value {
                GROUPED_WITH_METERED_MINIMUM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithMeteredMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithMeteredMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMeteredMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithDisplayNamePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        private val matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<MatrixWithDisplayNameConfig> =
            matrixWithDisplayNameConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithDisplayNamePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithDisplayNameConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice) = apply {
                id = matrixWithDisplayNamePrice.id
                billableMetric = matrixWithDisplayNamePrice.billableMetric
                billingCycleConfiguration = matrixWithDisplayNamePrice.billingCycleConfiguration
                cadence = matrixWithDisplayNamePrice.cadence
                conversionRate = matrixWithDisplayNamePrice.conversionRate
                createdAt = matrixWithDisplayNamePrice.createdAt
                creditAllocation = matrixWithDisplayNamePrice.creditAllocation
                currency = matrixWithDisplayNamePrice.currency
                discount = matrixWithDisplayNamePrice.discount
                externalPriceId = matrixWithDisplayNamePrice.externalPriceId
                fixedPriceQuantity = matrixWithDisplayNamePrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithDisplayNamePrice.invoicingCycleConfiguration
                item = matrixWithDisplayNamePrice.item
                matrixWithDisplayNameConfig = matrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                maximum = matrixWithDisplayNamePrice.maximum
                maximumAmount = matrixWithDisplayNamePrice.maximumAmount
                metadata = matrixWithDisplayNamePrice.metadata
                minimum = matrixWithDisplayNamePrice.minimum
                minimumAmount = matrixWithDisplayNamePrice.minimumAmount
                modelType = matrixWithDisplayNamePrice.modelType
                name = matrixWithDisplayNamePrice.name
                planPhaseOrder = matrixWithDisplayNamePrice.planPhaseOrder
                priceType = matrixWithDisplayNamePrice.priceType
                additionalProperties =
                    matrixWithDisplayNamePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithDisplayNamePrice =
                MatrixWithDisplayNamePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixWithDisplayNameConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixWithDisplayNameConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                    apply {
                        additionalProperties =
                            matrixWithDisplayNameConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixWithDisplayNameConfig =
                    MatrixWithDisplayNameConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixWithDisplayNameConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithDisplayNameConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                MATRIX_WITH_DISPLAY_NAME,
            }

            enum class Value {
                MATRIX_WITH_DISPLAY_NAME,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithDisplayNamePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithDisplayNameConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithDisplayNamePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkWithProrationConfig(): BulkWithProrationConfig =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<BulkWithProrationConfig> = bulkWithProrationConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkWithProrationConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkWithProrationPrice: BulkWithProrationPrice) = apply {
                id = bulkWithProrationPrice.id
                billableMetric = bulkWithProrationPrice.billableMetric
                billingCycleConfiguration = bulkWithProrationPrice.billingCycleConfiguration
                bulkWithProrationConfig = bulkWithProrationPrice.bulkWithProrationConfig
                cadence = bulkWithProrationPrice.cadence
                conversionRate = bulkWithProrationPrice.conversionRate
                createdAt = bulkWithProrationPrice.createdAt
                creditAllocation = bulkWithProrationPrice.creditAllocation
                currency = bulkWithProrationPrice.currency
                discount = bulkWithProrationPrice.discount
                externalPriceId = bulkWithProrationPrice.externalPriceId
                fixedPriceQuantity = bulkWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithProrationPrice.invoicingCycleConfiguration
                item = bulkWithProrationPrice.item
                maximum = bulkWithProrationPrice.maximum
                maximumAmount = bulkWithProrationPrice.maximumAmount
                metadata = bulkWithProrationPrice.metadata
                minimum = bulkWithProrationPrice.minimum
                minimumAmount = bulkWithProrationPrice.minimumAmount
                modelType = bulkWithProrationPrice.modelType
                name = bulkWithProrationPrice.name
                planPhaseOrder = bulkWithProrationPrice.planPhaseOrder
                priceType = bulkWithProrationPrice.priceType
                additionalProperties = bulkWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkWithProrationPrice =
                BulkWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                    additionalProperties =
                        bulkWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkWithProrationConfig =
                    BulkWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                BULK_WITH_PRORATION,
            }

            enum class Value {
                BULK_WITH_PRORATION,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkWithProrationConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        private val groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedTieredPackageConfig(): GroupedTieredPackageConfig =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): Item = item.getRequired("item")

        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<GroupedTieredPackageConfig> =
            groupedTieredPackageConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredPackageConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            @JvmStatic fun builder() = Builder()
        }

        class Builder {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPackagePrice: GroupedTieredPackagePrice) = apply {
                id = groupedTieredPackagePrice.id
                billableMetric = groupedTieredPackagePrice.billableMetric
                billingCycleConfiguration = groupedTieredPackagePrice.billingCycleConfiguration
                cadence = groupedTieredPackagePrice.cadence
                conversionRate = groupedTieredPackagePrice.conversionRate
                createdAt = groupedTieredPackagePrice.createdAt
                creditAllocation = groupedTieredPackagePrice.creditAllocation
                currency = groupedTieredPackagePrice.currency
                discount = groupedTieredPackagePrice.discount
                externalPriceId = groupedTieredPackagePrice.externalPriceId
                fixedPriceQuantity = groupedTieredPackagePrice.fixedPriceQuantity
                groupedTieredPackageConfig = groupedTieredPackagePrice.groupedTieredPackageConfig
                invoicingCycleConfiguration = groupedTieredPackagePrice.invoicingCycleConfiguration
                item = groupedTieredPackagePrice.item
                maximum = groupedTieredPackagePrice.maximum
                maximumAmount = groupedTieredPackagePrice.maximumAmount
                metadata = groupedTieredPackagePrice.metadata
                minimum = groupedTieredPackagePrice.minimum
                minimumAmount = groupedTieredPackagePrice.minimumAmount
                modelType = groupedTieredPackagePrice.modelType
                name = groupedTieredPackagePrice.name
                planPhaseOrder = groupedTieredPackagePrice.planPhaseOrder
                priceType = groupedTieredPackagePrice.priceType
                additionalProperties = groupedTieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentageDiscount: PercentageDiscount) =
                discount(Discount.ofPercentageDiscount(percentageDiscount))

            fun discount(trialDiscount: TrialDiscount) =
                discount(Discount.ofTrialDiscount(trialDiscount))

            fun discount(usageDiscount: Discount.UsageDiscount) =
                discount(Discount.ofUsageDiscount(usageDiscount))

            fun discount(amountDiscount: AmountDiscount) =
                discount(Discount.ofAmountDiscount(amountDiscount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredPackageConfig(groupedTieredPackageConfig: GroupedTieredPackageConfig) =
                groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPackagePrice =
                GroupedTieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            fun currency(): String = currency.getRequired("currency")

            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedTieredPackageConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredPackageConfig: GroupedTieredPackageConfig) = apply {
                    additionalProperties =
                        groupedTieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedTieredPackageConfig =
                    GroupedTieredPackageConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun duration(): Long = duration.getRequired("duration")

            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(
                private val value: JsonField<String>,
            ) : Enum {

                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                enum class Known {
                    DAY,
                    MONTH,
                }

                enum class Value {
                    DAY,
                    MONTH,
                    _UNKNOWN,
                }

                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                fun asString(): String = _value().asStringOrThrow()

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            fun id(): String = id.getRequired("id")

            fun name(): String = name.getRequired("name")

            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Maximum amount applied */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Maximum amount applied */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /** Minimum amount applied */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /** Minimum amount applied */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                @JvmStatic fun builder() = Builder()
            }

            class Builder {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).apply {
                            asKnown()
                                .orElseThrow {
                                    IllegalStateException(
                                        "Field was set to non-list type: ${javaClass.simpleName}"
                                    )
                                }
                                .add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            enum class Known {
                GROUPED_TIERED_PACKAGE,
            }

            enum class Value {
                GROUPED_TIERED_PACKAGE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType
        @JsonCreator
        private constructor(
            private val value: JsonField<String>,
        ) : Enum {

            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                _UNKNOWN,
            }

            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            fun asString(): String = _value().asStringOrThrow()

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredPackageConfig == other.groupedTieredPackageConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredPackageConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredPackageConfig=$groupedTieredPackageConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, additionalProperties=$additionalProperties}"
    }
}
